[{"content":"go build 这个命令主要用于编译代码。在包的编译过程中，若有必要，会同时编译与之相关联的包。\n如果是普通包，就像我们在1.2节中编写的mymath包那样，当你执行go build之后，它不会产生任何文件。如果你需要在$GOPATH/pkg下生成相应的文件，那就得执行go install。\n如果是main包，当你执行go build之后，它就会在当前目录下生成一个可执行文件。如果你需要在$GOPATH/bin下生成相应的文件，需要执行go install，或者使用go build -o 路径/a.exe。\n如果某个项目文件夹下有多个文件，而你只想编译某个文件，就可在go build之后加上文件名，例如go build a.go；go build命令默认会编译当前目录下的所有go文件。\n你也可以指定编译输出的文件名。例如1.2节中的mathapp应用，我们可以指定go build -o astaxie.exe，默认情况是你的package名(非main包)，或者是第一个源文件的文件名(main包)。\n（注：实际上，package名在Go语言规范中指代码中“package”后使用的名称，此名称可以与文件夹名不同。默认生成的可执行文件名是文件夹名。）\ngo build会忽略目录下以“_”或“.”开头的go文件。\n如果你的源代码针对不同的操作系统需要不同的处理，那么你可以根据不同的操作系统后缀来命名文件。例如有一个读取数组的程序，它对于不同的操作系统可能有如下几个源文件：\narray_linux.go array_darwin.go array_windows.go array_freebsd.go\ngo build的时候会选择性地编译以系统名结尾的文件（Linux、Darwin、Windows、Freebsd）。例如Linux系统下面编译只会选择array_linux.go文件，其它系统命名后缀文件全部忽略。\n参数的介绍\n-o 指定输出的文件名，可以带上路径，例如 go build -o a/b/c -i 安装相应的包，编译+go install -a 更新全部已经是最新的包的，但是对标准包不适用 -n 把需要执行的编译命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的 -p n 指定可以并行可运行的编译数目，默认是CPU数目 -race 开启编译的时候自动检测数据竞争的情况，目前只支持64位的机器 -v 打印出来我们正在编译的包名 -work 打印出来编译时候的临时文件夹名称，并且如果已经存在的话就不要删除 -x 打印出来执行的命令，其实就是和-n的结果类似，只是这个会执行 -ccflags 'arg list' 传递参数给5c, 6c, 8c 调用 -compiler name 指定相应的编译器，gccgo还是gc -gccgoflags 'arg list' 传递参数给gccgo编译连接调用 -gcflags 'arg list' 传递参数给5g, 6g, 8g 调用 -installsuffix suffix 为了和默认的安装包区别开来，采用这个前缀来重新安装那些依赖的包，-race的时候默认已经是-installsuffix race,大家可以通过-n命令来验证 -ldflags 'flag list' 传递参数给5l, 6l, 8l 调用 -tags 'tag list' 设置在编译的时候可以适配的那些tag，详细的tag限制参考里面的 Build Constraints go clean 这个命令是用来移除当前源码包和关联源码包里面编译生成的文件。这些文件包括\n_obj/ 旧的object目录，由Makefiles遗留\r_test/ 旧的test目录，由Makefiles遗留\r_testmain.go 旧的gotest文件，由Makefiles遗留\rtest.out 旧的test记录，由Makefiles遗留\rbuild.out 旧的test记录，由Makefiles遗留\r*.[568ao] object文件，由Makefiles遗留\rDIR(.exe) 由go build产生\rDIR.test(.exe) 由go test -c产生\rMAINFILE(.exe) 由go build MAINFILE.go产生\r*.so 由 SWIG 产生\r我一般都是利用这个命令清除编译文件，然后GitHub递交源码，在本机测试的时候这些编译文件都是和系统相关的，但是对于源码管理来说没必要。\n$ go clean -i -n\rcd /Users/astaxie/develop/gopath/src/mathapp\rrm -f mathapp mathapp.exe mathapp.test mathapp.test.exe app app.exe\rrm -f /Users/astaxie/develop/gopath/bin/mathapp\r参数介绍\n-i 清除关联的安装的包和可运行文件，也就是通过go install安装的文件 -n 把需要执行的清除命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的 -r 循环的清除在import中引入的包 -x 打印出来执行的详细命令，其实就是-n打印的执行版本 go fmt 有过C/C++经验的读者会知道,一些人经常为代码采取K\u0026amp;R风格还是ANSI风格而争论不休。在go中，代码则有标准的风格。由于之前已经有的一些习惯或其它的原因我们常将代码写成ANSI风格或者其它更合适自己的格式，这将为人们在阅读别人的代码时添加不必要的负担，所以go强制了代码格式（比如左大括号必须放在行尾），不按照此格式的代码将不能编译通过，为了减少浪费在排版上的时间，go工具集中提供了一个go fmt命令 它可以帮你格式化你写好的代码文件，使你写代码的时候不需要关心格式，你只需要在写完之后执行go fmt \u0026lt;文件名\u0026gt;.go，你的代码就被修改成了标准格式，但是我平常很少用到这个命令，因为开发工具里面一般都带了保存时候自动格式化功能，这个功能其实在底层就是调用了go fmt。接下来的一节我将讲述两个工具，这两个工具都自带了保存文件时自动化go fmt功能。\n使用go fmt命令，其实是调用了gofmt，而且需要参数-w，否则格式化结果不会写入文件。gofmt -w -l src，可以格式化整个项目。\n所以go fmt是gofmt的上层一个包装的命令，我们想要更多的个性化的格式化可以参考 gofmt\ngofmt的参数介绍\n-l 显示那些需要格式化的文件 -w 把改写后的内容直接写入到文件中，而不是作为结果打印到标准输出。 -r 添加形如“a[b:len(a)] -\u0026gt; a[b:]”的重写规则，方便我们做批量替换 -s 简化文件中的代码 -d 显示格式化前后的diff而不是写入文件，默认是false -e 打印所有的语法错误到标准输出。如果不使用此标记，则只会打印不同行的前10个错误。 -cpuprofile 支持调试模式，写入相应的cpufile到指定的文件 go get 这个命令是用来动态获取远程代码包的，目前支持的有BitBucket、GitHub、Google Code和Launchpad。这个命令在内部实际上分成了两步操作：第一步是下载源码包，第二步是执行go install。下载源码包的go工具会自动根据不同的域名调用不同的源码工具，对应关系如下：\nBitBucket (Mercurial Git)\rGitHub (Git)\rGoogle Code Project Hosting (Git, Mercurial, Subversion)\rLaunchpad (Bazaar)\r所以为了go get 能正常工作，你必须确保安装了合适的源码管理工具，并同时把这些命令加入你的PATH中。其实go get支持自定义域名的功能，具体参见go help remote。\n参数介绍：\n-d 只下载不安装 -f 只有在你包含了-u参数的时候才有效，不让-u去验证import中的每一个都已经获取了，这对于本地fork的包特别有用 -fix 在获取源码之后先运行fix，然后再去做其他的事情 -t 同时也下载需要为运行测试所需要的包 -u 强制使用网络去更新包和它的依赖包 -v 显示执行的命令 go install 这个命令在内部实际上分成了两步操作：第一步是生成结果文件(可执行文件或者.a包)，第二步会把编译好的结果移到$GOPATH/pkg或者$GOPATH/bin。\n参数支持go build的编译参数。大家只要记住一个参数-v就好了，这个随时随地的可以查看底层的执行信息。\ngo test 执行这个命令，会自动读取源码目录下面名为*_test.go的文件，生成并运行测试用的可执行文件。输出的信息类似\nok archive/tar 0.011s\rFAIL archive/zip 0.022s\rok compress/gzip 0.033s\r...\r默认的情况下，不需要任何的参数，它会自动把你源码包下面所有test文件测试完毕，当然你也可以带上参数，详情请参考go help testflag\n这里我介绍几个我们常用的参数：\n-bench regexp 执行相应的benchmarks，例如 -bench=. -cover 开启测试覆盖率 -run regexp 只运行regexp匹配的函数，例如 -run=Array 那么就执行包含有Array开头的函数 -v 显示测试的详细命令 go tool go tool下面下载聚集了很多命令，这里我们只介绍两个，fix和vet\ngo tool fix . 用来修复以前老版本的代码到新版本，例如go1之前老版本的代码转化到go1,例如API的变化 go tool vet directory|files 用来分析当前目录的代码是否都是正确的代码,例如是不是调用fmt.Printf里面的参数不正确，例如函数里面提前return了然后出现了无用代码之类的。 go generate 这个命令是从Go1.4开始才设计的，用于在编译前自动化生成某类代码。go generate和go build是完全不一样的命令，通过分析源码中特殊的注释，然后执行相应的命令。这些命令都是很明确的，没有任何的依赖在里面。而且大家在用这个之前心里面一定要有一个理念，这个go generate是给你用的，不是给使用你这个包的人用的，是方便你来生成一些代码的。\n这里我们来举一个简单的例子，例如我们经常会使用yacc来生成代码，那么我们常用这样的命令：\ngo tool yacc -o gopher.go -p parser gopher.y\r-o 指定了输出的文件名， -p指定了package的名称，这是一个单独的命令，如果我们想让go generate来触发这个命令，那么就可以在当前目录的任意一个xxx.go文件里面的任意位置增加一行如下的注释：\n//go:generate go tool yacc -o gopher.go -p parser gopher.y\r这里我们注意了，//go:generate是没有任何空格的，这其实就是一个固定的格式，在扫描源码文件的时候就是根据这个来判断的。\n所以我们可以通过如下的命令来生成，编译，测试。如果gopher.y文件有修改，那么就重新执行go generate重新生成文件就好。\n$ go generate\r$ go build\r$ go test\rgodoc 在Go1.2版本之前还支持go doc命令，但是之后全部移到了godoc这个命令下，需要这样安装go get golang.org/x/tools/cmd/godoc\n很多人说go不需要任何的第三方文档，例如chm手册之类的（其实我已经做了一个了，chm手册），因为它内部就有一个很强大的文档工具。\n如何查看相应package的文档呢？ 例如builtin包，那么执行godoc builtin 如果是http包，那么执行godoc net/http 查看某一个包里面的函数，那么执行godoc fmt Printf 也可以查看相应的代码，执行godoc -src fmt Printf\n通过命令在命令行执行 godoc -http=:端口号 比如godoc -http=:8080。然后在浏览器中打开127.0.0.1:8080，你将会看到一个golang.org的本地copy版本，通过它你可以查询pkg文档等其它内容。如果你设置了GOPATH，在pkg分类下，不但会列出标准包的文档，还会列出你本地GOPATH中所有项目的相关文档，这对于经常被墙的用户来说是一个不错的选择。\n其它命令 go还提供了其它很多的工具，例如下面的这些工具\ngo version 查看go当前的版本\rgo env 查看当前go的环境变量\rgo list 列出当前全部安装的package\rgo run 编译并运行Go程序\r以上这些工具还有很多参数没有一一介绍，用户可以使用go help 命令获取更详细的帮助信息。\n","permalink":"https://liiqii.github.io/posts/tech/go/command/","summary":"go build 这个命令主要用于编译代码。在包的编译过程中，若有必要，会同时编译与之相关联的包。 如果是普通包，就像我们在1.2节中编写的mymath包那样，当你执行go build之后，它不会产生任何文件。如果你需要在$GOPATH/pkg下生成相应的文件，那就得执行go install。 如果是","title":"Go 命令"},{"content":"1.冒泡排序 从头开始两两互比然后进行交换。将最大值/最小值 冒到最后一位。依次循环\nfunc bubbleSort(nums []int){ for i:=0;i\u0026lt;len(nums)-1;i++{ // 循环次数 for j:=0;j\u0026lt;len(nums)-1-i;j++{ // 数组内相邻元素比较 if nums[j]\u0026gt;nums[j+1]{ // 交换条件 nums[j],nums[j+1]=nums[j+1],nums[j] // 元素交换 } } } } 2.选择排序 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置; 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾; （一次在元素中选择符合需求的元素，然后交换。每个元素只移动一次）\nfunc selectSorted(nums []int) { for i := 0; i \u0026lt; len(nums)-1; i++ { // 从第一个元素开始 min := i // 默认当前元素为最小元素。保存对应下标 for j := i + 1; j \u0026lt; len(nums); j++ { if nums[min] \u0026gt; nums[j] { // 找到最小的元素 min = j // 保存最小的值min(下标) } } nums[i], nums[min] = nums[min], nums[i] //交换元素 } } 3.插入排序 可以假设前面的已经有序，随机在后面抽取一个元素，插入到前面，并保持有序； 已排好序的依次后移！！！ （扑克牌：每拿起一张，插入到合适的位置。之前的已经有序）\nfunc insertSorted(nums []int) { for i := 1; i \u0026lt; len(nums); i++ { preIndex := i - 1 // 记录当前值对应前一个元素的下标 nowNum := nums[i] // 记录当前值 for nums[preIndex] \u0026gt; nowNum { // 循环到前面的值不小于当前值为止 nums[preIndex+1] = nums[preIndex] // 将小于当前值的数后移 preIndex-- } nums[preIndex+1] = nowNum // 找到了不小于当前置的位置并赋值 } } 4.希尔排序 本质是 分组+插入排序 也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是 非稳定 排序算法。 实践中：数据的交换次数远远小于插入排序的交换次数\nfunc shellSorted(nums []int) { lens := len(nums) tag := 1 // 选取合适的分组树(即：每组的数据个数) for tag \u0026lt; lens/3 { tag = 3*tag + 1 // 比较合适的分组数 } for tag \u0026gt; 0 { for i := tag; i \u0026lt; lens; i++ { // 依旧采用插入算法逻辑，只是跨度变大，以分组为间隔 j := i - tag temp := nums[i] for j \u0026gt;= 0 \u0026amp;\u0026amp; nums[j] \u0026gt; temp { nums[j+tag] = nums[j] j -= tag } nums[j+tag] = temp } tag /= 3 // tag逐渐缩小，最后为 1 } } 5.归并排序 乱序数组，单个元素为一组，两两对比排序；然后已排序数据2个为一组，两两对比排序，以此类推 总结：先分后合(合的时候排好序)\nfunc mergeSorted(nums []int) []int { length := len(nums) if length \u0026lt; 2 { return nums } left := nums[:length/2] right := nums[length/2:] return merge(mergeSorted(left), mergeSorted(right)) } //传入的两个数组进行合并排序 func merge(left []int, right []int) []int { var res []int // 两数组对比，小的先放入结果表 for len(left) \u0026gt; 0 \u0026amp;\u0026amp; len(right) \u0026gt; 0 { if left[0] \u0026lt;= right[0] { res = append(res, left[0]) left = left[1:] } else { res = append(res, right[0]) right = right[1:] } } // left或者right其中一个未添加完毕 if len(left) \u0026gt; 0 { res = append(res, left...) } if len(right) \u0026gt; 0 { res = append(res, right...) } return res } 6.快速排序 在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较 随机取一个树(一般是第一个数)，一次比较，比他小的放左边，大的放右边，依次类推 个人感觉：和归并反着来！ 每一次分开，左右都对应已比较完成！ 1、从数列中挑出一个元素，称为 “基准”（pivot）; 2、重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 3、递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序； 优化： 1、机选三个数，取中间的数为 基准 2、当数组比较小的时候采用插入算法，更快\nfunc quickSorted(nums []int) []int { return quick(nums, 0, len(nums)-1) } func quick(arr []int, left, right int) []int { if left \u0026lt; right { //分次执行 partitionVal := partition(arr, left, right) quick(arr, left, partitionVal-1) // 先递归把左边的排完 quick(arr, partitionVal+1, right) // 再依次由深到浅排序右边 } return arr } func partition(arr []int, left, right int) int { pivot := left index := left + 1 for i := index; i \u0026lt;= right; i++ { if arr[i] \u0026lt; arr[pivot] { swap(arr, i, index) // 调换基数的位置 index++ } } swap(arr, pivot, index-1) //最后一个空位补上 return index - 1 } func swap(arr []int, left, right int) { arr[left], arr[right] = arr[right], arr[left] } 7.堆排序 堆的特点: 完全二叉树、（大顶堆) 所有父节点大于子节点 1、构建一个堆(所有值小于父节点) 2、把堆首和队尾互换 3、堆的大小减一，并重构堆，目的是把最大值放入堆头 4、重复2/3\n// 堆排序的实现 // 1、建堆 // 2、堆尾和堆头互换，取出堆头，堆容量缩小一个单位 // 3、重读1/2 // 传入一个数组 func heapSorted(arr []int) []int { arrlen := len(arr) buildHeap(arr, arrlen) fmt.Println(arr) // 堆已建造完成，堆头与堆尾交换，堆长减一 for arrlen \u0026gt; 0 { swap(arr, 0, arrlen-1) arrlen -= 1 heapify(arr, 0, arrlen) } return arr } // 将数组建造成堆格式 func buildHeap(arr []int, arrlen int) { for i := arrlen / 2; i \u0026gt;= 0; i-- { heapify(arr, i, arrlen) } } // 实际down与swap过程 func heapify(arr []int, i, arrlen int) { left := 2*i + 1 right := 2*i + 2 parent := i // 比较时，找出left与right对应的最大值与之兑换 if left \u0026lt; arrlen \u0026amp;\u0026amp; arr[left] \u0026gt; arr[parent] { parent = left } if right \u0026lt; arrlen \u0026amp;\u0026amp; arr[right] \u0026gt; arr[parent] { parent = right } if parent != i { swap(arr, i, parent) // 用来排除孩子的孩子(第一次建堆时作用可能不大，但是当后面互换后 ，堆顶元素一路向下) heapify(arr, parent, arrlen) } } // 用于两个元素交换 func swap(arr []int, i, j int) { arr[i], arr[j] = arr[j], arr[i] } 8.计数排序 1、根据待排序集合中最大元素和最小元素的差值范围，申请额外空间； 2、遍历待排序集合，将每一个元素出现的次数记录到元素值对应的额外空间内； 3、对额外空间内数据进行计算，得出每一个元素的正确位置； 4、将待排序集合每一个元素移动到计算得出的正确位置上。 即： 将相同的数，统计出现次数，然后从小到大，把该数取出对应的次数\n// 计数排序(一般用书较集中数据) // 先确定取值范围 // 创建范围内大小的值，统计 // 注：需要额外空间 func counrSorted(arr []int) []int { // 先获取取值范围大小 // 考虑可能存在负数（两次遍历） min, max := 0, 0 for i := 0; i \u0026lt; len(arr); i++ { if arr[i] \u0026gt; max { max = arr[i] } if arr[i] \u0026lt; min { min = arr[i] } } // 创建计数器 blen := max - min + 1 bucket := make([]int, blen) fmt.Println(blen) // 统计 for i := 0; i \u0026lt; len(arr); i++ { bucket[arr[i]-min] += 1 } // 原数组中移动 index := 0 for i := 0; i \u0026lt; len(bucket); i++ { for bucket[i] \u0026gt; 0 { arr[index] = i - min index++ bucket[i]-- } } return arr } 9.桶排序 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。 桶排序 (Bucket sort)的工作的原理： 假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排） 计数排序时对单个数据，桶排序是对一组数据。分配再排序\nfunc bucketSorted(arr []int){ vari; varminValue = arr[0]; varmaxValue = arr[0]; for(i = 1; i \u0026lt; arr.length; i++) { if(arr[i] \u0026lt; minValue) { minValue = arr[i]; // 输入数据的最小值 }elseif(arr[i] \u0026gt; maxValue) { maxValue = arr[i]; // 输入数据的最大值 } } // 桶的初始化 varDEFAULT_BUCKET_SIZE = 5; // 设置桶的默认数量为5 bucketSize = bucketSize || DEFAULT_BUCKET_SIZE; varbucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; varbuckets =newArray(bucketCount); for(i = 0; i \u0026lt; buckets.length; i++) { buckets[i] = []; } // 利用映射函数将数据分配到各个桶中 for(i = 0; i \u0026lt; arr.length; i++) { buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]); } arr.length = 0; for(i = 0; i \u0026lt; buckets.length; i++) { insertionSort(buckets[i]); // 对每个桶进行排序，这里使用了插入排序 for(varj = 0; j \u0026lt; buckets[i].length; j++) { arr.push(buckets[i][j]); } } return arr; } 10.基数排序 基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数 对数字或者字符串进行拆分，单个对比的排序。以此类推\n// 基数排序 func radixSorted(arr []int) []int { // 统计最大子串长度 max := -1 length := len(arr) // 获取最大数 for i := 0; i \u0026lt; length; i++ { if max \u0026lt; arr[i] { max = arr[i] } } // 获取最大位数 maxlen := 0 for max \u0026gt; 0 { maxlen++ max /= 10 } // 开始 bucket := [10][20]int{{0}} count := [10]int{0} divisor := 1 for i := 1; i \u0026lt;= maxlen; i++ { // 先放入桶中，然后排好序，依次类推 for j := 0; j \u0026lt; length; j++ { tmp := arr[j] index := (tmp / divisor) % 10 bucket[index][count[index]] = tmp count[index]++ } // 原数组重新排序 k := 0 for m := 0; m \u0026lt; len(bucket); m++ { if count[m] == 0 { continue } for n := 0; n \u0026lt; count[n]; n++ { arr[k] = bucket[m][n] k++ } // 桶清零 bucket[m] = [20]int{0} } divisor *= 10 } return arr } ","permalink":"https://liiqii.github.io/posts/tech/go/sort_algo/","summary":"1.冒泡排序 从头开始两两互比然后进行交换。将最大值/最小值 冒到最后一位。依次循环 func bubbleSort(nums []int){ for i:=0;i\u0026lt;len(nums)-1;i++{ // 循环次数 for j:=0;j\u0026lt;len(nums)-1-i;j++{ // 数组内相邻元素比较 if nums[j]\u0026gt;nums[j+1]{ // 交换条件 nums[j],nums[j+1]=nums[j+1],nums[j] // 元素交换 } } } } 2.选择排序 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置; 再从剩余未排序元素中继续寻找最小（大）元素，然后放","title":"Go 排序算法实现"},{"content":"1. 正则表达式语法 正则表达式是一种用于匹配和操作文本的强大工具，它使用特殊的字符和语法来定义模式。在 Golang 的 regexp 包中，使用的正则表达式语法是基于标准的 POSIX 正则表达式语法的一个子集。\n以下是一些常用的正则表达式元字符：\n. ：匹配任意单个字符，除了换行符。 * ：匹配前面的元素零次或多次。 + ：匹配前面的元素一次或多次。 ? ：匹配前面的元素零次或一次。 ^ ：匹配字符串的开头。 $ ：匹配字符串的结尾。 [] ：字符类，匹配方括号中的任意字符。 [^] ：否定字符类，匹配除方括号中字符以外的任意字符。 | ：逻辑或，匹配两个模式之一。 () ：捕获组，用于分组和提取匹配的子字符串。 示例代码：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;Hello, World!\u0026#34; re := regexp.MustCompile(`H.llo`) fmt.Println(re.MatchString(str)) // true } 在上面的示例中，我们创建了一个正则表达式对象 re，它使用了.元字符来匹配 H 后面的任意字符，然后是 llo。我们使用 MatchString 方法来检查字符串 str 是否匹配该正则表达式，它将返回 true。\n2. 创建正则表达式对象 在 Golang 中，要使用正则表达式进行匹配，首先需要创建一个正则表达式对象。可以使用 regexp.Compile 函数或正则表达式字面量来创建对象。\n示例代码：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;Hello, World!\u0026#34; re := regexp.MustCompile(`[aeiou]`) fmt.Println(re.MatchString(str)) // true } 当我们运行上述代码时，它将打印出 true，因为正则表达式 [aeiou] 匹配字符串中的任何一个元音字母。\n在上面的示例中，我们使用 regexp.MustCompile 函数创建了一个正则表达式对象 re，该函数接受一个字符串参数，表示正则表达式的模式。这个函数会编译正则表达式并返回一个可用于匹配的正则表达式对象。\n另外，你还可以使用正则表达式字面量来创建正则表达式对象，如下所示：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;Hello, World!\u0026#34; re := `[aeiou]` match, _ := regexp.MatchString(re, str) fmt.Println(match) // true } 在这个示例中，我们直接将正则表达式模式作为字符串赋值给变量 re，然后使用 regexp.MatchString 函数检查字符串 str 是否与正则表达式匹配。这个函数返回一个布尔值表示匹配结果。\n无论是使用 regexp.MustCompile 函数还是正则表达式字面量，都会创建一个正则表达式对象，该对象可以在后续的匹配操作中使用。\n3. 字符串匹配 使用 Golang 的 regexp 包，你可以对字符串进行正则表达式匹配操作。下面是一些常用的方法：\nMatchString(pattern, s string) bool：检查字符串 s 是否与正则表达式模式 pattern 匹配，返回一个布尔值表示匹配结果。 Match(pattern string, b []byte) (matched bool, err error)：检查字节切片 b 是否与正则表达式模式 pattern 匹配，返回一个布尔值表示匹配结果。 示例代码：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;Hello, World!\u0026#34; re := regexp.MustCompile(`^Hello`) fmt.Println(re.MatchString(str)) // true } 在上面的示例中，我们使用 MatchString 方法检查字符串 str 是否以 Hello 开头。由于 str 的开头确实是 Hello，所以匹配结果为 true。\n另外，你也可以使用 Match 方法来检查字节切片是否与正则表达式匹配。例如：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := []byte(\u0026#34;Hello, World!\u0026#34;) re := regexp.MustCompile(`^Hello`) matched, _ := re.Match(str) fmt.Println(matched) // true } 在这个示例中，我们将字符串 str 转换为字节切片，并使用 Match 方法来检查它是否以 Hello 开头。同样，由于匹配成功，所以输出为 true。\n通过使用这些方法，你可以轻松地检查字符串是否符合特定的正则表达式模式。\n4. 字符串替换 在 Golang 的 regexp 包中，你可以使用正则表达式来进行字符串替换操作。以下是常用的方法：\nReplaceAllString(src, repl, pattern string) string：将字符串 src 中所有匹配正则表达式模式 pattern 的部分替换为 repl，并返回替换后的新字符串。 ReplaceAllStringFunc(src string, repl func(string) string, pattern string) string：根据匹配的正则表达式模式 pattern，使用 repl 函数对字符串 src 进行替换，并返回替换后的新字符串。repl 函数接收匹配的字符串作为参数，并返回替换后的字符串。 示例代码：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;Hello, Golang!\u0026#34; re := regexp.MustCompile(`Golang`) newStr := re.ReplaceAllString(str, \u0026#34;World\u0026#34;) fmt.Println(newStr) // Hello, World! } 在上面的示例中，我们使用 ReplaceAllString 方法将字符串 str 中的 Golang 替换为 World。替换后的新字符串存储在变量 newStr 中，并打印输出结果为 Hello, World!。\n如果你想根据匹配的字符串来动态替换内容，可以使用 ReplaceAllStringFunc 方法。例如：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; \u0026#34;strings\u0026#34; ) func main() { str := \u0026#34;Hello, Golang!\u0026#34; re := regexp.MustCompile(`\\w+`) newStr := re.ReplaceAllStringFunc(str, strings.ToUpper) fmt.Println(newStr) // HELLO, GOLANG! } 在这个示例中，我们使用 ReplaceAllStringFunc 方法将字符串 str 中的每个单词转换为大写。我们提供了 strings.ToUpper 函数作为替换函数，该函数将匹配的字符串转换为大写形式。结果输出为 HELLO, GOLANG!。\n通过这些方法，你可以对字符串进行灵活的替换操作，根据正则表达式模式来实现各种替换需求。\n5. 捕获组 在正则表达式中，捕获组是用括号括起来的子表达式，它们允许你在匹配中提取特定的子字符串。Golang 的 regexp 包提供了多个方法来处理捕获组。\nFindStringSubmatch(s string) []string：返回一个字符串切片，其中包含与正则表达式模式匹配的子字符串及其对应的捕获组。 FindAllStringSubmatch(s string, n int) string：返回一个字符串切片的切片，其中包含与正则表达式模式匹配的所有子字符串及其对应的捕获组。可指定 n 来限制匹配的数量。 示例代码：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;John Doe, jane@example.com\u0026#34; re := regexp.MustCompile(`(\\w+)\\s(\\w+),\\s(\\w+@\\w+.\\w+)`) match := re.FindStringSubmatch(str) fmt.Println(match) // [John Doe, John Doe, jane@example.com] fmt.Println(\u0026#34;Name:\u0026#34;, match[1], match[2]) // Name: John Doe fmt.Println(\u0026#34;Email:\u0026#34;, match[3]) // Email: jane@example.com } 在上面的示例中，我们使用正则表达式 (\\w+)\\s(\\w+),\\s(\\w+@\\w+.\\w+) 匹配形如 \u0026ldquo;John Doe, jane@example.com\u0026rdquo; 的字符串。该正则表达式包含了三个捕获组，分别用于提取名字、姓氏和电子邮件地址。我们使用 FindStringSubmatch 方法来获取匹配的结果，并通过索引访问捕获组中的子字符串。\n当我们打印 match 时，可以看到它是一个字符串切片，其中第一个元素是整个匹配的字符串，后续元素是捕获组中的子字符串。\n7. 标志（Flags） Golang 的 regexp 包还提供了一些标志（flags）选项，用于修改正则表达式的行为。这些标志可以通过在正则表达式模式中添加标志参数来设置。\n以下是一些常用的标志：\ni：忽略大小写，使匹配对大小写不敏感。 m：多行模式，允许 ^ 和 $ 匹配文本的每一行的开头和结尾。 s：单行模式，使点号 . 可以匹配换行符。 U：非贪婪模式，使匹配尽可能少地进行。 示例代码：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;Hello\\nworld\u0026#34; re := regexp.MustCompile((?m)^(\\w+)) matches := re.FindAllStringSubmatch(str, -1) for _, match := range matches { fmt.Println(\u0026#34;Matched:\u0026#34;, match[0]) fmt.Println(\u0026#34;Capture Group 1:\u0026#34;, match[1]) } } 在上面的示例中，我们使用正则表达式 (?m)^(\\w+) 匹配多行字符串中的每一行的第一个单词。标志 (?m) 启用多行模式，^ 匹配每行的开头，(\\w+) 是一个捕获组，用于匹配一个或多个字母数字字符。我们使用 FindAllStringSubmatch 方法来获取所有匹配的结果，并迭代输出每个匹配的字符串和捕获组。\n当我们运行该代码时，输出将是：\nMatched: Hello Capture Group 1: Hello Matched: world Capture Group 1: world 通过设置适当的标志，你可以调整正则表达式的行为，以满足特定的匹配需求。\n8. 常见正则表达式技巧 当使用正则表达式时，有一些常见的技巧可以帮助你更有效地处理模式匹配。以下是一些常见的正则表达式技巧。\n8.1 使用限定符 限定符用于指定匹配元素的数量。以下是一些常见的限定符：\n*：匹配前一个元素零次或多次。 +：匹配前一个元素一次或多次。 ?：匹配前一个元素零次或一次。 {n}：匹配前一个元素恰好 n 次。 {n,}：匹配前一个元素至少 n 次。 {n,m}：匹配前一个元素至少 n 次，但不超过 m 次。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;aaaabbbbcccc\u0026#34; re := regexp.MustCompile(`a{2,}b{2,}c{2,}`) match := re.MatchString(str) fmt.Println(match) // true } 在上面的示例中，我们使用正则表达式 a{2,}b{2,}c{2,} 匹配连续出现两次或更多次的字母 \u0026ldquo;a\u0026rdquo;、\u0026ldquo;b\u0026rdquo; 和 \u0026ldquo;c\u0026rdquo;。通过使用限定符，我们可以定义所需的匹配次数。\n8.2 使用字符类 字符类用于匹配一组特定的字符。以下是一些常见的字符类：\n[abc]：匹配字符 \u0026ldquo;a\u0026rdquo;、\u0026ldquo;b\u0026rdquo; 或 \u0026ldquo;c\u0026rdquo;。 [0-9]：匹配任意一个数字。 [^0-9]：匹配除数字以外的任意字符。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;a1b2c3\u0026#34; re := regexp.MustCompile(`[0-9]`) matches := re.FindAllString(str, -1) fmt.Println(matches) // [1 2 3] } 在上面的示例中，我们使用正则表达式 [0-9] 匹配字符串中的数字字符。通过使用字符类，我们可以定义需要匹配的字符范围。\n8.3 使用元字符 元字符具有特殊的含义。以下是一些常见的元字符：\n.：匹配除换行符以外的任意字符。 \\w：匹配字母、数字或下划线字符。 \\d：匹配数字字符。 \\s：匹配空白字符。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;Hello, World!\u0026#34; re := regexp.MustCompile(`\\w+`) matches := re.FindAllString(str, -1) fmt.Println(matches) // [Hello World] } 8.4 使用捕获组 捕获组允许你提取匹配的子字符串。通过使用括号将子表达式括起来，你可以将其作为捕获组。以下是一个示例：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;Hello, Golang!\u0026#34; re := regexp.MustCompile(`(\\w+), (\\w+)!`) matches := re.FindStringSubmatch(str) fmt.Println(matches[0]) // Hello, Golang! fmt.Println(matches[1]) // Hello fmt.Println(matches[2]) // Golang } 在上面的示例中，我们使用正则表达式 (\\w+), (\\w+)! 匹配以逗号分隔的两个单词，并将它们作为捕获组。通过使用 FindStringSubmatch 方法，我们可以提取整个匹配的子字符串以及每个捕获组的内容。\n8.5 使用反向引用 反向引用允许你在正则表达式中引用先前匹配的捕获组。通过使用 \\n，其中 n 是捕获组的索引，你可以引用先前的捕获组。以下是一个示例：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;hello hello\u0026#34; re := regexp.MustCompile(`(\\w+) \\1`) match := re.MatchString(str) fmt.Println(match) // true } 在上面的示例中，我们使用正则表达式 (\\w+) \\1 匹配重复的单词。\\1 表示引用第一个捕获组的内容。通过使用反向引用，我们可以匹配重复出现的模式。\n8.6 使用锚点 锚点用于指定匹配发生的位置。以下是一些常见的锚点：\n^：匹配字符串的开头。 $：匹配字符串的结尾。 \\b：匹配单词的边界。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;Hello, Golang!\u0026#34; re := regexp.MustCompile(`^Hello`) match := re.MatchString(str) fmt.Println(match) // true re = regexp.MustCompile(`Golang!$`) match = re.MatchString(str) fmt.Println(match) // true re = regexp.MustCompile(`\\bGolang\\b`) match = re.MatchString(str) fmt.Println(match) // true } 在上面的示例中，我们使用不同的锚点来匹配字符串的开头、结尾和单词边界。通过使用锚点，我们可以限定匹配发生的位置。\n8.7 使用修饰符 修饰符是用于修改正则表达式的行为的特殊标记。它们可以影响匹配的方式和规则。以下是一些常见的修饰符。\n8.7.1 i 修饰符（不区分大小写） 使用 i 修饰符可以使匹配过程对大小写不敏感。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;Hello, World!\u0026#34; re := regexp.MustCompile(`hello`) match := re.MatchString(str) fmt.Println(match) // false re = regexp.MustCompile(`(?i)hello`) match = re.MatchString(str) fmt.Println(match) // true } 在上面的示例中，正则表达式 (?i)hello 使用了 i 修饰符，使匹配过程不区分大小写。\n8.7.2 m 修饰符（多行模式） 使用 m 修饰符可以使 ^ 和 $ 锚点匹配每一行的开头和结尾，而不仅仅是整个字符串的开头和结尾。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := `Line 1 Line 2 Line 3` re := regexp.MustCompile(`^Line \\d+$`) match := re.MatchString(str) fmt.Println(match) // false re = regexp.MustCompile(`(?m)^Line \\d+$`) match = re.MatchString(str) fmt.Println(match) // true } 在上面的示例中，正则表达式 (?m)^Line \\d+使用了m修饰符，使和使用了 m 修饰符，使 ^ 和使用了m修饰符，使和 锚点匹配每一行的开头和结尾。\n8.7.3 s 修饰符（单行模式） 使用 s 修饰符可以使 . 元字符匹配包括换行符在内的任意字符。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;Hello\\nWorld!\u0026#34; re := regexp.MustCompile(`Hello.World!`) match := re.MatchString(str) fmt.Println(match) // false re = regexp.MustCompile(`(?s)Hello.World!`) match = re.MatchString(str) fmt.Println(match) // true } 在上面的示例中，正则表达式 (?s)Hello.World! 使用了 s 修饰符，使 . 元字符可以匹配包括换行符在内的任意字符。\n修饰符可以在正则表达式中使用括号和 ? 符号的形式，如 (?i)、(?m) 和 (?s)。它们可以单独使用，也可以组合使用，以适应特定的匹配需求。\n8.7.4 x 修饰符（忽略空白字符） 使用 x 修饰符可以在正则表达式中忽略空白字符，包括空格、制表符和换行符。这样可以使正则表达式更易读和维护。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;Hello World!\u0026#34; re := regexp.MustCompile(`Hello World!`) match := re.MatchString(str) fmt.Println(match) // false re = regexp.MustCompile(`(?x)Hello World!`) match = re.MatchString(str) fmt.Println(match) // true } 在上面的示例中，正则表达式 (?x)Hello World! 使用了 x 修饰符，忽略了正则表达式中的空白字符。这样可以使正则表达式更易读，减少了空格的影响。\n8.7.5 U 修饰符（非贪婪模式） 使用 U 修饰符可以将匹配模式设置为非贪婪模式，即尽可能少地匹配字符。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;Hello World!\u0026#34; re := regexp.MustCompile(`H.*o`) match := re.FindString(str) fmt.Println(match) // Hello World! re = regexp.MustCompile(`H.*?o`) match = re.FindString(str) fmt.Println(match) // Hello } 在上面的示例中，正则表达式 H.o 使用了贪婪模式，匹配了从 \u0026ldquo;H\u0026rdquo; 到最后一个 \u0026ldquo;o\u0026rdquo; 的最长字符串。而正则表达式 H. ?o 使用了 U 修饰符，将匹配模式设置为非贪婪模式，只匹配了从 \u0026ldquo;H\u0026rdquo; 到第一个 \u0026ldquo;o\u0026rdquo; 的最短字符串。\n","permalink":"https://liiqii.github.io/posts/tech/go/regexp/","summary":"1. 正则表达式语法 正则表达式是一种用于匹配和操作文本的强大工具，它使用特殊的字符和语法来定义模式。在 Golang 的 regexp 包中，使用的正则表达式语法是基于标准的 POSIX 正则表达式语法的一个子集。 以下是一些常用的正则表达式元字符： . ：匹配任意单个字符，除了换行符。 * ：匹配前面的元素零次或多次。 + ：匹配前面","title":"Go 正则表达式"},{"content":"随便来点什么测试一下\n","permalink":"https://liiqii.github.io/posts/blog/blog/","summary":"随便来点什么测试一下","title":"建站"},{"content":"随便来点什么测试一下\n","permalink":"https://liiqii.github.io/posts/life/life/","summary":"随便来点什么测试一下","title":"生活"},{"content":"随便来点什么测试一下\n","permalink":"https://liiqii.github.io/posts/read/read/","summary":"随便来点什么测试一下","title":"阅读"},{"content":"\r👉友链格式\r名称： XXXXXX 网址： https://liiqii.github.io/ 图标： https://liiqii.github.io/img/Q.gif 描述： XXXXXX 👉友链申请要求\r秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n","permalink":"https://liiqii.github.io/links/","summary":"👉友链格式 名称： XXXXXX 网址： https://liiqii.github.io/ 图标： https://liiqii.github.io/img/Q.gif 描述： XXXXXX 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内","title":"🤝友链"},{"content":"关于我\n英文名: Klaus 职业: 程序员 爱好: 游戏 ","permalink":"https://liiqii.github.io/about/","summary":"关于我 英文名: Klaus 职业: 程序员 爱好: 游戏","title":"🙋🏻‍♂️关于"}]