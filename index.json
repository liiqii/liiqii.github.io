[{"content":"数据查询 go build 这个命令主要用于编译代码。在包的编译过程中，若有必要，会同时编译与之相关联的包。\n如果是普通包，就像我们在1.2节中编写的mymath包那样，当你执行go build之后，它不会产生任何文件。如果你需要在$GOPATH/pkg下生成相应的文件，那就得执行go install。\n如果是main包，当你执行go build之后，它就会在当前目录下生成一个可执行文件。如果你需要在$GOPATH/bin下生成相应的文件，需要执行go install，或者使用go build -o 路径/a.exe。\n如果某个项目文件夹下有多个文件，而你只想编译某个文件，就可在go build之后加上文件名，例如go build a.go；go build命令默认会编译当前目录下的所有go文件。\n你也可以指定编译输出的文件名。例如1.2节中的mathapp应用，我们可以指定go build -o astaxie.exe，默认情况是你的package名(非main包)，或者是第一个源文件的文件名(main包)。\n（注：实际上，package名在Go语言规范中指代码中“package”后使用的名称，此名称可以与文件夹名不同。默认生成的可执行文件名是文件夹名。）\ngo build会忽略目录下以“_”或“.”开头的go文件。\n如果你的源代码针对不同的操作系统需要不同的处理，那么你可以根据不同的操作系统后缀来命名文件。例如有一个读取数组的程序，它对于不同的操作系统可能有如下几个源文件：\narray_linux.go array_darwin.go array_windows.go array_freebsd.go\ngo build的时候会选择性地编译以系统名结尾的文件（Linux、Darwin、Windows、Freebsd）。例如Linux系统下面编译只会选择array_linux.go文件，其它系统命名后缀文件全部忽略。\n参数的介绍\n-o 指定输出的文件名，可以带上路径，例如 go build -o a/b/c -i 安装相应的包，编译+go install -a 更新全部已经是最新的包的，但是对标准包不适用 -n 把需要执行的编译命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的 -p n 指定可以并行可运行的编译数目，默认是CPU数目 -race 开启编译的时候自动检测数据竞争的情况，目前只支持64位的机器 -v 打印出来我们正在编译的包名 -work 打印出来编译时候的临时文件夹名称，并且如果已经存在的话就不要删除 -x 打印出来执行的命令，其实就是和-n的结果类似，只是这个会执行 -ccflags 'arg list' 传递参数给5c, 6c, 8c 调用 -compiler name 指定相应的编译器，gccgo还是gc -gccgoflags 'arg list' 传递参数给gccgo编译连接调用 -gcflags 'arg list' 传递参数给5g, 6g, 8g 调用 -installsuffix suffix 为了和默认的安装包区别开来，采用这个前缀来重新安装那些依赖的包，-race的时候默认已经是-installsuffix race,大家可以通过-n命令来验证 -ldflags 'flag list' 传递参数给5l, 6l, 8l 调用 -tags 'tag list' 设置在编译的时候可以适配的那些tag，详细的tag限制参考里面的 Build Constraints go clean 这个命令是用来移除当前源码包和关联源码包里面编译生成的文件。这些文件包括\n_obj/ 旧的object目录，由Makefiles遗留\r_test/ 旧的test目录，由Makefiles遗留\r_testmain.go 旧的gotest文件，由Makefiles遗留\rtest.out 旧的test记录，由Makefiles遗留\rbuild.out 旧的test记录，由Makefiles遗留\r*.[568ao] object文件，由Makefiles遗留\rDIR(.exe) 由go build产生\rDIR.test(.exe) 由go test -c产生\rMAINFILE(.exe) 由go build MAINFILE.go产生\r*.so 由 SWIG 产生\r我一般都是利用这个命令清除编译文件，然后GitHub递交源码，在本机测试的时候这些编译文件都是和系统相关的，但是对于源码管理来说没必要。\n$ go clean -i -n\rcd /Users/astaxie/develop/gopath/src/mathapp\rrm -f mathapp mathapp.exe mathapp.test mathapp.test.exe app app.exe\rrm -f /Users/astaxie/develop/gopath/bin/mathapp\r参数介绍\n-i 清除关联的安装的包和可运行文件，也就是通过go install安装的文件 -n 把需要执行的清除命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的 -r 循环的清除在import中引入的包 -x 打印出来执行的详细命令，其实就是-n打印的执行版本 go fmt 有过C/C++经验的读者会知道,一些人经常为代码采取K\u0026amp;R风格还是ANSI风格而争论不休。在go中，代码则有标准的风格。由于之前已经有的一些习惯或其它的原因我们常将代码写成ANSI风格或者其它更合适自己的格式，这将为人们在阅读别人的代码时添加不必要的负担，所以go强制了代码格式（比如左大括号必须放在行尾），不按照此格式的代码将不能编译通过，为了减少浪费在排版上的时间，go工具集中提供了一个go fmt命令 它可以帮你格式化你写好的代码文件，使你写代码的时候不需要关心格式，你只需要在写完之后执行go fmt \u0026lt;文件名\u0026gt;.go，你的代码就被修改成了标准格式，但是我平常很少用到这个命令，因为开发工具里面一般都带了保存时候自动格式化功能，这个功能其实在底层就是调用了go fmt。接下来的一节我将讲述两个工具，这两个工具都自带了保存文件时自动化go fmt功能。\n使用go fmt命令，其实是调用了gofmt，而且需要参数-w，否则格式化结果不会写入文件。gofmt -w -l src，可以格式化整个项目。\n所以go fmt是gofmt的上层一个包装的命令，我们想要更多的个性化的格式化可以参考 gofmt\ngofmt的参数介绍\n-l 显示那些需要格式化的文件 -w 把改写后的内容直接写入到文件中，而不是作为结果打印到标准输出。 -r 添加形如“a[b:len(a)] -\u0026gt; a[b:]”的重写规则，方便我们做批量替换 -s 简化文件中的代码 -d 显示格式化前后的diff而不是写入文件，默认是false -e 打印所有的语法错误到标准输出。如果不使用此标记，则只会打印不同行的前10个错误。 -cpuprofile 支持调试模式，写入相应的cpufile到指定的文件 go get 这个命令是用来动态获取远程代码包的，目前支持的有BitBucket、GitHub、Google Code和Launchpad。这个命令在内部实际上分成了两步操作：第一步是下载源码包，第二步是执行go install。下载源码包的go工具会自动根据不同的域名调用不同的源码工具，对应关系如下：\nBitBucket (Mercurial Git)\rGitHub (Git)\rGoogle Code Project Hosting (Git, Mercurial, Subversion)\rLaunchpad (Bazaar)\r所以为了go get 能正常工作，你必须确保安装了合适的源码管理工具，并同时把这些命令加入你的PATH中。其实go get支持自定义域名的功能，具体参见go help remote。\n参数介绍：\n-d 只下载不安装 -f 只有在你包含了-u参数的时候才有效，不让-u去验证import中的每一个都已经获取了，这对于本地fork的包特别有用 -fix 在获取源码之后先运行fix，然后再去做其他的事情 -t 同时也下载需要为运行测试所需要的包 -u 强制使用网络去更新包和它的依赖包 -v 显示执行的命令 go install 这个命令在内部实际上分成了两步操作：第一步是生成结果文件(可执行文件或者.a包)，第二步会把编译好的结果移到$GOPATH/pkg或者$GOPATH/bin。\n参数支持go build的编译参数。大家只要记住一个参数-v就好了，这个随时随地的可以查看底层的执行信息。\ngo test 执行这个命令，会自动读取源码目录下面名为*_test.go的文件，生成并运行测试用的可执行文件。输出的信息类似\nok archive/tar 0.011s\rFAIL archive/zip 0.022s\rok compress/gzip 0.033s\r...\r默认的情况下，不需要任何的参数，它会自动把你源码包下面所有test文件测试完毕，当然你也可以带上参数，详情请参考go help testflag\n这里我介绍几个我们常用的参数：\n-bench regexp 执行相应的benchmarks，例如 -bench=. -cover 开启测试覆盖率 -run regexp 只运行regexp匹配的函数，例如 -run=Array 那么就执行包含有Array开头的函数 -v 显示测试的详细命令 go tool go tool下面下载聚集了很多命令，这里我们只介绍两个，fix和vet\ngo tool fix . 用来修复以前老版本的代码到新版本，例如go1之前老版本的代码转化到go1,例如API的变化 go tool vet directory|files 用来分析当前目录的代码是否都是正确的代码,例如是不是调用fmt.Printf里面的参数不正确，例如函数里面提前return了然后出现了无用代码之类的。 go generate 这个命令是从Go1.4开始才设计的，用于在编译前自动化生成某类代码。go generate和go build是完全不一样的命令，通过分析源码中特殊的注释，然后执行相应的命令。这些命令都是很明确的，没有任何的依赖在里面。而且大家在用这个之前心里面一定要有一个理念，这个go generate是给你用的，不是给使用你这个包的人用的，是方便你来生成一些代码的。\n这里我们来举一个简单的例子，例如我们经常会使用yacc来生成代码，那么我们常用这样的命令：\ngo tool yacc -o gopher.go -p parser gopher.y\r-o 指定了输出的文件名， -p指定了package的名称，这是一个单独的命令，如果我们想让go generate来触发这个命令，那么就可以在当前目录的任意一个xxx.go文件里面的任意位置增加一行如下的注释：\n//go:generate go tool yacc -o gopher.go -p parser gopher.y\r这里我们注意了，//go:generate是没有任何空格的，这其实就是一个固定的格式，在扫描源码文件的时候就是根据这个来判断的。\n所以我们可以通过如下的命令来生成，编译，测试。如果gopher.y文件有修改，那么就重新执行go generate重新生成文件就好。\n$ go generate\r$ go build\r$ go test\rgodoc 在Go1.2版本之前还支持go doc命令，但是之后全部移到了godoc这个命令下，需要这样安装go get golang.org/x/tools/cmd/godoc\n很多人说go不需要任何的第三方文档，例如chm手册之类的（其实我已经做了一个了，chm手册），因为它内部就有一个很强大的文档工具。\n如何查看相应package的文档呢？ 例如builtin包，那么执行godoc builtin 如果是http包，那么执行godoc net/http 查看某一个包里面的函数，那么执行godoc fmt Printf 也可以查看相应的代码，执行godoc -src fmt Printf\n通过命令在命令行执行 godoc -http=:端口号 比如godoc -http=:8080。然后在浏览器中打开127.0.0.1:8080，你将会看到一个golang.org的本地copy版本，通过它你可以查询pkg文档等其它内容。如果你设置了GOPATH，在pkg分类下，不但会列出标准包的文档，还会列出你本地GOPATH中所有项目的相关文档，这对于经常被墙的用户来说是一个不错的选择。\n其它命令 go还提供了其它很多的工具，例如下面的这些工具\ngo version 查看go当前的版本\rgo env 查看当前go的环境变量\rgo list 列出当前全部安装的package\rgo run 编译并运行Go程序\r以上这些工具还有很多参数没有一一介绍，用户可以使用go help 命令获取更详细的帮助信息。\n","permalink":"https://liiqii.github.io/posts/tech/go/command/","summary":"数据查询 go build 这个命令主要用于编译代码。在包的编译过程中，若有必要，会同时编译与之相关联的包。 如果是普通包，就像我们在1.2节中编写的mymath包那样，当你执行go build之后，它不会产生任何文件。如果你需要在$GOPATH/pkg下生成相应的文件，那就得执行go install","title":"go 相关操作命令"},{"content":"数据查询 find()方法 方法说明\nfind()方法没有参数时会匹配集合中的所有内容，find({})和find()功能一样 find({\u0026quot;_id\u0026quot;:1})表示查询_id字段为 1 的文档；find({\u0026quot;_id\u0026quot;:1,\u0026quot;name\u0026quot;:\u0026quot;salta\u0026quot;})多个筛选条件表示为and的关系，表示查询_id=1 and name='salta'的文档；增加查询条件也一样 find({},{\u0026quot;price\u0026quot;:0,\u0026quot;_id\u0026quot;:0})表示从查询结果中剔除price和_id字段；find({},{\u0026quot;name\u0026quot;:1,\u0026quot;price\u0026quot;:1})表示从查询结果中只保留name和price字段。 find()方法中的筛选条件必须是常量 **注意：**第二个参数中如果是保留字段，则必须都是保留字段；如果是剔除字段，则必须都是剔除字段。否则 mongodb 会报错。但_id字段不受此规则限制，可以随意剔除。举例如下：\n//以下代码会报错 db.game.find( {}, { name: 1, price: 0, } ); //以下代码能正常运行 db.game.find( {}, { name: 1, _id: 0, } ); 运行效果如下：\n\u0026gt; db.game.find({},{ ... \u0026#34;name\u0026#34;:1, ... \u0026#34;price\u0026#34;:0 ... }) Error: error: { \u0026#34;ok\u0026#34; : 0, \u0026#34;errmsg\u0026#34; : \u0026#34;Cannot do exclusion on field price in inclusion projection\u0026#34;, \u0026#34;code\u0026#34; : 31254, \u0026#34;codeName\u0026#34; : \u0026#34;Location31254\u0026#34; } \u0026gt; db.game.find({},{ ... \u0026#34;name\u0026#34;:1, ... \u0026#34;_id\u0026#34;:0 ... }) { \u0026#34;name\u0026#34; : \u0026#34;salta legend\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;monster hunter: rise\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;bayonetta\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;nier replicant\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;god of war\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;Nioh 2\u0026#34; } 条件查询 $lt,$lte,$gt,$gte,$ne $lt小于 $lte小于等于 $gt大于 $gte大于等于 $ne不等于,$ne可用于任意数据类型 以下代码用来查询价格大于 20,且价格小于等于 280 的 document\ndb.game.find({ price: { $gt: 20, $lte: 280, }, }); 运行效果如下:\n\u0026gt; db.game.find({ ... \u0026#34;price\u0026#34;:{ ... \u0026#34;$gt\u0026#34;:20, ... \u0026#34;$lte\u0026#34;:280 ... } ... }) { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 128, \u0026#34;platform\u0026#34; : [ \u0026#34;steam\u0026#34; ], \u0026#34;comments\u0026#34; : [ { \u0026#34;author\u0026#34; : \u0026#34;xilia\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;hello salta\u0026#34;, \u0026#34;hidden\u0026#34; : true }, { \u0026#34;author\u0026#34; : \u0026#34;salta\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;link\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;link\u0026#34; } ] } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62ba596511721fa1455eb94b\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;nier replicant\u0026#34;, \u0026#34;company\u0026#34; : \u0026#34;square enix\u0026#34;, \u0026#34;price\u0026#34; : 180 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62bd39540a71331919b6295e\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;god of war\u0026#34;, \u0026#34;price\u0026#34; : 30 } $or $or运算符用于表示两个是筛选条件是或的关系,以下代码用来筛选价格大于280或者价格小于等于20的document\ndb.game.find({\u0026#34;$or\u0026#34;:[ {\u0026#34;price\u0026#34;:{\u0026#34;$gt\u0026#34;:280}}, {\u0026#34;price\u0026#34;:{\u0026#34;$lte\u0026#34;:20}} ]}) 代码运行效果如下:\n\u0026gt; db.game.find({\u0026#34;$or\u0026#34;:[ ... {\u0026#34;price\u0026#34;:{\u0026#34;$gt\u0026#34;:280}}, ... {\u0026#34;price\u0026#34;:{\u0026#34;$lte\u0026#34;:20}} ... ]}) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62b9515ba8e0e5b80c720d94\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;salta legend\u0026#34;, \u0026#34;orderDate\u0026#34; : ISODate(\u0026#34;2022-06-27T06:42:35.640Z\u0026#34;), \u0026#34;price\u0026#34; : 327 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62ba565711721fa1455eb949\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;monster hunter: rise\u0026#34;, \u0026#34;orderDate\u0026#34; : ISODate(\u0026#34;2022-06-28T01:16:07.114Z\u0026#34;), \u0026#34;price\u0026#34; : 298 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62ba596511721fa1455eb94a\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;bayonetta\u0026#34;, \u0026#34;company\u0026#34; : \u0026#34;nintendo\u0026#34;, \u0026#34;price\u0026#34; : 318 } $in和$nin $in用来筛选在某些列出的范围内的属性(和sql语句中的in关键字相同)\n$nin是not in的意思\n以下代码用来查询价格在[327,30]两个数字中的结果:\ndb.game.find({\u0026#34;price\u0026#34;:{ \u0026#34;$in\u0026#34;:[327,30] }}) 代码运行效果如下:\n\u0026gt; db.game.find({\u0026#34;price\u0026#34;:{ ... \u0026#34;$in\u0026#34;:[327,30] ... }}) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62b9515ba8e0e5b80c720d94\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;salta legend\u0026#34;, \u0026#34;orderDate\u0026#34; : ISODate(\u0026#34;2022-06-27T06:42:35.640Z\u0026#34;), \u0026#34;price\u0026#34; : 327 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62bd39540a71331919b6295e\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;god of war\u0026#34;, \u0026#34;price\u0026#34; : 30 } $mod $mod为取模运算符,以下代码用来筛选出 对price模3余0的document。\ndb.game.find({\u0026#34;price\u0026#34;:{ \u0026#34;$mod\u0026#34;:[3,0] }}) 代码运行效果为：\n\u0026gt; db.game.find({\u0026#34;price\u0026#34;:{ ... \u0026#34;$mod\u0026#34;:[3,0] ... }}) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62b9515ba8e0e5b80c720d94\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;salta legend\u0026#34;, \u0026#34;orderDate\u0026#34; : ISODate(\u0026#34;2022-06-27T06:42:35.640Z\u0026#34;), \u0026#34;price\u0026#34; : 327 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62ba596511721fa1455eb94a\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;bayonetta\u0026#34;, \u0026#34;company\u0026#34; : \u0026#34;nintendo\u0026#34;, \u0026#34;price\u0026#34; : 318 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62ba596511721fa1455eb94b\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;nier replicant\u0026#34;, \u0026#34;company\u0026#34; : \u0026#34;square enix\u0026#34;, \u0026#34;price\u0026#34; : 180 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62bd39540a71331919b6295e\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;god of war\u0026#34;, \u0026#34;price\u0026#34; : 30 } $not $not表示取反，可用于描述其他运算符，以下代码用来筛选出 不满足对price模3余0的document\ndb.game.find({\u0026#34;price\u0026#34;:{ \u0026#34;$not\u0026#34;:{ \u0026#34;$mod\u0026#34;:[3,0] } }}) 代码运行效果如下：\n\u0026gt; db.game.find({\u0026#34;price\u0026#34;:{ ... \u0026#34;$not\u0026#34;:{ ... \u0026#34;$mod\u0026#34;:[3,0] ... } ... }}) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62ba565711721fa1455eb949\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;monster hunter: rise\u0026#34;, \u0026#34;orderDate\u0026#34; : ISODate(\u0026#34;2022-06-28T01:16:07.114Z\u0026#34;), \u0026#34;price\u0026#34; : 298 } { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 128, \u0026#34;platform\u0026#34; : [ \u0026#34;steam\u0026#34; ], \u0026#34;comments\u0026#34; : [ { \u0026#34;author\u0026#34; : \u0026#34;xilia\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;hello salta\u0026#34;, \u0026#34;hidden\u0026#34; : true }, { \u0026#34;author\u0026#34; : \u0026#34;salta\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;link\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;link\u0026#34; } ] } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62bd3d9f0a71331919b6297a\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;Nioh 2\u0026#34;, \u0026#34;published\u0026#34; : ISODate(\u0026#34;2022-06-30T06:08:30.014Z\u0026#34;) } 类型查询 关于null类型的说明 当查询条件设置为{\u0026quot;platform\u0026quot;:null}时，既可以查到platform=null的文档，也可以查到不存在platform字段的文档。如果只希望得到platform=null的文档，可以通过$exits条件确定该字段存在。\n以下代码用来筛选出platform字段存在，并且为空的文档：\ndb.game.find({\u0026#34;platform\u0026#34;:{ \u0026#34;$eq\u0026#34;:null, \u0026#34;$exists\u0026#34;:true }}) 代码运行效果如下：\n\u0026gt; db.game.insertMany([{name:\u0026#34;it takes two\u0026#34;,platform:null},{name:\u0026#34;naraka\u0026#34;,platform:\u0026#34;\u0026#34;},{name:\u0026#34;gta5\u0026#34;}]) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;insertedIds\u0026#34; : [ ObjectId(\u0026#34;62be8e82718b6cda80d080aa\u0026#34;), ObjectId(\u0026#34;62be8e82718b6cda80d080ab\u0026#34;), ObjectId(\u0026#34;62be8e82718b6cda80d080ac\u0026#34;) ] } \u0026gt; db.game.find({\u0026#34;platform\u0026#34;:{ ... \u0026#34;$eq\u0026#34;:null, ... \u0026#34;$exists\u0026#34;:true ... }}) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62be8e82718b6cda80d080aa\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;it takes two\u0026#34;, \u0026#34;platform\u0026#34; : null } 如果只进行null筛选，效果如下:\n\u0026gt; db.game.find({\u0026#34;platform\u0026#34;:null}) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62b9515ba8e0e5b80c720d94\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;salta legend\u0026#34;, \u0026#34;orderDate\u0026#34; : ISODate(\u0026#34;2022-06-27T06:42:35.640Z\u0026#34;), \u0026#34;price\u0026#34; : 327 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62ba565711721fa1455eb949\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;monster hunter: rise\u0026#34;, \u0026#34;orderDate\u0026#34; : ISODate(\u0026#34;2022-06-28T01:16:07.114Z\u0026#34;), \u0026#34;price\u0026#34; : 298 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62ba596511721fa1455eb94a\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;bayonetta\u0026#34;, \u0026#34;company\u0026#34; : \u0026#34;nintendo\u0026#34;, \u0026#34;price\u0026#34; : 318 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62ba596511721fa1455eb94b\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;nier replicant\u0026#34;, \u0026#34;company\u0026#34; : \u0026#34;square enix\u0026#34;, \u0026#34;price\u0026#34; : 180 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62bd39540a71331919b6295e\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;god of war\u0026#34;, \u0026#34;price\u0026#34; : 30 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62bd3d9f0a71331919b6297a\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;Nioh 2\u0026#34;, \u0026#34;published\u0026#34; : ISODate(\u0026#34;2022-06-30T06:08:30.014Z\u0026#34;) } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62be8e82718b6cda80d080aa\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;it takes two\u0026#34;, \u0026#34;platform\u0026#34; : null } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62be8e82718b6cda80d080ac\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;gta5\u0026#34; } 正则表达式 $regex运算符用来在查询中对字符串进行正则表达时匹配，正则表达式也遵循JavaScript的正则表达式语法。如，以下代码用来查询name字段以n或N开头的文档：\ndb.game.find({\u0026#34;name\u0026#34;:{ \u0026#34;$regex\u0026#34;:/^n/i }}) 查询结果如下：\n\u0026gt; db.game.find({\u0026#34;name\u0026#34;:{ ... \u0026#34;$regex\u0026#34;:/^n/i ... }}) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62ba596511721fa1455eb94b\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;nier replicant\u0026#34;, \u0026#34;company\u0026#34; : \u0026#34;square enix\u0026#34;, \u0026#34;price\u0026#34; : 180 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62bd3d9f0a71331919b6297a\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;Nioh 2\u0026#34;, \u0026#34;published\u0026#34; : ISODate(\u0026#34;2022-06-30T06:08:30.014Z\u0026#34;) } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62be8e82718b6cda80d080ab\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;naraka\u0026#34;, \u0026#34;platform\u0026#34; : \u0026#34;\u0026#34; } 数组查询 测试用法之前先新增数据：\ndb.game.updateOne( {name:\u0026#34;naraka\u0026#34;}, {$set:[ \u0026#34;it is so good\u0026#34;, \u0026#34;it is so pretty\u0026#34;, \u0026#34;i am a old gamer\u0026#34;, \u0026#34;it`s my like\u0026#34;, \u0026#34;i like sanniang\u0026#34; ]} ) 数组内容匹配方式：\n完全匹配整个数组\ndb.game.find({\u0026quot;comments\u0026quot;:[\u0026quot;abc\u0026quot;,\u0026quot;def\u0026quot;]})用来筛选出数组comments字段值为['abc','def']的文档，这种用法和精确匹配完全一样。\n匹配单个数组元素\ndb.game.find({\u0026quot;comments\u0026quot;:\u0026quot;it is so good\u0026quot;})用来筛选出数组comments字段值中包含it is so good元素的文档\n匹配多个数组元素，$all\ndb.game.find({\u0026quot;comments\u0026quot;:{\u0026quot;all\u0026quot;:[\u0026quot;it is so good\u0026quot;,\u0026quot;i am a old gamer\u0026quot;]}})用来筛选出数组元素中包含it is so good和i am a old gamer两个元素的文档。如果$all的数组中只有一个元素，那么使用$all和不适用$all结果一样，即：{\u0026quot;author\u0026quot;:{\u0026quot;$all\u0026quot;:[\u0026quot;apple\u0026quot;]}}和{\u0026quot;author\u0026quot;:\u0026quot;apple\u0026quot;}的筛选结果完全一样\n匹配数组长度\n$size运算符用于匹配数组长度，但$size只能是常数，且$size不能和$lt等比较运算符同时使用。如果需要比较数组的长度，可以单独增加一个size字段，每次修改数组同时修改这个size字段，这在mongoDB中很容易实现。\ndb.game.find({\u0026quot;comments\u0026quot;:{\u0026quot;$size\u0026quot;:3}})用于筛选comments数组长度为3的文档。\n匹配数组元素对象的属性\ndb.game.find({\u0026quot;comments.author\u0026quot;:\u0026quot;salta\u0026quot;})用于筛选comments数组中元素的author属性为salta的文档\n控制返回值数组的长度\n过滤返回值中显示的数组长度可以使用$slice修饰符，整数n表示返回前n条数据，负数n表示返回后n条数据。以下代码用于返回comments字段的前3个元素：\ndb.game.find( {\u0026#34;name\u0026#34;:\u0026#34;naraka\u0026#34;}, {\u0026#34;comments\u0026#34;:{\u0026#34;$slice\u0026#34;:3}} ) 运行效果如下：\n\u0026gt; db.game.find( ... {\u0026#34;name\u0026#34;:\u0026#34;naraka\u0026#34;}, ... {\u0026#34;comments\u0026#34;:{\u0026#34;$slice\u0026#34;:3}} ... ) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62be8e82718b6cda80d080ab\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;naraka\u0026#34;, \u0026#34;platform\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;comments\u0026#34; : [ \u0026#34;it is so good\u0026#34;, \u0026#34;it is so pretty\u0026#34;, \u0026#34;i am a old gamer\u0026#34; ] } 此方法也可以返回数组中的一段数据，以下代码会返回comments字段的第2~第4个元素（忽略前1个元素，从第2个开始返回3个元素）\ndb.game.find( {\u0026#34;name\u0026#34;:\u0026#34;naraka\u0026#34;}, {\u0026#34;comments\u0026#34;:{\u0026#34;$slice\u0026#34;:[1,3]}} ) 显示效果如下：\n\u0026gt; db.game.find( ... {\u0026#34;name\u0026#34;:\u0026#34;naraka\u0026#34;}, ... {\u0026#34;comments\u0026#34;:{\u0026#34;$slice\u0026#34;:[1,3]}} ... ) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62be8e82718b6cda80d080ab\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;naraka\u0026#34;, \u0026#34;platform\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;comments\u0026#34; : [ \u0026#34;it is so pretty\u0026#34;, \u0026#34;i am a old gamer\u0026#34;, \u0026#34;it`s my like\u0026#34; ] } 只返回数组中匹配到的第一个元素\n可以通过$$运算符来返回匹配到的元素，这种方法只能返回匹配到的第一个元素，返回值的数组中只有一个元素。以下代码用于筛选comments数组字段中的元素对象的author属性，返回值中只有_id和comments字段，且comments字段中只有匹配到的第一个元素。\ndb.game.find( {\u0026#34;comments.author\u0026#34;:\u0026#34;salta\u0026#34;}, {\u0026#34;comments.$\u0026#34;:1} ) 代码运行效果如下：\n\u0026gt; db.game.find( ... {\u0026#34;comments.author\u0026#34;:\u0026#34;salta\u0026#34;}, ... {\u0026#34;comments.$\u0026#34;:1} ... ) { \u0026#34;_id\u0026#34; : 1, \u0026#34;comments\u0026#34; : [ { \u0026#34;author\u0026#34; : \u0026#34;salta\u0026#34; } ] } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62be8e82718b6cda80d080ab\u0026#34;), \u0026#34;comments\u0026#34; : [ { \u0026#34;author\u0026#34; : \u0026#34;salta\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;i am salta\u0026#34; } ] } 数组与范围查询 有以下数据：\ndb.number.insertMany([ {\u0026#34;num\u0026#34;:6}, {\u0026#34;num\u0026#34;:66}, {\u0026#34;num\u0026#34;:666}, {\u0026#34;num\u0026#34;:[6,66]}, {\u0026#34;num\u0026#34;:[6,666]}, {\u0026#34;num\u0026#34;:[6,66,666]} ]) 有以下查询代码：\ndb.number.find({\u0026#34;num\u0026#34;:{ \u0026#34;$gt\u0026#34;:10, \u0026#34;$lt\u0026#34;:100 }}) 此代码目的是查找 10 \u0026lt; n u m \u0026lt; 100 10\u0026lt;num\u0026lt;100 10\u0026lt;num\u0026lt;100的数据，期望能返回的数据为：\n{\u0026#34;num\u0026#34;:66}, 但，实际返回的数据为：\n{\u0026#34;num\u0026#34; : 66 } {\u0026#34;num\u0026#34; : [ 6, 66 ] } {\u0026#34;num\u0026#34; : [ 6, 666 ] } {\u0026#34;num\u0026#34; : [ 6, 66, 666 ] } 因为，在数组的比较中，满足6\u0026lt;100 和666\u0026gt;66\u0026gt;10，所以实际返回值和期望返回值产生了差别，这就使得针对数组的范围查询失效。\n这种现象可以通过$elemMatch表达式解决，但是$elemMatch表达式只能匹配数组元素，对于非数组元素回被跳过。效果如下：\n\u0026gt; db.number.find().pretty() { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62beb40a718b6cda80d080ad\u0026#34;), \u0026#34;num\u0026#34; : 6 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62beb40a718b6cda80d080ae\u0026#34;), \u0026#34;num\u0026#34; : 66 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62beb40a718b6cda80d080af\u0026#34;), \u0026#34;num\u0026#34; : 666 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62beb40a718b6cda80d080b0\u0026#34;), \u0026#34;num\u0026#34; : [ 6, 66 ] } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62beb40a718b6cda80d080b1\u0026#34;), \u0026#34;num\u0026#34; : [ 6, 666 ] } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62beb40a718b6cda80d080b2\u0026#34;), \u0026#34;num\u0026#34; : [ 6, 66, 666 ] } \u0026gt; db.number.find({\u0026#34;num\u0026#34;:{\u0026#34;$elemMatch\u0026#34;:{\u0026#34;$gt\u0026#34;:10,\u0026#34;$lt\u0026#34;:100}}}) \u0026gt; //查询结果为空。可见，{\u0026#34;num\u0026#34;:66}未参与筛选 对于以上现象，可以通过对num字段添加索引，之后使用min和max方法将筛选条件的索引范围限制在最大和最小值之间的形式予以解决。具体代码如下：\n//已对num字段创建索引 db.number.find({\u0026#34;num\u0026#34;:{ \u0026#34;$gt\u0026#34;:10, \u0026#34;$lt\u0026#34;:100 }}).min({\u0026#34;num\u0026#34;:10}).max({\u0026#34;num\u0026#34;:100}) 内嵌文档查询 如果想要通过以下方式查询一个子文档，那么这个被查询必须精确的匹配整个文档（包括各个属性的顺序）。即，如果文档的内容为{\u0026quot;author\u0026quot;:\u0026quot;xilia\u0026quot;,\u0026quot;content\u0026quot;:\u0026quot;hello salta\u0026quot;}，则能匹配成功；但是如果文档中存在更多其他的属性，如{\u0026quot;author\u0026quot;:\u0026quot;xilia\u0026quot;,\u0026quot;content\u0026quot;:\u0026quot;hello salta\u0026quot;,\u0026quot;hidden\u0026quot;:true}则这种匹配方式不能查询出对应的结果。\ndb.game.find({\u0026#34;comments\u0026#34;:{ \u0026#34;author\u0026#34;:\u0026#34;xilia\u0026#34;, \u0026#34;content\u0026#34;:\u0026#34;hello salta\u0026#34; }}) 更重要的一点是，除了需要匹配整个文档之外，这种查询方式还是强顺序相关的，两个条件的顺序必须符合要求才能成功匹配。\n在这中情况下，需要使用点调用1的方式\ndb.game.find({ \u0026#34;comments.author\u0026#34;:\u0026#34;xilia\u0026#34;, \u0026#34;comments.content\u0026#34;:\u0026#34;hello salta\u0026#34; }) 效果如下：\n\u0026gt; db.game.find({\u0026#34;comments\u0026#34;:{ ... \u0026#34;author\u0026#34;:\u0026#34;xilia\u0026#34;, ... \u0026#34;content\u0026#34;:\u0026#34;hello salta\u0026#34; ... }}) \u0026gt; db.game.find({ ... \u0026#34;comments.author\u0026#34;:\u0026#34;xilia\u0026#34;, ... \u0026#34;comments.content\u0026#34;:\u0026#34;hello salta\u0026#34; ... }) { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 128, \u0026#34;platform\u0026#34; : [ \u0026#34;steam\u0026#34; ], \u0026#34;comments\u0026#34; : [ { \u0026#34;author\u0026#34; : \u0026#34;xilia\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;hello salta\u0026#34;, \u0026#34;hidden\u0026#34; : true }, { \u0026#34;author\u0026#34; : \u0026#34;salta\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;link\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;link\u0026#34; } ] } $where查询 对于有些特殊的查询，无法通过以上任何一种方式表示出来，mongoDB提供了$where子句这种查询方式。$where子句允许在查询中执行JavaScript代码，这样就能在JavaScript代码中执行某些特殊的比较逻辑。但是为了安全和效率的要求，应该尽量减少或消除使用$where，并且禁止普通用户使用。\n在$where查询过程中，每个文档都必须从BSON转换成JavaScript对象，而且$where查询也不能使用索引，所以有很大的性能问题。\n具体使用方法如下：\n/** * 查询文档中存在两个字段满足以下条件： * 1.其中一个字段是日期类型，并且时间在当前日期之前； * 2.另一个字段是数字类型，并且这个数字小于300。 */ db.game.find({\u0026#34;$where\u0026#34;:function(){ for(var param_1 in this){ for(var param_2 in this){ return this[param_1]\u0026lt;new Date() \u0026amp;\u0026amp; this[param_2]\u0026lt;300; } } return false; }}).pretty() 执行效果如下：\n\u0026gt; db.game.find({\u0026#34;$where\u0026#34;:function(){ ... for(var param_1 in this){ ... for(var param_2 in this){ ... return this[param_1]\u0026lt;new Date() \u0026amp;\u0026amp; this[param_2]\u0026lt;300; ... } ... } ... return false; ... }}).pretty() { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 128, \u0026#34;platform\u0026#34; : [ \u0026#34;steam\u0026#34; ], \u0026#34;comments\u0026#34; : [ { \u0026#34;author\u0026#34; : \u0026#34;xilia\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;hello salta\u0026#34;, \u0026#34;hidden\u0026#34; : true }, { \u0026#34;author\u0026#34; : \u0026#34;salta\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;link\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;link\u0026#34; } ] } 游标 游标基础 find()方法的返回值是一个游标对象，通过对游标对象的各种操作，可以对查询结果进行输出控制。（在mongoDBshell中执行find()方法的打印操作是shell自动执行的结果）游标对象提供了hasNex()和next()两个方法，典型的使用方式为：\nvar cursor=db.game.find() while(cursor.hasNext()){ var item=cursor.next() print(item.name) } 同时游标对象也实现了迭代器接口，可以在forEach()方法中进行操作，使用方式如下：\nvar cursor=db.game.find(); cursor.forEach(res=\u0026gt;{ print(res.name) }) 注意：当调用find()方法时，shell并不会立即执行查询操作，而是真正开始获取结果时才执行查询操作。所以可以在查询之前进行一些额外的操作，如：排序、分页、限制长度等，这些操作的返回值仍然是一个游标对象。\n因此，以下三行代码返回的数据相同：\ndb.game.find().sort({\u0026#34;price\u0026#34;:1}).limit(3).skip(2).pretty(); db.game.find().sort({\u0026#34;price\u0026#34;:1}).skip(2).limit(3).pretty(); db.game.find().limit(3).sort({\u0026#34;price\u0026#34;:1}).skip(2).pretty(); db.game.find().limit(3).skip(2).sort({\u0026#34;price\u0026#34;:1}).pretty(); db.game.find().skip(2).limit(3).sort({\u0026#34;price\u0026#34;:1}).pretty(); db.game.find().skip(2).sort({\u0026#34;price\u0026#34;:1}).limit(3).pretty(); 当hasNext()方法被调用后，查询条件会发送到服务端，之后shell会获取一段查询结果（这里的一段是100个结果或4MB数据中的较小值），在客户端遍历完这些数据后，shell会再次链接数据库，使用getMore获取更多数据。\nlimit()、skip()、sort() 这三个函数的使用方法如下：\n//限制只返回三个结果 db.game.find().limit(3) //跳过前三条数据 db.game.find().skip(3) //按价格升序排序，-1表示降序 db.game.find().sort({\u0026#34;price\u0026#34;:1}) 以上三个方法可以结合使用。对于一个字段的数据包含多种类型时，mongoDB预设了排序顺序，从最小值到最大值顺序为：\n序号 类型 1 最小值 2 null 3 数字 4 字符串 5 对象、文档 6 数组 7 二进制数据 8 对象ID 9 布尔 10 日期 11 时间戳 12 正则表达式 13 最大值 注意：当skip()方法跳过大量数据时会产生性能问题，所以对于大数据量的分页操作，通常不用skip()方法实现。假设有一个需求，需要使用create_date字段降序排列，可以通过如下方式操作：\nvar page_1=db.game.find().sort({\u0026#34;create_date\u0026#34;:-1}).limit(20); var latest=null; while(page_1.hasNext()){ latest=page_1.next(); //do sth } var page_2=db.game.find({ \u0026#34;create_date\u0026#34;:{\u0026#34;$lt\u0026#34;:latest.create_date} }).sort({\u0026#34;create_date\u0026#34;:-1}).limit(100) 游标的生命周期 一个游标会占用服务器的资源，在满足一定的条件之后，服务端会释放这个游标的资源，这些条件包括：\n游标遍历完所有的结果 客户端要求终止该游标 当游标超出客户端的作用域，驱动程序会向数据库发送一条 “可以销毁该游标” 的消息 一个游标如果10分钟内没有被使用，数据库会自动销毁 ","permalink":"https://liiqii.github.io/posts/tech/mongo/mongo_query/","summary":"数据查询 find()方法 方法说明 find()方法没有参数时会匹配集合中的所有内容，find({})和find()功能一样 find({\u0026quot;_id\u0026quot;:1})表示查询_id字段为 1 的文档；find({\u0026quot;_id\u0026quot;:1,\u0026quot;name\u0026quot;","title":"mongo 查询"},{"content":"随便来点什么测试一下\n","permalink":"https://liiqii.github.io/posts/blog/blog/","summary":"随便来点什么测试一下","title":"建站"},{"content":"随便来点什么测试一下\n","permalink":"https://liiqii.github.io/posts/life/life/","summary":"随便来点什么测试一下","title":"生活"},{"content":"随便来点什么测试一下\n","permalink":"https://liiqii.github.io/posts/read/read/","summary":"随便来点什么测试一下","title":"阅读"},{"content":"\r👉友链格式\r名称： XXXXXX 网址： https://liiqii.github.io/ 图标： https://liiqii.github.io/img/Q.gif 描述： XXXXXX 👉友链申请要求\r秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n","permalink":"https://liiqii.github.io/links/","summary":"👉友链格式 名称： XXXXXX 网址： https://liiqii.github.io/ 图标： https://liiqii.github.io/img/Q.gif 描述： XXXXXX 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内","title":"🤝友链"},{"content":"关于我\n英文名: Klaus 职业: 程序员 爱好: 游戏 ","permalink":"https://liiqii.github.io/about/","summary":"关于我 英文名: Klaus 职业: 程序员 爱好: 游戏","title":"🙋🏻‍♂️关于"}]