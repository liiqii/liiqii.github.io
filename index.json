[{"content":"转自：【Mongo】MongoDB文档查询\n数据查询 find()方法 方法说明\nfind()方法没有参数时会匹配集合中的所有内容，find({})和find()功能一样 find({\u0026quot;_id\u0026quot;:1})表示查询_id字段为 1 的文档；find({\u0026quot;_id\u0026quot;:1,\u0026quot;name\u0026quot;:\u0026quot;salta\u0026quot;})多个筛选条件表示为and的关系，表示查询_id=1 and name='salta'的文档；增加查询条件也一样 find({},{\u0026quot;price\u0026quot;:0,\u0026quot;_id\u0026quot;:0})表示从查询结果中剔除price和_id字段；find({},{\u0026quot;name\u0026quot;:1,\u0026quot;price\u0026quot;:1})表示从查询结果中只保留name和price字段。 find()方法中的筛选条件必须是常量 **注意：**第二个参数中如果是保留字段，则必须都是保留字段；如果是剔除字段，则必须都是剔除字段。否则 mongodb 会报错。但_id字段不受此规则限制，可以随意剔除。举例如下：\n//以下代码会报错 db.game.find( {}, { name: 1, price: 0, } ); //以下代码能正常运行 db.game.find( {}, { name: 1, _id: 0, } ); 运行效果如下：\n\u0026gt; db.game.find({},{ ... \u0026#34;name\u0026#34;:1, ... \u0026#34;price\u0026#34;:0 ... }) Error: error: { \u0026#34;ok\u0026#34; : 0, \u0026#34;errmsg\u0026#34; : \u0026#34;Cannot do exclusion on field price in inclusion projection\u0026#34;, \u0026#34;code\u0026#34; : 31254, \u0026#34;codeName\u0026#34; : \u0026#34;Location31254\u0026#34; } \u0026gt; db.game.find({},{ ... \u0026#34;name\u0026#34;:1, ... \u0026#34;_id\u0026#34;:0 ... }) { \u0026#34;name\u0026#34; : \u0026#34;salta legend\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;monster hunter: rise\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;bayonetta\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;nier replicant\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;god of war\u0026#34; } { \u0026#34;name\u0026#34; : \u0026#34;Nioh 2\u0026#34; } 条件查询 $lt,$lte,$gt,$gte,$ne $lt小于 $lte小于等于 $gt大于 $gte大于等于 $ne不等于,$ne可用于任意数据类型 以下代码用来查询价格大于 20,且价格小于等于 280 的 document\ndb.game.find({ price: { $gt: 20, $lte: 280, }, }); 运行效果如下:\n\u0026gt; db.game.find({ ... \u0026#34;price\u0026#34;:{ ... \u0026#34;$gt\u0026#34;:20, ... \u0026#34;$lte\u0026#34;:280 ... } ... }) { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 128, \u0026#34;platform\u0026#34; : [ \u0026#34;steam\u0026#34; ], \u0026#34;comments\u0026#34; : [ { \u0026#34;author\u0026#34; : \u0026#34;xilia\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;hello salta\u0026#34;, \u0026#34;hidden\u0026#34; : true }, { \u0026#34;author\u0026#34; : \u0026#34;salta\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;link\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;link\u0026#34; } ] } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62ba596511721fa1455eb94b\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;nier replicant\u0026#34;, \u0026#34;company\u0026#34; : \u0026#34;square enix\u0026#34;, \u0026#34;price\u0026#34; : 180 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62bd39540a71331919b6295e\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;god of war\u0026#34;, \u0026#34;price\u0026#34; : 30 } $or $or运算符用于表示两个是筛选条件是或的关系,以下代码用来筛选价格大于280或者价格小于等于20的document\ndb.game.find({\u0026#34;$or\u0026#34;:[ {\u0026#34;price\u0026#34;:{\u0026#34;$gt\u0026#34;:280}}, {\u0026#34;price\u0026#34;:{\u0026#34;$lte\u0026#34;:20}} ]}) 代码运行效果如下:\n\u0026gt; db.game.find({\u0026#34;$or\u0026#34;:[ ... {\u0026#34;price\u0026#34;:{\u0026#34;$gt\u0026#34;:280}}, ... {\u0026#34;price\u0026#34;:{\u0026#34;$lte\u0026#34;:20}} ... ]}) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62b9515ba8e0e5b80c720d94\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;salta legend\u0026#34;, \u0026#34;orderDate\u0026#34; : ISODate(\u0026#34;2022-06-27T06:42:35.640Z\u0026#34;), \u0026#34;price\u0026#34; : 327 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62ba565711721fa1455eb949\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;monster hunter: rise\u0026#34;, \u0026#34;orderDate\u0026#34; : ISODate(\u0026#34;2022-06-28T01:16:07.114Z\u0026#34;), \u0026#34;price\u0026#34; : 298 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62ba596511721fa1455eb94a\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;bayonetta\u0026#34;, \u0026#34;company\u0026#34; : \u0026#34;nintendo\u0026#34;, \u0026#34;price\u0026#34; : 318 } $in和$nin $in用来筛选在某些列出的范围内的属性(和sql语句中的in关键字相同)\n$nin是not in的意思\n以下代码用来查询价格在[327,30]两个数字中的结果:\ndb.game.find({\u0026#34;price\u0026#34;:{ \u0026#34;$in\u0026#34;:[327,30] }}) 代码运行效果如下:\n\u0026gt; db.game.find({\u0026#34;price\u0026#34;:{ ... \u0026#34;$in\u0026#34;:[327,30] ... }}) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62b9515ba8e0e5b80c720d94\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;salta legend\u0026#34;, \u0026#34;orderDate\u0026#34; : ISODate(\u0026#34;2022-06-27T06:42:35.640Z\u0026#34;), \u0026#34;price\u0026#34; : 327 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62bd39540a71331919b6295e\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;god of war\u0026#34;, \u0026#34;price\u0026#34; : 30 } $mod $mod为取模运算符,以下代码用来筛选出 对price模3余0的document。\ndb.game.find({\u0026#34;price\u0026#34;:{ \u0026#34;$mod\u0026#34;:[3,0] }}) 代码运行效果为：\n\u0026gt; db.game.find({\u0026#34;price\u0026#34;:{ ... \u0026#34;$mod\u0026#34;:[3,0] ... }}) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62b9515ba8e0e5b80c720d94\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;salta legend\u0026#34;, \u0026#34;orderDate\u0026#34; : ISODate(\u0026#34;2022-06-27T06:42:35.640Z\u0026#34;), \u0026#34;price\u0026#34; : 327 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62ba596511721fa1455eb94a\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;bayonetta\u0026#34;, \u0026#34;company\u0026#34; : \u0026#34;nintendo\u0026#34;, \u0026#34;price\u0026#34; : 318 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62ba596511721fa1455eb94b\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;nier replicant\u0026#34;, \u0026#34;company\u0026#34; : \u0026#34;square enix\u0026#34;, \u0026#34;price\u0026#34; : 180 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62bd39540a71331919b6295e\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;god of war\u0026#34;, \u0026#34;price\u0026#34; : 30 } $not $not表示取反，可用于描述其他运算符，以下代码用来筛选出 不满足对price模3余0的document\ndb.game.find({\u0026#34;price\u0026#34;:{ \u0026#34;$not\u0026#34;:{ \u0026#34;$mod\u0026#34;:[3,0] } }}) 代码运行效果如下：\n\u0026gt; db.game.find({\u0026#34;price\u0026#34;:{ ... \u0026#34;$not\u0026#34;:{ ... \u0026#34;$mod\u0026#34;:[3,0] ... } ... }}) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62ba565711721fa1455eb949\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;monster hunter: rise\u0026#34;, \u0026#34;orderDate\u0026#34; : ISODate(\u0026#34;2022-06-28T01:16:07.114Z\u0026#34;), \u0026#34;price\u0026#34; : 298 } { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 128, \u0026#34;platform\u0026#34; : [ \u0026#34;steam\u0026#34; ], \u0026#34;comments\u0026#34; : [ { \u0026#34;author\u0026#34; : \u0026#34;xilia\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;hello salta\u0026#34;, \u0026#34;hidden\u0026#34; : true }, { \u0026#34;author\u0026#34; : \u0026#34;salta\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;link\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;link\u0026#34; } ] } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62bd3d9f0a71331919b6297a\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;Nioh 2\u0026#34;, \u0026#34;published\u0026#34; : ISODate(\u0026#34;2022-06-30T06:08:30.014Z\u0026#34;) } 类型查询 关于null类型的说明 当查询条件设置为{\u0026quot;platform\u0026quot;:null}时，既可以查到platform=null的文档，也可以查到不存在platform字段的文档。如果只希望得到platform=null的文档，可以通过$exits条件确定该字段存在。\n以下代码用来筛选出platform字段存在，并且为空的文档：\ndb.game.find({\u0026#34;platform\u0026#34;:{ \u0026#34;$eq\u0026#34;:null, \u0026#34;$exists\u0026#34;:true }}) 代码运行效果如下：\n\u0026gt; db.game.insertMany([{name:\u0026#34;it takes two\u0026#34;,platform:null},{name:\u0026#34;naraka\u0026#34;,platform:\u0026#34;\u0026#34;},{name:\u0026#34;gta5\u0026#34;}]) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;insertedIds\u0026#34; : [ ObjectId(\u0026#34;62be8e82718b6cda80d080aa\u0026#34;), ObjectId(\u0026#34;62be8e82718b6cda80d080ab\u0026#34;), ObjectId(\u0026#34;62be8e82718b6cda80d080ac\u0026#34;) ] } \u0026gt; db.game.find({\u0026#34;platform\u0026#34;:{ ... \u0026#34;$eq\u0026#34;:null, ... \u0026#34;$exists\u0026#34;:true ... }}) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62be8e82718b6cda80d080aa\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;it takes two\u0026#34;, \u0026#34;platform\u0026#34; : null } 如果只进行null筛选，效果如下:\n\u0026gt; db.game.find({\u0026#34;platform\u0026#34;:null}) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62b9515ba8e0e5b80c720d94\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;salta legend\u0026#34;, \u0026#34;orderDate\u0026#34; : ISODate(\u0026#34;2022-06-27T06:42:35.640Z\u0026#34;), \u0026#34;price\u0026#34; : 327 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62ba565711721fa1455eb949\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;monster hunter: rise\u0026#34;, \u0026#34;orderDate\u0026#34; : ISODate(\u0026#34;2022-06-28T01:16:07.114Z\u0026#34;), \u0026#34;price\u0026#34; : 298 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62ba596511721fa1455eb94a\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;bayonetta\u0026#34;, \u0026#34;company\u0026#34; : \u0026#34;nintendo\u0026#34;, \u0026#34;price\u0026#34; : 318 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62ba596511721fa1455eb94b\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;nier replicant\u0026#34;, \u0026#34;company\u0026#34; : \u0026#34;square enix\u0026#34;, \u0026#34;price\u0026#34; : 180 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62bd39540a71331919b6295e\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;god of war\u0026#34;, \u0026#34;price\u0026#34; : 30 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62bd3d9f0a71331919b6297a\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;Nioh 2\u0026#34;, \u0026#34;published\u0026#34; : ISODate(\u0026#34;2022-06-30T06:08:30.014Z\u0026#34;) } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62be8e82718b6cda80d080aa\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;it takes two\u0026#34;, \u0026#34;platform\u0026#34; : null } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62be8e82718b6cda80d080ac\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;gta5\u0026#34; } 正则表达式 $regex运算符用来在查询中对字符串进行正则表达时匹配，正则表达式也遵循JavaScript的正则表达式语法。如，以下代码用来查询name字段以n或N开头的文档：\ndb.game.find({\u0026#34;name\u0026#34;:{ \u0026#34;$regex\u0026#34;:/^n/i }}) 查询结果如下：\n\u0026gt; db.game.find({\u0026#34;name\u0026#34;:{ ... \u0026#34;$regex\u0026#34;:/^n/i ... }}) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62ba596511721fa1455eb94b\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;nier replicant\u0026#34;, \u0026#34;company\u0026#34; : \u0026#34;square enix\u0026#34;, \u0026#34;price\u0026#34; : 180 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62bd3d9f0a71331919b6297a\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;Nioh 2\u0026#34;, \u0026#34;published\u0026#34; : ISODate(\u0026#34;2022-06-30T06:08:30.014Z\u0026#34;) } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62be8e82718b6cda80d080ab\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;naraka\u0026#34;, \u0026#34;platform\u0026#34; : \u0026#34;\u0026#34; } 数组查询 测试用法之前先新增数据：\ndb.game.updateOne( {name:\u0026#34;naraka\u0026#34;}, {$set:[ \u0026#34;it is so good\u0026#34;, \u0026#34;it is so pretty\u0026#34;, \u0026#34;i am a old gamer\u0026#34;, \u0026#34;it`s my like\u0026#34;, \u0026#34;i like sanniang\u0026#34; ]} ) 数组内容匹配方式：\n完全匹配整个数组\ndb.game.find({\u0026quot;comments\u0026quot;:[\u0026quot;abc\u0026quot;,\u0026quot;def\u0026quot;]})用来筛选出数组comments字段值为['abc','def']的文档，这种用法和精确匹配完全一样。\n匹配单个数组元素\ndb.game.find({\u0026quot;comments\u0026quot;:\u0026quot;it is so good\u0026quot;})用来筛选出数组comments字段值中包含it is so good元素的文档\n匹配多个数组元素，$all\ndb.game.find({\u0026quot;comments\u0026quot;:{\u0026quot;all\u0026quot;:[\u0026quot;it is so good\u0026quot;,\u0026quot;i am a old gamer\u0026quot;]}})用来筛选出数组元素中包含it is so good和i am a old gamer两个元素的文档。如果$all的数组中只有一个元素，那么使用$all和不适用$all结果一样，即：{\u0026quot;author\u0026quot;:{\u0026quot;$all\u0026quot;:[\u0026quot;apple\u0026quot;]}}和{\u0026quot;author\u0026quot;:\u0026quot;apple\u0026quot;}的筛选结果完全一样\n匹配数组长度\n$size运算符用于匹配数组长度，但$size只能是常数，且$size不能和$lt等比较运算符同时使用。如果需要比较数组的长度，可以单独增加一个size字段，每次修改数组同时修改这个size字段，这在mongoDB中很容易实现。\ndb.game.find({\u0026quot;comments\u0026quot;:{\u0026quot;$size\u0026quot;:3}})用于筛选comments数组长度为3的文档。\n匹配数组元素对象的属性\ndb.game.find({\u0026quot;comments.author\u0026quot;:\u0026quot;salta\u0026quot;})用于筛选comments数组中元素的author属性为salta的文档\n控制返回值数组的长度\n过滤返回值中显示的数组长度可以使用$slice修饰符，整数n表示返回前n条数据，负数n表示返回后n条数据。以下代码用于返回comments字段的前3个元素：\ndb.game.find( {\u0026#34;name\u0026#34;:\u0026#34;naraka\u0026#34;}, {\u0026#34;comments\u0026#34;:{\u0026#34;$slice\u0026#34;:3}} ) 运行效果如下：\n\u0026gt; db.game.find( ... {\u0026#34;name\u0026#34;:\u0026#34;naraka\u0026#34;}, ... {\u0026#34;comments\u0026#34;:{\u0026#34;$slice\u0026#34;:3}} ... ) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62be8e82718b6cda80d080ab\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;naraka\u0026#34;, \u0026#34;platform\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;comments\u0026#34; : [ \u0026#34;it is so good\u0026#34;, \u0026#34;it is so pretty\u0026#34;, \u0026#34;i am a old gamer\u0026#34; ] } 此方法也可以返回数组中的一段数据，以下代码会返回comments字段的第2~第4个元素（忽略前1个元素，从第2个开始返回3个元素）\ndb.game.find( {\u0026#34;name\u0026#34;:\u0026#34;naraka\u0026#34;}, {\u0026#34;comments\u0026#34;:{\u0026#34;$slice\u0026#34;:[1,3]}} ) 显示效果如下：\n\u0026gt; db.game.find( ... {\u0026#34;name\u0026#34;:\u0026#34;naraka\u0026#34;}, ... {\u0026#34;comments\u0026#34;:{\u0026#34;$slice\u0026#34;:[1,3]}} ... ) { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62be8e82718b6cda80d080ab\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;naraka\u0026#34;, \u0026#34;platform\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;comments\u0026#34; : [ \u0026#34;it is so pretty\u0026#34;, \u0026#34;i am a old gamer\u0026#34;, \u0026#34;it`s my like\u0026#34; ] } 只返回数组中匹配到的第一个元素\n可以通过$$运算符来返回匹配到的元素，这种方法只能返回匹配到的第一个元素，返回值的数组中只有一个元素。以下代码用于筛选comments数组字段中的元素对象的author属性，返回值中只有_id和comments字段，且comments字段中只有匹配到的第一个元素。\ndb.game.find( {\u0026#34;comments.author\u0026#34;:\u0026#34;salta\u0026#34;}, {\u0026#34;comments.$\u0026#34;:1} ) 代码运行效果如下：\n\u0026gt; db.game.find( ... {\u0026#34;comments.author\u0026#34;:\u0026#34;salta\u0026#34;}, ... {\u0026#34;comments.$\u0026#34;:1} ... ) { \u0026#34;_id\u0026#34; : 1, \u0026#34;comments\u0026#34; : [ { \u0026#34;author\u0026#34; : \u0026#34;salta\u0026#34; } ] } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62be8e82718b6cda80d080ab\u0026#34;), \u0026#34;comments\u0026#34; : [ { \u0026#34;author\u0026#34; : \u0026#34;salta\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;i am salta\u0026#34; } ] } 数组与范围查询 有以下数据：\ndb.number.insertMany([ {\u0026#34;num\u0026#34;:6}, {\u0026#34;num\u0026#34;:66}, {\u0026#34;num\u0026#34;:666}, {\u0026#34;num\u0026#34;:[6,66]}, {\u0026#34;num\u0026#34;:[6,666]}, {\u0026#34;num\u0026#34;:[6,66,666]} ]) 有以下查询代码：\ndb.number.find({\u0026#34;num\u0026#34;:{ \u0026#34;$gt\u0026#34;:10, \u0026#34;$lt\u0026#34;:100 }}) 此代码目的是查找 10 \u0026lt; n u m \u0026lt; 100 10\u0026lt;num\u0026lt;100 10\u0026lt;num\u0026lt;100的数据，期望能返回的数据为：\n{\u0026#34;num\u0026#34;:66}, 但，实际返回的数据为：\n{\u0026#34;num\u0026#34; : 66 } {\u0026#34;num\u0026#34; : [ 6, 66 ] } {\u0026#34;num\u0026#34; : [ 6, 666 ] } {\u0026#34;num\u0026#34; : [ 6, 66, 666 ] } 因为，在数组的比较中，满足6\u0026lt;100 和666\u0026gt;66\u0026gt;10，所以实际返回值和期望返回值产生了差别，这就使得针对数组的范围查询失效。\n这种现象可以通过$elemMatch表达式解决，但是$elemMatch表达式只能匹配数组元素，对于非数组元素回被跳过。效果如下：\n\u0026gt; db.number.find().pretty() { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62beb40a718b6cda80d080ad\u0026#34;), \u0026#34;num\u0026#34; : 6 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62beb40a718b6cda80d080ae\u0026#34;), \u0026#34;num\u0026#34; : 66 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62beb40a718b6cda80d080af\u0026#34;), \u0026#34;num\u0026#34; : 666 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62beb40a718b6cda80d080b0\u0026#34;), \u0026#34;num\u0026#34; : [ 6, 66 ] } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62beb40a718b6cda80d080b1\u0026#34;), \u0026#34;num\u0026#34; : [ 6, 666 ] } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62beb40a718b6cda80d080b2\u0026#34;), \u0026#34;num\u0026#34; : [ 6, 66, 666 ] } \u0026gt; db.number.find({\u0026#34;num\u0026#34;:{\u0026#34;$elemMatch\u0026#34;:{\u0026#34;$gt\u0026#34;:10,\u0026#34;$lt\u0026#34;:100}}}) \u0026gt; //查询结果为空。可见，{\u0026#34;num\u0026#34;:66}未参与筛选 对于以上现象，可以通过对num字段添加索引，之后使用min和max方法将筛选条件的索引范围限制在最大和最小值之间的形式予以解决。具体代码如下：\n//已对num字段创建索引 db.number.find({\u0026#34;num\u0026#34;:{ \u0026#34;$gt\u0026#34;:10, \u0026#34;$lt\u0026#34;:100 }}).min({\u0026#34;num\u0026#34;:10}).max({\u0026#34;num\u0026#34;:100}) 内嵌文档查询 如果想要通过以下方式查询一个子文档，那么这个被查询必须精确的匹配整个文档（包括各个属性的顺序）。即，如果文档的内容为{\u0026quot;author\u0026quot;:\u0026quot;xilia\u0026quot;,\u0026quot;content\u0026quot;:\u0026quot;hello salta\u0026quot;}，则能匹配成功；但是如果文档中存在更多其他的属性，如{\u0026quot;author\u0026quot;:\u0026quot;xilia\u0026quot;,\u0026quot;content\u0026quot;:\u0026quot;hello salta\u0026quot;,\u0026quot;hidden\u0026quot;:true}则这种匹配方式不能查询出对应的结果。\ndb.game.find({\u0026#34;comments\u0026#34;:{ \u0026#34;author\u0026#34;:\u0026#34;xilia\u0026#34;, \u0026#34;content\u0026#34;:\u0026#34;hello salta\u0026#34; }}) 更重要的一点是，除了需要匹配整个文档之外，这种查询方式还是强顺序相关的，两个条件的顺序必须符合要求才能成功匹配。\n在这中情况下，需要使用点调用1的方式\ndb.game.find({ \u0026#34;comments.author\u0026#34;:\u0026#34;xilia\u0026#34;, \u0026#34;comments.content\u0026#34;:\u0026#34;hello salta\u0026#34; }) 效果如下：\n\u0026gt; db.game.find({\u0026#34;comments\u0026#34;:{ ... \u0026#34;author\u0026#34;:\u0026#34;xilia\u0026#34;, ... \u0026#34;content\u0026#34;:\u0026#34;hello salta\u0026#34; ... }}) \u0026gt; db.game.find({ ... \u0026#34;comments.author\u0026#34;:\u0026#34;xilia\u0026#34;, ... \u0026#34;comments.content\u0026#34;:\u0026#34;hello salta\u0026#34; ... }) { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 128, \u0026#34;platform\u0026#34; : [ \u0026#34;steam\u0026#34; ], \u0026#34;comments\u0026#34; : [ { \u0026#34;author\u0026#34; : \u0026#34;xilia\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;hello salta\u0026#34;, \u0026#34;hidden\u0026#34; : true }, { \u0026#34;author\u0026#34; : \u0026#34;salta\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;link\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;link\u0026#34; } ] } $where查询 对于有些特殊的查询，无法通过以上任何一种方式表示出来，mongoDB提供了$where子句这种查询方式。$where子句允许在查询中执行JavaScript代码，这样就能在JavaScript代码中执行某些特殊的比较逻辑。但是为了安全和效率的要求，应该尽量减少或消除使用$where，并且禁止普通用户使用。\n在$where查询过程中，每个文档都必须从BSON转换成JavaScript对象，而且$where查询也不能使用索引，所以有很大的性能问题。\n具体使用方法如下：\n/** * 查询文档中存在两个字段满足以下条件： * 1.其中一个字段是日期类型，并且时间在当前日期之前； * 2.另一个字段是数字类型，并且这个数字小于300。 */ db.game.find({\u0026#34;$where\u0026#34;:function(){ for(var param_1 in this){ for(var param_2 in this){ return this[param_1]\u0026lt;new Date() \u0026amp;\u0026amp; this[param_2]\u0026lt;300; } } return false; }}).pretty() 执行效果如下：\n\u0026gt; db.game.find({\u0026#34;$where\u0026#34;:function(){ ... for(var param_1 in this){ ... for(var param_2 in this){ ... return this[param_1]\u0026lt;new Date() \u0026amp;\u0026amp; this[param_2]\u0026lt;300; ... } ... } ... return false; ... }}).pretty() { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 128, \u0026#34;platform\u0026#34; : [ \u0026#34;steam\u0026#34; ], \u0026#34;comments\u0026#34; : [ { \u0026#34;author\u0026#34; : \u0026#34;xilia\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;hello salta\u0026#34;, \u0026#34;hidden\u0026#34; : true }, { \u0026#34;author\u0026#34; : \u0026#34;salta\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;link\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;link\u0026#34; } ] } 游标 游标基础 find()方法的返回值是一个游标对象，通过对游标对象的各种操作，可以对查询结果进行输出控制。（在mongoDBshell中执行find()方法的打印操作是shell自动执行的结果）游标对象提供了hasNex()和next()两个方法，典型的使用方式为：\nvar cursor=db.game.find() while(cursor.hasNext()){ var item=cursor.next() print(item.name) } 同时游标对象也实现了迭代器接口，可以在forEach()方法中进行操作，使用方式如下：\nvar cursor=db.game.find(); cursor.forEach(res=\u0026gt;{ print(res.name) }) 注意：当调用find()方法时，shell并不会立即执行查询操作，而是真正开始获取结果时才执行查询操作。所以可以在查询之前进行一些额外的操作，如：排序、分页、限制长度等，这些操作的返回值仍然是一个游标对象。\n因此，以下三行代码返回的数据相同：\ndb.game.find().sort({\u0026#34;price\u0026#34;:1}).limit(3).skip(2).pretty(); db.game.find().sort({\u0026#34;price\u0026#34;:1}).skip(2).limit(3).pretty(); db.game.find().limit(3).sort({\u0026#34;price\u0026#34;:1}).skip(2).pretty(); db.game.find().limit(3).skip(2).sort({\u0026#34;price\u0026#34;:1}).pretty(); db.game.find().skip(2).limit(3).sort({\u0026#34;price\u0026#34;:1}).pretty(); db.game.find().skip(2).sort({\u0026#34;price\u0026#34;:1}).limit(3).pretty(); 当hasNext()方法被调用后，查询条件会发送到服务端，之后shell会获取一段查询结果（这里的一段是100个结果或4MB数据中的较小值），在客户端遍历完这些数据后，shell会再次链接数据库，使用getMore获取更多数据。\nlimit()、skip()、sort() 这三个函数的使用方法如下：\n//限制只返回三个结果 db.game.find().limit(3) //跳过前三条数据 db.game.find().skip(3) //按价格升序排序，-1表示降序 db.game.find().sort({\u0026#34;price\u0026#34;:1}) 以上三个方法可以结合使用。对于一个字段的数据包含多种类型时，mongoDB预设了排序顺序，从最小值到最大值顺序为：\n序号 类型 1 最小值 2 null 3 数字 4 字符串 5 对象、文档 6 数组 7 二进制数据 8 对象ID 9 布尔 10 日期 11 时间戳 12 正则表达式 13 最大值 注意：当skip()方法跳过大量数据时会产生性能问题，所以对于大数据量的分页操作，通常不用skip()方法实现。假设有一个需求，需要使用create_date字段降序排列，可以通过如下方式操作：\nvar page_1=db.game.find().sort({\u0026#34;create_date\u0026#34;:-1}).limit(20); var latest=null; while(page_1.hasNext()){ latest=page_1.next(); //do sth } var page_2=db.game.find({ \u0026#34;create_date\u0026#34;:{\u0026#34;$lt\u0026#34;:latest.create_date} }).sort({\u0026#34;create_date\u0026#34;:-1}).limit(100) 游标的生命周期 一个游标会占用服务器的资源，在满足一定的条件之后，服务端会释放这个游标的资源，这些条件包括：\n游标遍历完所有的结果 客户端要求终止该游标 当游标超出客户端的作用域，驱动程序会向数据库发送一条 “可以销毁该游标” 的消息 一个游标如果10分钟内没有被使用，数据库会自动销毁 ","permalink":"https://liiqii.github.io/posts/tech/mongo/mongo_query/","summary":"转自：【Mongo】MongoDB文档查询 数据查询 find()方法 方法说明 find()方法没有参数时会匹配集合中的所有内容，find({})和find()功能一样 find({\u0026quot;_id\u0026quot;:1})表示查询_id字段为 1 的文档；find({\u0026quot;_id\u0026quo","title":"【Mongo】MongoDB文档查询"},{"content":"转自：【Mongo】MongoDB文档的增删改操作\n数据增删 插入 document 单条插入 insertOne()方法可以向数据库中插入一条数据，效果如下:\n\u0026gt; db.game.insertOne({name:\u0026#34;monster hunter: rise\u0026#34;,orderDate:new Date(),price:298}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;insertedId\u0026#34; : ObjectId(\u0026#34;62ba565711721fa1455eb949\u0026#34;) } 此方法会为 document 自动添加一个_id键，_id也可以自己添加，比如这样：\n\u0026gt; db.game.insertOne({name:\u0026#34;monster hunter: world\u0026#34;,orderDate:new Date(),price:298,_id:1}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;insertedId\u0026#34; : 1 } 多条插入 insertMany()方法可以向数据库中插入一个document数组，效果如下：\n\u0026gt; db.game.insertMany([{name:\u0026#34;bayonetta\u0026#34;,company:\u0026#34;nintendo\u0026#34;,price:318},{name:\u0026#34;nier replicant\u0026#34;,company:\u0026#34;square enix\u0026#34;,price:180},{name:\u0026#34;the king of fighters xiii\u0026#34;,company:\u0026#34;snk corporation\u0026#34;,price:28}]) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;insertedIds\u0026#34; : [ ObjectId(\u0026#34;62ba596511721fa1455eb94a\u0026#34;), ObjectId(\u0026#34;62ba596511721fa1455eb94b\u0026#34;), ObjectId(\u0026#34;62ba596511721fa1455eb94c\u0026#34;) ] } insertMany()方法默认为有序插入，可以通过指定第二个参数的形式允许 mongoDB 重新排列插入的顺序，来提高性能，使用方法如下：\n\u0026gt; db.game.insertMany([ ... {name:\u0026#34;fifa 22\u0026#34;, price:63, platform:\u0026#34;switch\u0026#34;}, ... {name:\u0026#34;animal crossing: new horizons\u0026#34;, price:326, platform:\u0026#34;switch\u0026#34;}, ... {name:\u0026#34;god of war\u0026#34;, price:128, platform:\u0026#34;psn\u0026#34;}, ... {name:\u0026#34;it takes two\u0026#34;, price:99, platform:\u0026#34;steam\u0026#34;} ... ],{order:false}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;insertedIds\u0026#34; : [ ObjectId(\u0026#34;62ba629011721fa1455eb94d\u0026#34;), ObjectId(\u0026#34;62ba629011721fa1455eb94e\u0026#34;), ObjectId(\u0026#34;62ba629011721fa1455eb94f\u0026#34;), ObjectId(\u0026#34;62ba629011721fa1455eb950\u0026#34;) ] } 如果在插入数据过程中发现中间某个数据错误（如：存在相同的_id值），在有序插入中会立即中断程序，而在无序插入中会跳过此条文档，继续插入后边的数据。\n注意：insertMany()方法可以将多个document插入到单个集合中。如果在数据导入的场景下，应该使用数据导入工具，因为 MongoDB 能够接受到的消息是有最大长度限制的（4.0.5 版本 MongoDB 最大消息长度是 48MB，如果超过限制，多数驱动程序会将其拆分为多个 48MB 的请求1）\n删除操作 删除文档（document） 在 MongoDB 中删除文档可以使用方法deleteOne()和deleteMany()，使用方法如下：\n\u0026gt; db.game.deleteOne({name:\u0026#34;fifa 22\u0026#34;}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;deletedCount\u0026#34; : 1 } \u0026gt; db.game.deleteMany({platform:\u0026#34;switch\u0026#34;}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;deletedCount\u0026#34; : 2 } 其中，deleteOne()方法用于删除第一个符合条件的文档，deleteMany()方法用于删除所有符合条件的文档。\n注意：db.game.deleteMany({})方法会删除集合中的所有文档，慎用\n删除集合 drop()方法可以用于删除一个集合，使用方法如下：\ndb.game.drop(); 数据更新 MongoDB 针对更新操作提供了三个方法，分别是updateOne()、updateMany()和replaceOne()。\n其中，updateOne()和updateMany()用来对已有文档的更新操作，第一个参数为筛选条件，第二个参数为更改描述；replaceOne()方法用于替换匹配的文档，第一个参数为筛选条件，第二个参数是用来替换的新文档。\n替换文档 \u0026gt; db.game.replaceOne({_id:1},{name:\u0026#34;monster hunter: world\u0026#34;,price:128,platform:\u0026#34;steam\u0026#34;}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;matchedCount\u0026#34; : 1, \u0026#34;modifiedCount\u0026#34; : 1 } 注意：在更新操作中最好使用_id字段或其他唯一字段作为筛选条件，避免出现更新错误的问题\n更新运算符 更新运算符是 MongoDB 内置的特殊键，可以用于指定复杂的更新操作，但是不能修改_id的值。\n$set 运算符 用于设置一个 key 的值，如果这个 key 不存在，则会创建一组对应的 k-v，使用方法为：\n\u0026gt; db.game.updateOne({_id:1},{$set:{company:\u0026#34;capcon\u0026#34;}}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;matchedCount\u0026#34; : 1, \u0026#34;modifiedCount\u0026#34; : 1 } \u0026gt; db.game.updateOne({_id:1},{$set:{company:\u0026#34;capcom\u0026#34;}}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;matchedCount\u0026#34; : 1, \u0026#34;modifiedCount\u0026#34; : 1 } \u0026gt; db.game.findOne({_id:1}) { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 128, \u0026#34;platform\u0026#34; : \u0026#34;steam\u0026#34;, \u0026#34;company\u0026#34; : \u0026#34;capcom\u0026#34; } $set 运算符支持修改键的类型，如：\n\u0026gt; db.game.updateOne({_id:1},{$set:{platform:[\u0026#34;steam\u0026#34;,\u0026#34;psn\u0026#34;,\u0026#34;xbox\u0026#34;]}}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;matchedCount\u0026#34; : 1, \u0026#34;modifiedCount\u0026#34; : 1 } \u0026gt; db.game.findOne({_id:1}) { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 128, \u0026#34;platform\u0026#34; : [ \u0026#34;steam\u0026#34;, \u0026#34;psn\u0026#34;, \u0026#34;xbox\u0026#34; ], \u0026#34;company\u0026#34; : \u0026#34;capcom\u0026#34; } $set运算符同样支持修改内嵌文档中的数据，使用方式为：\n\u0026gt; db.game.updateOne({_id:1},{$set:{company:{name:\u0026#34;capcom\u0026#34;,region:\u0026#34;日本\u0026#34;}}}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;matchedCount\u0026#34; : 1, \u0026#34;modifiedCount\u0026#34; : 1 } \u0026gt; db.game.findOne({_id:1}) { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 128, \u0026#34;platform\u0026#34; : [ \u0026#34;steam\u0026#34;, \u0026#34;psn\u0026#34;, \u0026#34;xbox\u0026#34; ], \u0026#34;company\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;capcom\u0026#34;, \u0026#34;region\u0026#34; : \u0026#34;日本\u0026#34; } } \u0026gt; \u0026gt; db.game.updateOne({_id:1},{$set:{\u0026#34;company.region\u0026#34;:\u0026#34;america\u0026#34;}}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;matchedCount\u0026#34; : 1, \u0026#34;modifiedCount\u0026#34; : 1 } \u0026gt; db.game.findOne({_id:1}) { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 128, \u0026#34;platform\u0026#34; : [ \u0026#34;steam\u0026#34;, \u0026#34;psn\u0026#34;, \u0026#34;xbox\u0026#34; ], \u0026#34;company\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;capcom\u0026#34;, \u0026#34;region\u0026#34; : \u0026#34;america\u0026#34; } } $inc 运算符 $inc 运算符用来对数字类型的键进行递增操作，如果该键不存在，则会新建。使用方法如下：\n\u0026gt; db.game.updateOne({_id:1},{$inc:{price:2}}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;matchedCount\u0026#34; : 1, \u0026#34;modifiedCount\u0026#34; : 1 } \u0026gt; db.game.findOne({_id:1}) { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 130, \u0026#34;platform\u0026#34; : [ \u0026#34;steam\u0026#34;, \u0026#34;psn\u0026#34;, \u0026#34;xbox\u0026#34; ], \u0026#34;company\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;capcom\u0026#34;, \u0026#34;region\u0026#34; : \u0026#34;america\u0026#34; } } \u0026gt; db.game.updateOne({_id:1},{$inc:{score:5}}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;matchedCount\u0026#34; : 1, \u0026#34;modifiedCount\u0026#34; : 1 } \u0026gt; db.game.findOne({_id:1}) { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 130, \u0026#34;platform\u0026#34; : [ \u0026#34;steam\u0026#34;, \u0026#34;psn\u0026#34;, \u0026#34;xbox\u0026#34; ], \u0026#34;company\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;capcom\u0026#34;, \u0026#34;region\u0026#34; : \u0026#34;america\u0026#34; }, \u0026#34;score\u0026#34; : 5 } \u0026gt; db.game.updateOne({_id:1},{$inc:{score:-3}}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;matchedCount\u0026#34; : 1, \u0026#34;modifiedCount\u0026#34; : 1 } \u0026gt; db.game.findOne({_id:1}) { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 130, \u0026#34;platform\u0026#34; : [ \u0026#34;steam\u0026#34;, \u0026#34;psn\u0026#34;, \u0026#34;xbox\u0026#34; ], \u0026#34;company\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;capcom\u0026#34;, \u0026#34;region\u0026#34; : \u0026#34;america\u0026#34; }, \u0026#34;score\u0026#34; : 2 } 注意：$inc 运算符只能操作整型、长整型、双精度浮点型三种类型的数据，如果用在其他类型，会报错。\n数组运算符 $push 运算符 $push运算符用于在数组末尾添加一个元素，如果数组不存在，则会自动创建并添加一条数据，以下代码用于在comments数组中添加一条数据\ndb.game.updateOne( { _id: 1 }, { $push: { comments: { author: \u0026#34;tom\u0026#34;, content: \u0026#34;it is very good\u0026#34; }, }, } ); 效果如下:\n\u0026gt; db.game.updateOne({_id:1},{$push:{ ... comments:{author:\u0026#34;tom\u0026#34;,content:\u0026#34;it is very good\u0026#34;} ... }}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;matchedCount\u0026#34; : 1, \u0026#34;modifiedCount\u0026#34; : 1 } \u0026gt; db.game.findOne({_id:1}) { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 128, \u0026#34;platform\u0026#34; : [ \u0026#34;steam\u0026#34; ], \u0026#34;comments\u0026#34; : [ { \u0026#34;author\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;it is very good\u0026#34; } ] } $each 修饰符 $each和$push配合使用，可以在一次操作中添加多条数据，以下代码用来新增两条评论\ndb.game.updateOne( { _id: 1 }, { $push: { comments: { $each: [ { author: \u0026#34;link\u0026#34;, content: \u0026#34;i can hunt everything\u0026#34; }, { author: \u0026#34;salta\u0026#34;, content: \u0026#34;link stop~~\u0026#34; }, ], }, }, } ); 效果如下：\n\u0026gt; db.game.updateOne({_id:1},{$push:{ ... comments:{$each:[ ... {author:\u0026#34;link\u0026#34;,content:\u0026#34;i can hunt everything\u0026#34;}, ... {author:\u0026#34;salta\u0026#34;,content:\u0026#34;link stop~~\u0026#34;} ... ]} ... }}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;matchedCount\u0026#34; : 1, \u0026#34;modifiedCount\u0026#34; : 1 } \u0026gt; db.game.findOne({_id:1}) { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 128, \u0026#34;platform\u0026#34; : [ \u0026#34;steam\u0026#34; ], \u0026#34;comments\u0026#34; : [ { \u0026#34;author\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;it is very good\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;jerry\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;it is very very good\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;link\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;i can hunt everything\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;salta\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;link stop~~\u0026#34; } ] } $slice 修饰符 $slice修饰符能控制数组只增长到某个长度（如 5），可以防止数据增长过长。如果数组数量超过这个限制长度，则多余的数据不会插入。以下代码用于插入 2 条新评论并限制数组长度不能超过 5\ndb.game.updateOne( { _id: 1 }, { $push: { comments: { $each: [ { author: \u0026#34;kaiya\u0026#34;, content: \u0026#34;shabby\u0026#34; }, { author: \u0026#34;ying\u0026#34;, content: \u0026#34;kaiya laji\u0026#34; }, ], $slice: 5, }, }, } ); 效果如下：\n\u0026gt; db.game.updateOne({_id:1},{$push:{ ... comments:{ ... $each:[ ... {author:\u0026#34;kaiya\u0026#34;,content:\u0026#34;shabby\u0026#34;}, ... {author:\u0026#34;ying\u0026#34;,content:\u0026#34;kaiya laji\u0026#34;} ... ], ... $slice:5 ... } ... }}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;matchedCount\u0026#34; : 1, \u0026#34;modifiedCount\u0026#34; : 1 } \u0026gt; db.game.findOne({_id:1}) { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 128, \u0026#34;platform\u0026#34; : [ \u0026#34;steam\u0026#34; ], \u0026#34;comments\u0026#34; : [ { \u0026#34;author\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;it is very good\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;jerry\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;it is very very good\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;link\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;i can hunt everything\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;salta\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;link stop~~\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;kaiya\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;shabby\u0026#34; } ] } $sort 修饰符 $sort用于在截断数组之前对数组进行排序，然后再保留对应的长度，以下代码用来插入后排序：\ndb.game.updateOne( { _id: 1 }, { $push: { comments: { $each: [ { author: \u0026#34;alix\u0026#34;, content: \u0026#34;it`s so cool\u0026#34; }, { author: \u0026#34;bill\u0026#34;, content: \u0026#34;oh my god of war\u0026#34; }, ], $slice: 5, $sort: { author: 1 }, }, }, } ); 效果如下：\n\u0026gt; db.game.updateOne({_id:1},{$push:{ ... comments:{ ... $each:[ ... {author:\u0026#34;alix\u0026#34;,content:\u0026#34;it`s so cool\u0026#34;}, ... {author:\u0026#34;bill\u0026#34;,content:\u0026#34;oh my god of war\u0026#34;} ... ], ... $slice:5, ... $sort:{author:1} ... } ... }}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;matchedCount\u0026#34; : 1, \u0026#34;modifiedCount\u0026#34; : 1 } \u0026gt; db.game.findOne({_id:1}) { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 128, \u0026#34;platform\u0026#34; : [ \u0026#34;steam\u0026#34; ], \u0026#34;comments\u0026#34; : [ { \u0026#34;author\u0026#34; : \u0026#34;alix\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;it`s so cool\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;bill\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;oh my god of war\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;jerry\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;it is very very good\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;link\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;i can hunt everything\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;salta\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;link stop~~\u0026#34; } ] } 注意：不能将$sort或$slice修饰符单独与$push使用，使用时必须有$each存在\n$addToSet 运算符 用于在添加数据时避免重复数据，用法如下：\ndb.game.updateOne( { _id: 1 }, { $set: { comments: [{ author: \u0026#34;salta\u0026#34;, content: \u0026#34;it`s so cool\u0026#34; }] } } ); db.game.updateOne( { _id: 1 }, { $addToSet: { comments: { author: \u0026#34;salta\u0026#34;, content: \u0026#34;it`s my like\u0026#34; }, }, } ); 效果如下：\n\u0026gt; //comments数据设置为一条 \u0026gt; db.game.updateOne({_id:1},{$set:{comments:[{author:\u0026#34;salta\u0026#34;,content:\u0026#34;it`s so cool\u0026#34;}]}}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;matchedCount\u0026#34; : 1, \u0026#34;modifiedCount\u0026#34; : 1 } \u0026gt; db.game.findOne({_id:1}) { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 128, \u0026#34;platform\u0026#34; : [ \u0026#34;steam\u0026#34; ], \u0026#34;comments\u0026#34; : [ { \u0026#34;author\u0026#34; : \u0026#34;salta\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;it`s so cool\u0026#34; } ] } \u0026gt; //插入一条新数据，新数据其中一个字段不同，可以正常插入 \u0026gt; db.game.updateOne({_id:1},{$addToSet:{ ... comments:{author:\u0026#34;salta\u0026#34;,content:\u0026#34;it`s my like\u0026#34;} ... }}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;matchedCount\u0026#34; : 1, \u0026#34;modifiedCount\u0026#34; : 1 } \u0026gt; db.game.findOne({_id:1}) { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 128, \u0026#34;platform\u0026#34; : [ \u0026#34;steam\u0026#34; ], \u0026#34;comments\u0026#34; : [ { \u0026#34;author\u0026#34; : \u0026#34;salta\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;it`s so cool\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;salta\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;it`s my like\u0026#34; } ] } \u0026gt; //插入和上一次一样的数据，这次不能正常插入，modifiedCount=0 \u0026gt; db.game.updateOne({_id:1},{$addToSet:{ comments:{author:\u0026#34;salta\u0026#34;,content:\u0026#34;it`s my like\u0026#34;} }}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;matchedCount\u0026#34; : 1, \u0026#34;modifiedCount\u0026#34; : 0 } \u0026gt; db.game.findOne({_id:1}) { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 128, \u0026#34;platform\u0026#34; : [ \u0026#34;steam\u0026#34; ], \u0026#34;comments\u0026#34; : [ { \u0026#34;author\u0026#34; : \u0026#34;salta\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;it`s so cool\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;salta\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;it`s my like\u0026#34; } ] } $addToSet运算符可以和$each修饰符配合使用，来插入多条数据，使用方法和$push运算符相同。\n$pop $pop运算符可以从数据头部或尾部删除一个元素，具体用法如下：\n//先添加数据 db.game.updateOne( { _id: 1 }, { $push: { comments: { $each: [ { author: \u0026#34;link\u0026#34;, content: \u0026#34;hello salta\u0026#34; }, { author: \u0026#34;xilia\u0026#34;, content: \u0026#34;shabby\u0026#34; }, { author: \u0026#34;ying\u0026#34;, content: \u0026#34;oh my kong\u0026#34; }, ], }, }, } ); //从头部删除数据 db.game.updateOne({ _id: 1 }, { $pop: { comments: -1 } }); //从末尾删除数据 db.game.updateOne({ _id: 1 }, { $pop: { comments: 1 } }); 效果如下：\n\u0026gt; db.game.updateOne({_id:1},{$push:{ ... comments:{$each:[ ... {author:\u0026#34;link\u0026#34;,content:\u0026#34;hello salta\u0026#34;}, ... {author:\u0026#34;xilia\u0026#34;,content:\u0026#34;shabby\u0026#34;}, ... {author:\u0026#34;ying\u0026#34;,content:\u0026#34;oh my kong\u0026#34;} ... ]} ... }}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;matchedCount\u0026#34; : 1, \u0026#34;modifiedCount\u0026#34; : 1 } \u0026gt; db.game.findOne({_id:1}) { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 128, \u0026#34;platform\u0026#34; : [ \u0026#34;steam\u0026#34; ], \u0026#34;comments\u0026#34; : [ { \u0026#34;author\u0026#34; : \u0026#34;salta\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;it`s so cool\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;salta\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;it`s my like\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;link\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;hello salta\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;xilia\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;shabby\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;ying\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;oh my kong\u0026#34; } ] } \u0026gt; db.game.updateOne({_id:1},{$pop:{comments:-1}}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;matchedCount\u0026#34; : 1, \u0026#34;modifiedCount\u0026#34; : 1 } \u0026gt; db.game.findOne({_id:1}) { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 128, \u0026#34;platform\u0026#34; : [ \u0026#34;steam\u0026#34; ], \u0026#34;comments\u0026#34; : [ { \u0026#34;author\u0026#34; : \u0026#34;salta\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;it`s my like\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;link\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;hello salta\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;xilia\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;shabby\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;ying\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;oh my kong\u0026#34; } ] } \u0026gt; db.game.updateOne({_id:1},{$pop:{comments:1}}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;matchedCount\u0026#34; : 1, \u0026#34;modifiedCount\u0026#34; : 1 } \u0026gt; db.game.updateOne({_id:1},{$pop:{comments:1}}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;matchedCount\u0026#34; : 1, \u0026#34;modifiedCount\u0026#34; : 1 } \u0026gt; db.game.findOne({_id:1}) { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 128, \u0026#34;platform\u0026#34; : [ \u0026#34;steam\u0026#34; ], \u0026#34;comments\u0026#34; : [ { \u0026#34;author\u0026#34; : \u0026#34;salta\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;it`s my like\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;link\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;hello salta\u0026#34; } ] } $pull $pull用于删除数组中所有符合特定条件的元素，以下方法用来删除 comments 数组中含有author:\u0026quot;salta\u0026quot;的所有元素：\ndb.game.updateOne({ _id: 1 }, { $pull: { comments: { author: \u0026#34;salta\u0026#34; } } }); 效果如下：\n\u0026gt; db.game.updateOne({_id:1},{$pull:{comments:{author:\u0026#34;salta\u0026#34;}}}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;matchedCount\u0026#34; : 1, \u0026#34;modifiedCount\u0026#34; : 1 } \u0026gt; db.game.findOne({_id:1}) { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 128, \u0026#34;platform\u0026#34; : [ \u0026#34;steam\u0026#34; ], \u0026#34;comments\u0026#34; : [ { \u0026#34;author\u0026#34; : \u0026#34;link\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;hello salta\u0026#34; } ] } 注意：如上例所示，在使用$pull运算符处理对象数组时，如果按对象的某一个属性删除，则只判断这一个属性是否符合条件，其他属性不参与判断\n定位运算符($) $$运算符用于对符合筛选条件的第一个文档进行修改，以下代码用于修改 document 的数组元素comments中第一个author=link的元素，改为author=salta：\ndb.game.updateOne( { \u0026#34;comments.author\u0026#34;: \u0026#34;link\u0026#34; }, { $set: { \u0026#34;comments.$.author\u0026#34;: \u0026#34;salta\u0026#34;, }, } ); 运行效果如下：\n\u0026gt; db.game.find({_id:1}).pretty() { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 128, \u0026#34;platform\u0026#34; : [ \u0026#34;steam\u0026#34; ], \u0026#34;comments\u0026#34; : [ { \u0026#34;author\u0026#34; : \u0026#34;link\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;hello salta\u0026#34; } ] } \u0026gt; db.game.updateOne({\u0026#34;comments.author\u0026#34;:\u0026#34;link\u0026#34;},{$set:{ ... \u0026#34;comments.$.author\u0026#34;:\u0026#34;salta\u0026#34; ... }}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;matchedCount\u0026#34; : 1, \u0026#34;modifiedCount\u0026#34; : 1 } \u0026gt; db.game.find({_id:1}).pretty() { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 128, \u0026#34;platform\u0026#34; : [ \u0026#34;steam\u0026#34; ], \u0026#34;comments\u0026#34; : [ { \u0026#34;author\u0026#34; : \u0026#34;salta\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;hello salta\u0026#34; } ] } 如果已知修改元素在数组中的位置，可以通过数组下标对元素进行修改，以下代码用于对_id=1的文档中comments数组中的第一个元素进行修改：\ndb.game.updateOne( { _id: 1 }, { $set: { \u0026#34;comments.0.author\u0026#34;: \u0026#34;xilia\u0026#34;, }, } ); 运行效果如下：\n\u0026gt; db.game.updateOne({_id:1},{$set:{ ... \u0026#34;comments.0.author\u0026#34;:\u0026#34;xilia\u0026#34; ... }}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;matchedCount\u0026#34; : 1, \u0026#34;modifiedCount\u0026#34; : 1 } \u0026gt; db.game.find({_id:1}).pretty() { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 128, \u0026#34;platform\u0026#34; : [ \u0026#34;steam\u0026#34; ], \u0026#34;comments\u0026#34; : [ { \u0026#34;author\u0026#34; : \u0026#34;xilia\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;hello salta\u0026#34; } ] } 使用数组过滤器更新 MongoDB3.6 引入了数组过滤器arrayFilters，可以在数组中筛选出符合条件的元素，并对其进行更新。以下代码用于对数组中的元素筛选出author=\u0026quot;xilia\u0026quot;的元素，并添加hidden=true数据：\ndb.game.updateOne( { _id: 1 }, { $set: { \u0026#34;comments.$[item].hidden\u0026#34;: true, }, }, { arrayFilters: [{ \u0026#34;item.author\u0026#34;: \u0026#34;xilia\u0026#34; }] } ); 执行修改之前先添加测试数据：\n\u0026gt; db.game.updateOne({_id:1},{$push:{comments:{$each:[{author:\u0026#34;salta\u0026#34;},{author:\u0026#34;link\u0026#34;},{author:\u0026#34;link\u0026#34;}]}}}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;matchedCount\u0026#34; : 1, \u0026#34;modifiedCount\u0026#34; : 1 } \u0026gt; db.game.find({_id:1}).pretty() { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 128, \u0026#34;platform\u0026#34; : [ \u0026#34;steam\u0026#34; ], \u0026#34;comments\u0026#34; : [ { \u0026#34;author\u0026#34; : \u0026#34;xilia\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;hello salta\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;salta\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;link\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;link\u0026#34; } ] } 运行效果如下：\n\u0026gt; db.game.updateOne( ... {_id:1}, ... {$set:{ ... \u0026#34;comments.$[item].hidden\u0026#34;:true ... }}, ... {arrayFilters:[ ... {\u0026#34;item.author\u0026#34;:\u0026#34;xilia\u0026#34;} ... ]} ... ) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;matchedCount\u0026#34; : 1, \u0026#34;modifiedCount\u0026#34; : 1 } \u0026gt; db.game.find({_id:1}).pretty() { \u0026#34;_id\u0026#34; : 1, \u0026#34;name\u0026#34; : \u0026#34;monster hunter: world\u0026#34;, \u0026#34;price\u0026#34; : 128, \u0026#34;platform\u0026#34; : [ \u0026#34;steam\u0026#34; ], \u0026#34;comments\u0026#34; : [ { \u0026#34;author\u0026#34; : \u0026#34;xilia\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;hello salta\u0026#34;, \u0026#34;hidden\u0026#34; : true }, { \u0026#34;author\u0026#34; : \u0026#34;salta\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;link\u0026#34; }, { \u0026#34;author\u0026#34; : \u0026#34;link\u0026#34; } ] } upsert 更新 upsert关键字用于updateOne()或updateMany()方法的第三个参数，第三个参数是一个选项文档，可以指定选项文档的操作。\nupsert表示如果能筛选到匹配的文档，则会对所有匹配的文档进行更新；如果更新筛选条件中找不到所匹配的文档，则会以筛选条件和更新内容为基础，创建一个新的文档。注意，这一流程是原子性的。以下为操作示例：\n此操作表示name=\u0026quot;god of war\u0026quot;的游戏，涨价 30 元\ndb.game.updateOne( { name: \u0026#34;god of war\u0026#34; }, { $inc: { price: 30, }, }, { upsert: true } ); 运行效果如下：\n\u0026gt; db.game.updateOne( ... {name:\u0026#34;god of war\u0026#34;}, ... {$inc:{ ... price:30 ... }}, ... {upsert:true} ... ) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;matchedCount\u0026#34; : 1, \u0026#34;modifiedCount\u0026#34; : 1 } \u0026gt; db.game.find({name:\u0026#34;god of war\u0026#34;}).pretty() { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62ba629011721fa1455eb94f\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;god of war\u0026#34;, \u0026#34;price\u0026#34; : 158, \u0026#34;platform\u0026#34; : \u0026#34;psn\u0026#34; } 删除此文档后再执行效果如下：\n# 按名称查询，有一条结果 \u0026gt; db.game.find({name:\u0026#34;god of war\u0026#34;}).pretty() { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62ba629011721fa1455eb94f\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;god of war\u0026#34;, \u0026#34;price\u0026#34; : 158, \u0026#34;platform\u0026#34; : \u0026#34;psn\u0026#34; } # 删除此结果 \u0026gt; db.game.deleteOne({name:\u0026#34;god of war\u0026#34;}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;deletedCount\u0026#34; : 1 } # 按名称查询，没有结果 \u0026gt; db.game.find({name:\u0026#34;god of war\u0026#34;}).pretty() # 执行upsert更新 \u0026gt; db.game.updateOne( {name:\u0026#34;god of war\u0026#34;}, {$inc:{ price:30 }}, {upsert:true} ) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;matchedCount\u0026#34; : 0, \u0026#34;modifiedCount\u0026#34; : 0, \u0026#34;upsertedId\u0026#34; : ObjectId(\u0026#34;62bd39540a71331919b6295e\u0026#34;) } # 再次按名称查询，有一个新的文档 \u0026gt; db.game.find({name:\u0026#34;god of war\u0026#34;}).pretty() { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62bd39540a71331919b6295e\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;god of war\u0026#34;, \u0026#34;price\u0026#34; : 30 } $setOnInsert 运算符 此运算符表示，只有再插入文档数据时才会对字段进行设置，后续更新不会对该字段进行任何更改（类似于create_date）。以下代码作用为：\n当存在name=\u0026quot;Nioh 2\u0026quot;时以下代码更新失效，如果不存在，则会创建新的数据，新数据可以通过 $set运算符更新，但不能通过$setOnInsert运算符更新\ndb.game.updateOne( { name: \u0026#34;Nioh 2\u0026#34; }, { $setOnInsert: { published: new Date(), }, }, { upsert: true } ); 运行效果如下：\n# 不存在数据的前提下，upsert更新 \u0026gt; db.game.updateOne( ... {name:\u0026#34;Nioh 2\u0026#34;}, ... {$setOnInsert:{ ... published:new Date() ... }}, ... {upsert:true} ... ) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;matchedCount\u0026#34; : 0, \u0026#34;modifiedCount\u0026#34; : 0, \u0026#34;upsertedId\u0026#34; : ObjectId(\u0026#34;62bd3d9f0a71331919b6297a\u0026#34;) } # 查询结果，有一条是数据 \u0026gt; db.game.find({name:\u0026#34;Nioh 2\u0026#34;}).pretty() { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62bd3d9f0a71331919b6297a\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;Nioh 2\u0026#34;, \u0026#34;published\u0026#34; : ISODate(\u0026#34;2022-06-30T06:07:27.206Z\u0026#34;) } # 继续按setOnInsert更新 \u0026gt; db.game.updateOne( ... {name:\u0026#34;Nioh 2\u0026#34;}, ... {$setOnInsert:{ ... published:new Date() ... }}, ... {upsert:true} ... ) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;matchedCount\u0026#34; : 1, \u0026#34;modifiedCount\u0026#34; : 0 } # 查询结果，时间没变化 \u0026gt; db.game.find({name:\u0026#34;Nioh 2\u0026#34;}).pretty() { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62bd3d9f0a71331919b6297a\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;Nioh 2\u0026#34;, \u0026#34;published\u0026#34; : ISODate(\u0026#34;2022-06-30T06:07:27.206Z\u0026#34;) } # 按set更新 \u0026gt; db.game.updateOne( {name:\u0026#34;Nioh 2\u0026#34;}, {$set:{ published:new Date() }}, {upsert:true} ) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;matchedCount\u0026#34; : 1, \u0026#34;modifiedCount\u0026#34; : 1 } # 查询结果，更新成功 \u0026gt; db.game.find({name:\u0026#34;Nioh 2\u0026#34;}).pretty() { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;62bd3d9f0a71331919b6297a\u0026#34;), \u0026#34;name\u0026#34; : \u0026#34;Nioh 2\u0026#34;, \u0026#34;published\u0026#34; : ISODate(\u0026#34;2022-06-30T06:08:30.014Z\u0026#34;) } save() 辅助函数 save()函数时一个 shell 函数。作用是，在文档不存在时插入文档，在文档存在时更新文档。如果文档中包含_id键，save()函数会执行一次 upsert，否则直接插入数据。用法如下：\ndb.game.save({ _id: 2, name: \u0026#34;warm snow\u0026#34;, price: 38, platform: \u0026#34;PC\u0026#34;, }); 批量更新 批量更新函数updateMany()和单个更新函数updateOne()遵循相同的语法，唯一的区别是，updateMany()将会更新所有匹配的文档，而updateOne()只会更新第一个匹配到的文档。\n数据修改后返回结果 findOneAndUpdate()方法用于返回匹配的结果并更新数据，默认返回更新之前的数据，如果将第三个参数的returnNewDocument属性设置为 true，可以返回更新之后的数据。注意，这个方法可以保证更新操作的原子性，在多线程环境中很实用。方法使用举例：\n// 返回修改前的数据 db.game.findOneAndUpdate( { _id: 2 }, { $set: { platform: [\u0026#34;PC\u0026#34;, \u0026#34;Steam\u0026#34;], }, }, { $sort: { name: -1 } } ); // 返回修改之后的数据 db.game.findOneAndUpdate( { _id: 2 }, { $set: { platform: [\u0026#34;PC\u0026#34;, \u0026#34;Steam\u0026#34;], }, }, { $sort: { name: -1 }, returnNewDocument: true, } ); 运行结果如下：\n\u0026gt; db.game.findOneAndUpdate( ... {_id:2}, ... {$set:{ ... platform:[\u0026#34;PC\u0026#34;,\u0026#34;Steam\u0026#34;] ... }}, ... {$sort:{name:-1}} ... ) { \u0026#34;_id\u0026#34; : 2, \u0026#34;name\u0026#34; : \u0026#34;warm snow\u0026#34;, \u0026#34;price\u0026#34; : 56, \u0026#34;platform\u0026#34; : \u0026#34;PC\u0026#34;, \u0026#34;comments\u0026#34; : [ { \u0026#34;author\u0026#34; : \u0026#34;salta\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;oh,is very googd\u0026#34; } ] } \u0026gt; db.game.findOneAndUpdate( ... {_id:2}, ... {$set:{ ... platform:[\u0026#34;PC\u0026#34;,\u0026#34;Steam\u0026#34;] ... }}, ... { ... $sort:{name:-1}, ... returnNewDocument:true ... } ... ) { \u0026#34;_id\u0026#34; : 2, \u0026#34;name\u0026#34; : \u0026#34;warm snow\u0026#34;, \u0026#34;price\u0026#34; : 56, \u0026#34;platform\u0026#34; : [ \u0026#34;PC\u0026#34;, \u0026#34;Steam\u0026#34; ], \u0026#34;comments\u0026#34; : [ { \u0026#34;author\u0026#34; : \u0026#34;salta\u0026#34;, \u0026#34;content\u0026#34; : \u0026#34;oh,is very googd\u0026#34; } ] } 另外，findOneAndReplace()方法和findOneAndUpdate()方法的用法完全相同。findOneAndDelete()方法用来返回删除之前的文档。\n","permalink":"https://liiqii.github.io/posts/tech/mongo/mongo_edit/","summary":"转自：【Mongo】MongoDB文档的增删改操作 数据增删 插入 document 单条插入 insertOne()方法可以向数据库中插入一条数据，效果如下: \u0026gt; db.game.insertOne({name:\u0026#34;monster hunter: rise\u0026#34;,orderDate:new Date(),price:298}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;insertedId\u0026#34; : ObjectId(\u0026#34;62ba565711721fa1455eb949\u0026#34;) } 此方法会为 document 自动添加一个_id键，_id也可以自己添加，比如这样： \u0026gt; db.game.insertOne({name:\u0026#34;monster hunter: world\u0026#34;,orderDate:new Date(),price:298,_id:1}) { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;insertedId\u0026#34; : 1 } 多条插入 insertMan","title":"【Mongo】MongoDB文档的增删改操作"},{"content":"转自：【Mongo】初步认识MongoDB shell\\\n简介 由于非关系型数据库的数据没有特定的形式要求，与关系型数据库（如：MySQL、Oracle）使用SQL（Structured Query Language）语句查询数据不同，所以非关系型数据库一般都不支持SQL语句。\nMongoDB作为非关系型数据库的代表，MongoDB数据库自带MongoDB shell，类似于JavaScript语法，开发人员可以通过shell与数据库实例进行交互进行数据交互\n运行MongoDB shell 安装MongoDB后，在linux任意位置输入mongo命令，即可进入，shell启动时会自动连接到本地MongoDB数据库，效果如下：\nroot@cbbadf81d558:~# mongo MongoDB shell version v5.0.7 connecting to: mongodb://127.0.0.1:27017/?compressors=disabled\u0026amp;gssapiServiceName=mongodb Implicit session: session { \u0026#34;id\u0026#34; : UUID(\u0026#34;beb55bf8-8533-40f0-a957-e27b28e744eb\u0026#34;) } MongoDB server version: 5.0.7 ================ Warning: the \u0026#34;mongo\u0026#34; shell has been superseded by \u0026#34;mongosh\u0026#34;, which delivers improved usability and compatibility.The \u0026#34;mongo\u0026#34; shell has been deprecated and will be removed in an upcoming release. For installation instructions, see https://docs.mongodb.com/mongodb-shell/install/ ================ --- The server generated these startup warnings when booting: 2022-06-27T05:24:33.178+00:00: Using the XFS filesystem is strongly recommended with the WiredTiger storage engine. See http://dochub.mongodb.org/core/prodnotes-filesystem 2022-06-27T05:24:33.310+00:00: Access control is not enabled for the database. Read and write access to data and configuration is unrestricted 2022-06-27T05:24:33.310+00:00: /sys/kernel/mm/transparent_hugepage/enabled is \u0026#39;always\u0026#39;. We suggest setting it to \u0026#39;never\u0026#39; --- --- Enable MongoDB\u0026#39;s free cloud-based monitoring service, which will then receive and display metrics about your deployment (disk utilization, CPU, operation statistics, etc). The monitoring data will be available on a MongoDB website with a unique URL accessible to you and anyone you share the URL with. MongoDB may use this information to make product improvements and to suggest MongoDB products and deployment options to you. To enable free monitoring, run the following command: db.enableFreeMonitoring() To permanently disable this reminder, run the following command: db.disableFreeMonitoring() --- 也可以通过mongo ip:port[/collectionName]命令指定连接到其他机器上的MongoDB，效果如下：\n# 其中[/collectionName]为可选项，可以不写，默认进入test集合 root@cbbadf81d558:~# mongo 127.0.0.1:27017/MongoStudy MongoDB shell version v5.0.7 connecting to: mongodb://127.0.0.1:27017/MongoStudy 也可以通过参数--nodb指定不连接任何mongo数据库服务器，进入shell后手动连接，效果如下：\nroot@cbbadf81d558:~# mongo --nodb MongoDB shell version v5.0.7 ================ Warning: the \u0026#34;mongo\u0026#34; shell has been superseded by \u0026#34;mongosh\u0026#34;, which delivers improved usability and compatibility.The \u0026#34;mongo\u0026#34; shell has been deprecated and will be removed in an upcoming release. For installation instructions, see https://docs.mongodb.com/mongodb-shell/install/ ================ \u0026gt; 在shell中链接mongo数据库服务的方式为：\n\u0026gt; let conn=new Mongo(\u0026#34;127.0.0.1:27017\u0026#34;) \u0026gt; db=conn.getDB(\u0026#34;MongoStudy\u0026#34;) MongoStudy \u0026gt; db MongoStudy \u0026gt; 使用MongoShell执行JavaScript脚本 可以在shell中传入js脚本，以执行提前定义好的逻辑。注意，在脚本中可以访问mongo提供的全局变量，但是辅助函数（如use db或show collections命令）不能在脚本文件中使用。不过，每个辅助函数都有对应的js等价函数可使用。常见的等价函数包括：\n辅助函数 替代函数 use video db.getSisterDB(“video”) show dbs db.getMongo().getDBs() show collections db.getCollectionNames() 可以通过mongo 脚本名称命令在本地mongo中执行js脚本，效果如下：\nroot@cbbadf81d558:~# mongo ./script.js MongoDB shell version v5.0.7 connecting to: mongodb://127.0.0.1:27017/?compressors=disabled\u0026amp;gssapiServiceName=mongodb Implicit session: session { \u0026#34;id\u0026#34; : UUID(\u0026#34;972ea736-5895-448f-9042-4c8f7b800214\u0026#34;) } MongoDB server version: 5.0.7 hello mongodb root@cbbadf81d558:~# 或通过mongo 127.0.0.1:27017/MongoStudy ./script.js命令，指定其他服务器上的mongo执行js脚本。也可以使用参数--quiet关闭系统打印日志，只显示js脚本的输出内容，效果如下：\nroot@cbbadf81d558:~# mongo ./script.js --quiet hello mongodb root@cbbadf81d558:~# 总结 本文设计到的MongoDB命令有：\nmongo mongo --nodb mongo ip:port/db db mongo js文件名 --quiet mongo ip:port/db js文件名 use db show dbs show collections ","permalink":"https://liiqii.github.io/posts/tech/mongo/mongo_shell/","summary":"转自：【Mongo】初步认识MongoDB shell\\ 简介 由于非关系型数据库的数据没有特定的形式要求，与关系型数据库（如：MySQL、Oracle）使用SQL（Structured Query Language）语句查询数据不同，所以非关系型数据库一般都不支持SQL语句。 MongoDB作为非关系型数据","title":"【Mongo】初步认识MongoDB shell"},{"content":"git 是目前世界上最先进的分布式版本控制系统\n补充说明 git命令 很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。\nLinus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？\n事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！\n你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。\n不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。\n安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。\nLinus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：\nLinus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。\nGit迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。\n历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。\nGit常用命令清单\n语法 git [--version] [--help] [-C \u0026lt;path\u0026gt;] [-c name=value] [--exec-path[=\u0026lt;path\u0026gt;]] [--html-path] [--man-path] [--info-path] [-p | --paginate | --no-pager] [--no-replace-objects] [--bare] [--git-dir=\u0026lt;path\u0026gt;] [--work-tree=\u0026lt;path\u0026gt;] [--namespace=\u0026lt;name\u0026gt;] \u0026lt;command\u0026gt; [\u0026lt;args\u0026gt;] 选项 add 将文件内容添加到索引 bisect 通过二进制查找引入错误的更改 branch 列出，创建或删除分支 checkout 检查分支或路径到工作树 clone 将存储库克隆到新目录中 commit 将更改记录到存储库 diff 显示提交，提交和工作树等之间的更改 fetch 从另一个存储库下载对象和引用 grep 打印匹配图案的行 init 创建一个空的Git仓库或重新初始化一个现有的 log 显示提交日志 merge 加入两个或更多的开发历史 mv 移动或重命名文件，目录或符号链接 pull 从另一个存储库或本地分支获取并合并 push 更新远程引用以及相关对象 rebase 转发端口本地提交到更新的上游头 reset 将当前HEAD复位到指定状态 rm 从工作树和索引中删除文件 show 显示各种类型的对象 status 显示工作树状态 tag 创建，列出，删除或验证使用GPG签名的标签对象 例子 init\ngit init #初始化\nstatus\ngit status #获取状态\nadd\ngit add file # .或*代表全部添加\ngit rm --cached \u0026lt;added_file_to_undo\u0026gt; # 在commit之前撤销git add操作\ngit reset head # 好像比上面git rm --cached更方便\ncommit\ngit commit -m \u0026quot;message\u0026quot; #此处注意乱码\nremote\ngit remote add origin git@github.com:JSLite/test.git #添加源\npush\ngit push -u origin master # push 同时设置默认跟踪分支 git push origin master git push -f origin master # 强制推送文件，缩写 -f（全写--force） clone\ngit clone git://github.com/JSLite/JSLite.js.git\ngit clone git://github.com/JSLite/JSLite.js.git mypro #克隆到自定义文件夹\ngit clone [user@]example.com:path/to/repo.git/ #SSH协议还有另一种写法。\ngit clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。git clone \u0026lt;版本库的网址\u0026gt; \u0026lt;本地目录名\u0026gt;\ngit clone http[s]://example.com/path/to/repo.git/ git clone ssh://example.com/path/to/repo.git/ git clone git://example.com/path/to/repo.git/ git clone /opt/git/project.git git clone file:///opt/git/project.git git clone ftp[s]://example.com/path/to/repo.git/ git clone rsync://example.com/path/to/repo.git/ 配置 首先是配置帐号信息 ssh -T git@github.com 测试。\n修改项目中的个人信息 git help config # 获取帮助信息，查看修改个人信息的参数 git config --global user.name \u0026#34;小弟调调\u0026#34; # 修改全局名字 git config --global user.email \u0026#34;wowohoo@qq.com\u0026#34; # 修改全局邮箱 git config --list # 查看配置的信息 配置自动换行 自动转换坑太大，提交到git是自动将换行符转换为lf\ngit config --global core.autocrlf input 常见使用场景 创建SSH密钥 这个密钥用来跟 github 通信，在本地终端里生成然后上传到 github\nssh-keygen -t rsa -C \u0026#39;wowohoo@qq.com\u0026#39; # 生成密钥 ssh-keygen -t rsa -C \u0026#34;wowohoo@qq.com\u0026#34; -f ~/.ssh/ww_rsa # 指定生成目录文件名字 ssh -T git@github.com # 测试是否成功 多账号ssh配置 1.生成指定名字的密钥\nssh-keygen -t rsa -C \u0026quot;邮箱地址\u0026quot; -f ~/.ssh/jslite_rsa\n会生成 jslite_rsa 和 jslite_rsa.pub 这两个文件\n2.密钥复制到托管平台上\nvim ~/.ssh/jslite_rsa.pub 打开公钥文件 jslite_rsa.pub ，并把内容复制至代码托管平台上\n3.修改config文件\nvim ~/.ssh/config #修改config文件，如果没有创建 config\nHost jslite.github.com HostName github.com User git IdentityFile ~/.ssh/jslite_rsa Host work.github.com HostName github.com # Port 服务器open-ssh端口（默认：22,默认时一般不写此行） # PreferredAuthentications 配置登录时用什么权限认证 # publickey|password publickey|keyboard-interactive等 User git IdentityFile ~/.ssh/work_rsa Host 这里是个别名可以随便命名 HostName 一般是网站如：git@ss.github.com:username/repo.git 填写 github.com User 通常填写git IdentityFile 使用的公钥文件地址 4.测试\nssh -T git@jslite.github.com # `@`后面跟上定义的Host ssh -T work.github.com # 通过别名测试 ssh -i ~/公钥文件地址 Host别名 # 如 ssh -i ~/.ssh/work_rsa work.github.com 5.使用\n# 原来的写法 git clone git@github.com:\u0026lt;jslite的用户名\u0026gt;/learngit.git # 现在的写法 git clone git@jslite.github.com:\u0026lt;jslite的用户名\u0026gt;/learngit.git git clone git@work.github.com:\u0026lt;work的用户名\u0026gt;/learngit.git 5.注意\n如果你修改了id_rsa的名字，你需要将ssh key添加到SSH agent中，如：\nssh-add ~/.ssh/jslite_rsa ssh-add -l # 查看所有的key ssh-add -D # 删除所有的key ssh-add -d ~/.ssh/jslite_rsa # 删除指定的key 免密码登录远程服务器 ssh-keygen -t rsa -P \u0026#39;\u0026#39; -f ~/.ssh/aliyunserver.key ssh-copy-id -i ~/.ssh/aliyunserver.key.pub root@192.168.182.112 # 这里需要输入密码一次 编辑 ~/.ssh/config\nHost aliyun1 HostName 192.168.182.112 User root PreferredAuthentications publickey IdentityFile ~/.ssh/aliyunserver.key 上面配置完了，可以通过命令登录，不需要输入IP地址和密码 ssh aliyun1\nhttps协议下提交代码免密码 git clone https://github.com/username/rep.git 通过上面方式克隆可能需要密码，解决办法：进入当前克隆的项目 vi rep/.git/config 编辑 config, 按照下面方式修改，你就可以提交代码不用输入密码了。\n[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true [remote \u0026#34;origin\u0026#34;] - url = https://github.com/username/rep.git + url = https://用户名:密码@github.com/username/rep.git fetch = +refs/heads/*:refs/remotes/origin/* [branch \u0026#34;master\u0026#34;] remote = origin merge = refs/heads/master 文件推向3个git库 1. 增加3个远程库地址\ngit remote add origin https://github.com/JSLite/JSLite.git git remote set-url --add origin https://gitlab.com/wang/JSLite.js.git git remote set-url --add origin https://oschina.net/wang/JSLite.js.git 2. 删除其中一个 set-url 地址\nusage: git remote set-url [--push] \u0026lt;name\u0026gt; \u0026lt;newurl\u0026gt; [\u0026lt;oldurl\u0026gt;] or: git remote set-url --add \u0026lt;name\u0026gt; \u0026lt;newurl\u0026gt; or: git remote set-url --delete \u0026lt;name\u0026gt; \u0026lt;url\u0026gt; git remote set-url --delete origin https://oschina.net/wang/JSLite.js.git\n3.推送代码\ngit push origin master git push -f origin master # 强制推送 4.拉代码\n只能拉取 origin 里的一个url地址，这个fetch-url\n默认为你添加的到 origin的第一个地址\ngit pull origin master git pull --all # 获取远程所有内容包括tag git pull origin next:master # 取回origin主机的next分支，与本地的master分支合并 git pull origin next # 远程分支是与当前分支合并 # 上面一条命令等同于下面两条命令 git fetch origin git merge origin/next 如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。\n但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。\n$ git pull -p # 等同于下面的命令 $ git fetch --prune origin $ git fetch -p 5.更改pull\n只需要更改config文件里，那三个url的顺序即可，fetch-url会直接对应排行第一的那个utl连接。\n修改远程仓库地址 git remote remove origin # 删除该远程路径 git remote add origin git@jslite.github.com:JSLite/JSLite.git # 添加远程路径 撤销远程记录 git reset --hard HEAD~1 # 撤销一条记录 git push -f origin HEAD:master # 同步到远程仓库 放弃本地的文件修改 git reset --hard FETCH_HEAD # FETCH_HEAD表示上一次成功git pull之后形成的commit点。然后git pull git reset --hard FETCH_HEAD 出现错误\ngit pull You are not currently on a branch, so I cannot use any \u0026#39;branch.\u0026lt;branchname\u0026gt;.merge\u0026#39; in your configuration file. Please specify which remote branch you want to use on the command line and try again (e.g. \u0026#39;git pull \u0026lt;repository\u0026gt; \u0026lt;refspec\u0026gt;\u0026#39;). See git-pull(1) FOR details. 解决方法：\ngit checkout -b temp # 新建+切换到temp分支 git checkout master 最简单放弃本地修改内容 # 如果有的修改以及加入暂存区的话 git reset --hard # 还原所有修改，不会删除新增的文件 git checkout . # 下面命令会删除新增的文件 git clean -xdf 通过存储暂存区stash，在删除暂存区的方法放弃本地修改。\ngit stash \u0026amp;\u0026amp; git stash drop 回滚到某个commit提交 git revert HEAD~1 # 撤销一条记录 会弹出 commit 编辑 git push # 提交回滚 回退到某一个版本 git reset --hard \u0026lt;hash\u0026gt; # 例如 git reset --hard a3hd73r # --hard代表丢弃工作区的修改，让工作区与版本代码一模一样，与之对应， # --soft参数代表保留工作区的修改。 去掉某个commit # 实质是新建了一个与原来完全相反的commit，抵消了原来commit的效果 git revert \u0026lt;commit-hash\u0026gt; 新建一个空分支 # 这种方式新建的分支(gh-pages)是没有 commit 记录的 git checkout --orphan gh-pages # 删除新建的gh-pages分支原本的内容，如果不删除，提交将作为当前分支的第一个commit git rm -rf . # 查看一下状态 有可能上面一条命令，没有删除还没有提交的的文件 git state 合并多个commit # 这个命令，将最近4个commit合并为1个，HEAD代表当前版本。 # 将进入VIM界面，你可以修改提交信息。 git rebase -i HEAD~4 # 可以看到其中分为两个部分，上方未注释的部分是填写要执行的指令， # 而下方注释的部分则是指令的提示说明。指令部分中由前方的命令名称、commit hash 和 commit message 组成 # 当前我们只要知道 pick 和 squash 这两个命令即可。 # --\u0026gt; pick 的意思是要会执行这个 commit # --\u0026gt; squash 的意思是这个 commit 会被合并到前一个commit # 我们将 需要保留的 这个 commit 前方的命令改成 squash 或 s，然后输入:wq以保存并退出 # 这是我们会看到 commit message 的编辑界面 # 其中, 非注释部分就是两次的 commit message, 你要做的就是将这两个修改成新的 commit message。 # # 输入wq保存并推出, 再次输入git log查看 commit 历史信息，你会发现这两个 commit 已经合并了。 # 将修改强制推送到前端 git push -f origin master 修改远程Commit记录 git commit --amend # amend只能修改没有提交到线上的，最后一次commit记录 git rebase -i HEAD~3 # 表示要修改当前版本的倒数第三次状态 # 将要更改的记录行首单词 pick 改为 edit pick 96dc3f9 doc: Update quick-start.md pick f1cce8a test(Transition):Add transition test (#47) pick 6293516 feat(Divider): Add Divider component. # Rebase eeb03a4..6293516 onto eeb03a4 (3 commands) # # Commands: # p, pick = use commit # r, reword = use commit, but edit the commit message # e, edit = use commit, but stop for amending # s, squash = use commit, but meld into previous commit # f, fixup = like \u0026#34;squash\u0026#34;, but discard this commit\u0026#39;s log message # x, exec = run command (the rest of the line) using shell # d, drop = remove commit 保存并退出，会弹出下面提示\n# You can amend the commit now, with # # git commit --amend # # Once you are satisfied with your changes, run # # git rebase --continue # 通过这条命令进入编辑页面更改commit，保存退出 git commit --amend # 保存退出确认修改，继续执行 rebase, git rebase --continue # 如果修改多条记录反复执行上面两条命令直到完成所有修改 # 最后，确保别人没有提交进行push，最好不要加 -f 强制推送 git push -f origin master 添加忽略文件 echo node_modules/ \u0026gt;\u0026gt; .gitignore 利用commit关闭一个issue 这个功能在Github上可以玩儿，Gitlab上特别老的版本不能玩儿哦，那么如何跟随着commit关闭一个issue呢? 在confirm merge的时候可以使用一下命令来关闭相关issue:\nfixes #xxx、 fixed #xxx、 fix #xxx、 closes #xxx、 close #xxx、 closed #xxx、\n同步fork的上游仓库 Github教程同步fork教程，在Github上同步一个分支(fork)\n设置添加多个远程仓库地址。\n在同步之前，需要创建一个远程点指向上游仓库(repo).如果你已经派生了一个原始仓库，可以按照如下方法做。\n$ git remote -v # List the current remotes （列出当前远程仓库） # origin https://github.com/user/repo.git (fetch) # origin https://github.com/user/repo.git (push) $ git remote add upstream https://github.com/otheruser/repo.git # Set a new remote (设置一个新的远程仓库) $ git remote -v # Verify new remote (验证新的原唱仓库) # origin https://github.com/user/repo.git (fetch) # origin https://github.com/user/repo.git (push) # upstream https://github.com/otheruser/repo.git (fetch) # upstream https://github.com/otheruser/repo.git (push) 同步更新仓库内容\n同步上游仓库到你的仓库需要执行两步：首先你需要从远程拉去，之后你需要合并你希望的分支到你的本地副本分支。从上游的存储库中提取分支以及各自的提交内容。 master 将被存储在本地分支机构 upstream/master\ngit fetch upstream # remote: Counting objects: 75, done. # remote: Compressing objects: 100% (53/53), done. # remote: Total 62 (delta 27), reused 44 (delta 9) # Unpacking objects: 100% (62/62), done. # From https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY # * [new branch] master -\u0026gt; upstream/master 检查你的 fork\u0026rsquo;s 本地 master 分支\ngit checkout master # Switched to branch \u0026#39;master\u0026#39; 合并来自 upstream/master 的更改到本地 master 分支上。 这使你的前 fork\u0026rsquo;s master 分支与上游资源库同步，而不会丢失你本地修改。\ngit merge upstream/master # Updating a422352..5fdff0f # Fast-forward # README | 9 ------- # README.md | 7 ++++++ # 2 files changed, 7 insertions(+), 9 deletions(-) # delete mode 100644 README # create mode 100644 README.md 批量修改历史commit中的名字和邮箱 1.克隆仓库\n注意参数，这个不是普通的clone，clone下来的仓库并不能参与开发\ngit clone --bare https://github.com/user/repo.git cd repo.git 2.命令行中运行代码\nOLD_EMAIL原来的邮箱\nCORRECT_NAME更正的名字\nCORRECT_EMAIL更正的邮箱\n将下面代码复制放到命令行中执行\ngit filter-branch -f --env-filter \u0026#39; OLD_EMAIL=\u0026#34;wowohoo@qq.com\u0026#34; CORRECT_NAME=\u0026#34;小弟调调\u0026#34; CORRECT_EMAIL=\u0026#34;更正的邮箱@qq.com\u0026#34; if [ \u0026#34;$GIT_COMMITTER_EMAIL\u0026#34; = \u0026#34;$OLD_EMAIL\u0026#34; ] then export GIT_COMMITTER_NAME=\u0026#34;$CORRECT_NAME\u0026#34; export GIT_COMMITTER_EMAIL=\u0026#34;$CORRECT_EMAIL\u0026#34; fi if [ \u0026#34;$GIT_AUTHOR_EMAIL\u0026#34; = \u0026#34;$OLD_EMAIL\u0026#34; ] then export GIT_AUTHOR_NAME=\u0026#34;$CORRECT_NAME\u0026#34; export GIT_AUTHOR_EMAIL=\u0026#34;$CORRECT_EMAIL\u0026#34; fi \u0026#39; --tag-name-filter cat -- --branches --tags 执行过程\nRewrite 160d4df2689ff6df3820563bfd13b5f1fb9ba832 (479/508) (16 seconds passed, remaining 0 predicted) Ref \u0026#39;refs/heads/dev\u0026#39; was rewritten Ref \u0026#39;refs/heads/master\u0026#39; was rewritten 3.同步到远程仓库\n同步到push远程git仓库\ngit push --force --tags origin \u0026#39;refs/heads/*\u0026#39; 我还遇到了如下面错误，lab默认给master分支加了保护，不允许强制覆盖。Project(项目)-\u0026gt;Setting-\u0026gt;Repository 菜单下面的Protected branches把master的保护去掉就可以了。修改完之后，建议把master的保护再加回来，毕竟强推不是件好事。\nremote: GitLab: You are not allowed to force push code to a protected branch on this project. 当上面的push 不上去的时候，先 git pull 确保最新代码\ngit pull --allow-unrelated-histories # 或者指定分枝 git pull origin master --allow-unrelated-histories 查看某个文件历史 git log --pretty=oneline 文件名 # 列出文件的所有改动历史 git show c178bf49 # 某次的改动的修改记录 git log -p c178bf49 # 某次的改动的修改记录 git blame 文件名 # 显示文件的每一行是在那个版本最后修改。 git whatchanged 文件名 # 显示某个文件的每个版本提交信息：提交日期，提交人员，版本号，提交备注（没有修改细节） 打造自己的git命令 git config --global alias.st status git config --global alias.br branch git config --global alias.co checkout git config --global alias.ci commit 配置好后再输入git命令的时候就不用再输入一大段了，例如我们要查看状态，只需：\ngit st 中文乱码的解决方案 git config --global core.quotepath false 新建仓库 init git init #初始化\nstatus git status #获取状态\nadd git add file # .或*代表全部添加\ngit rm --cached \u0026lt;added_file_to_undo\u0026gt; # 在commit之前撤销git add操作\ngit reset head # 好像比上面git rm --cached更方便\ncommit git commit -m \u0026quot;message\u0026quot; #此处注意乱码\nremote git remote add origin git@github.com:JSLite/test.git #添加源\npush git push -u origin master # push同事设置默认跟踪分支 git push origin master git push -f origin master # 强制推送文件，缩写 -f（全写--force） clone git clone git://github.com/JSLite/JSLite.js.git\ngit clone git://github.com/JSLite/JSLite.js.git mypro #克隆到自定义文件夹\ngit clone [user@]example.com:path/to/repo.git/ #SSH协议还有另一种写法。\ngit clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。git clone \u0026lt;版本库的网址\u0026gt; \u0026lt;本地目录名\u0026gt;\ngit clone http[s]://example.com/path/to/repo.git/ git clone ssh://example.com/path/to/repo.git/ git clone git://example.com/path/to/repo.git/ git clone /opt/git/project.git git clone file:///opt/git/project.git git clone ftp[s]://example.com/path/to/repo.git/ git clone rsync://example.com/path/to/repo.git/ 本地 help git help config # 获取帮助信息 add git add * # 跟踪新文件 git add -u [path] # 添加[指定路径下]已跟踪文件 rm rm *\u0026amp;git rm * # 移除文件 git rm -f * # 移除文件 git rm --cached * # 取消跟踪 git mv file_from file_to # 重命名跟踪文件 git log # 查看提交记录 commit git commit #提交更新 git commit -m \u0026#39;message\u0026#39; #提交说明 git commit -a #跳过使用暂存区域，把所有已经跟踪过的文件暂存起来一并提交 git commit --amend #修改最后一次提交 git commit log #查看所有提交，包括没有push的commit git commit -m \u0026#34;#133\u0026#34; #关联issue 任意位置带上# 符号加上issue号码 git commit -m \u0026#34;fix #133\u0026#34; commit关闭issue git commit -m \u0026#39;概要描述\u0026#39;$\u0026#39;\\n\\n\u0026#39;\u0026#39;1.详细描述\u0026#39;$\u0026#39;\\n\u0026#39;\u0026#39;2.详细描述\u0026#39; #提交简要描述和详细描述 reset git reset HEAD * # 取消已经暂存的文件 git reset --mixed HEAD * # 同上 git reset --soft HEAD * # 重置到指定状态，不会修改索引区和工作树 git reset --hard HEAD * # 重置到指定状态，会修改索引区和工作树 git reset -- files * # 重置index区文件 revert git revert HEAD # 撤销前一次操作 git revert HEAD~ # 撤销前前一次操作 git revert commit # 撤销指定操作 checkout git checkout -- file # 取消对文件的修改（从暂存区——覆盖worktree file） git checkout branch|tag|commit -- file_name # 从仓库取出file覆盖当前分支 git checkout HEAD~1 [文件] # 将会更新 working directory 去匹配某次 commit git checkout -- . # 从暂存区取出文件覆盖工作区 git checkout -b gh-pages 0c304c9 # 这个表示 从当前分支 commit 哈希值为 0c304c9 的节点，分一个新的分支gh-pages出来，并切换到 gh-pages diff git diff file # 查看指定文件的差异 git diff --stat # 查看简单的diff结果 git diff # 比较Worktree和Index之间的差异 git diff --cached # 比较Index和HEAD之间的差异 git diff HEAD # 比较Worktree和HEAD之间的差异 git diff branch # 比较Worktree和branch之间的差异 git diff branch1 branch2 # 比较两次分支之间的差异 git diff commit commit # 比较两次提交之间的差异 git diff master..test # 上面这条命令只显示两个分支间的差异 git diff master...test # 你想找出‘master’,‘test’的共有 父分支和\u0026#39;test\u0026#39;分支之间的差异，你用3个‘.\u0026#39;来取代前面的两个\u0026#39;.\u0026#39; stash git stash # 将工作区现场（已跟踪文件）储藏起来，等以后恢复后继续工作。 git stash list # 查看保存的工作现场 git stash apply # 恢复工作现场 git stash drop # 删除stash内容 git stash pop # 恢复的同时直接删除stash内容 git stash apply stash@{0} # 恢复指定的工作现场，当你保存了不只一份工作现场时。 merge git merge --squash test # 合并压缩，将test上的commit压缩为一条 cherry-pick git cherry-pick commit # 拣选合并，将commit合并到当前分支 git cherry-pick -n commit # 拣选多个提交，合并完后可以继续拣选下一个提交 rebase git rebase master # 将master分之上超前的提交，变基到当前分支 git rebase --onto master 169a6 # 限制回滚范围，rebase当前分支从169a6以后的提交 git rebase --interactive # 交互模式，修改commit git rebase --continue # 处理完冲突继续合并 git rebase --skip # 跳过 git rebase --abort # 取消合并 分支branch 删除 git push origin :branchName # 删除远程分支 git push origin --delete new # 删除远程分支new git branch -d branchName # 删除本地分支，强制删除用-D git branch -d test # 删除本地test分支 git branch -D test # 强制删除本地test分支 git remote prune origin # 远程删除了，本地还能看到远程存在，这条命令删除远程不存在的分支 提交 git push -u origin branchName # 提交分支到远程origin主机中 拉取 git fetch -p #拉取远程分支时，自动清理 远程分支已删除，本地还存在的对应同名分支。\n分支合并 git merge branchName # 合并分支 - 将分支branchName和当前所在分支合并 git merge origin/master # 在本地分支上合并远程分支。 git rebase origin/master # 在本地分支上合并远程分支。 git merge test # 将test分支合并到当前分支 重命名 git branch -m old new #重命名分支\n查看 git branch # 列出本地分支 git branch -r # 列出远端分支 git branch -a # 列出所有分支 git branch -v # 查看各个分支最后一个提交对象的信息 git branch --merge # 查看已经合并到当前分支的分支 git branch --no-merge # 查看为合并到当前分支的分支 git remote show origin # 可以查看remote地址，远程分支 新建 git branch test # 新建test分支 git branch newBrach 3defc69 # 指定哈希3defc69，新建分支名字为newBrach git checkout -b newBrach origin/master # 取回远程主机的更新以后，在它的基础上创建一个新的分支 git checkout -b newBrach 3defc69 # 以哈希值3defc69，新建 newBrach 分支，并切换到该分支 连接 git branch --set-upstream dev origin/dev # 将本地dev分支与远程dev分支之间建立链接 git branch --set-upstream master origin/next # 手动建立追踪关系 分支切换 git checkout test # 切换到test分支 git checkout -b test # 新建+切换到test分支 git checkout -b test dev # 基于dev新建test分支，并切换 远端 git fetch \u0026lt;远程主机名\u0026gt; \u0026lt;分支名\u0026gt; # fetch取回所有分支（branch）的更新 git fetch origin remotebranch[:localbranch] # 从远端拉去分支[到本地指定分支] git merge origin/branch # 合并远端上指定分支 git pull origin remotebranch:localbranch # 拉去远端分支到本地分支 git push origin branch # 将当前分支，推送到远端上指定分支 git push origin localbranch:remotebranch # 推送本地指定分支，到远端上指定分支 git push origin :remotebranch # 删除远端指定分支 git checkout -b [--track] test origin/dev # 基于远端dev分支，新建本地test分支[同时设置跟踪] submodule 克隆项目同时克隆submodule\ngit clone https://github.com/jaywcjlove/handbook.git --depth=1 --recurse-submodules 克隆项目，之后再手动克隆 submodule 子项目\ngit submodule add --force \u0026#39;仓库地址\u0026#39; \u0026#39;路径\u0026#39; # 其中，仓库地址是指子模块仓库地址，路径指将子模块放置在当前工程下的路径。 # 注意：路径不能以 / 结尾（会造成修改不生效）、不能是现有工程已有的目录（不能順利 Clone） git submodule init # 初始化submodule git submodule update # 更新submodule(必须在根目录执行命令) git submodule update --init --recursive # 下载的工程带有submodule 当使用git clone下来的工程中带有submodule时，初始的时候，submodule的内容并不会自动下载下来的，此时，只需执行如下命令：\ngit submodule foreach git pull # submodule 里有其他的 submodule 一次更新 git submodule foreach git pull origin master # submodule更新 git submodule foreach --recursive git submodule init git submodule foreach --recursive git submodule update 删除文件 git rm -rf node_modules/ remote git是一个分布式代码管理工具，所以可以支持多个仓库，在git里，服务器上的仓库在本地称之为remote。个人开发时，多源用的可能不多，但多源其实非常有用。\ngit remote add origin1 git@github.com:yanhaijing/data.js.git git remote # 显示全部源 git remote -v # 显示全部源+详细信息 git remote rename origin1 origin2 # 重命名 git remote rm origin # 删除 git remote show origin # 查看指定源的全部信息 标签tag 当开发到一定阶段时，给程序打标签是非常棒的功能。\ngit tag -a v0.1 -m \u0026#39;my version 1.4\u0026#39; # 新建带注释标签 git push origin --tags # 一次性推送所有分支 git push origin v1.5 # 推送单个tag到orgin源上 git tag -v v1.4.2.1 # 验证标签，验证已经签署的标签 git show v1.5 # 看到对应的 GPG 签 git tag # 列出现有标签 git tag v0gi.1 # 新建标签 git checkout tagname # 切换到标签 git tag -d v0.1 # 删除标签 git push origin :refs/tags/v0.1 # 删除远程标签 git pull --all # 获取远程所有内容包括tag git --git-dir=\u0026#39;\u0026lt;绝对地址\u0026gt;/.git\u0026#39; describe --tags HEAD # 查看本地版本信息 日志log git config format.pretty oneline #显示历史记录时，每个提交的信息只显示一行 git config color.ui true #彩色的 git 输出 git log #查看提交日志，从最近的提交开始显示 git log --reverse #查看提交日志，从最远的提交开始显示 git log --pretty=oneline #单行显示提交日志 git log --graph --pretty=oneline --abbrev-commit git log -num #显示第几条log（倒数） git reflog #查看所有分支的所有操作记录 git log --since=1.day #一天内的提交；你可以给出各种时间格式，比如说具体的某一天（“2008-01-15”），或者是多久以前（“2 years 1 day 3 minutes ago”）。 git log --pretty=\u0026#34;%h - %s\u0026#34; --author=自己的名字 #查看自己的日志 git log -p -2 #展开两次更新显示每次提交的内容差异 git log --stat #要快速浏览其他协作者提交的更新都作了哪些改动 git log --pretty=format:\u0026#34;%h - %an, %ar : %s\u0026#34;#定制要显示的记录格式 git log --pretty=format:\u0026#39;%h : %s\u0026#39; --date-order --graph # 拓扑顺序展示 git log --pretty=format:\u0026#39;%h : %s - %ad\u0026#39; --date=short #日期YYYY-MM-DD显示 git log \u0026lt;last tag\u0026gt; HEAD --pretty=format:%s # 只显示commit git config --global format.pretty \u0026#39;%h : %s - %ad\u0026#39; --date=short #日期YYYY-MM-DD显示 写入全局配置 选项 说明 选项 说明 %H 提交对象（commit）的完整哈希字串 %ad 作者修订日期（可以用 -date= 选项定制格式） %h 提交对象的简短哈希字串 %ar 作者修订日期，按多久以前的方式显示 %T 树对象（tree）的完整哈希字串 %cn 提交者(committer)的名字 %t 树对象的简短哈希字串 %ce 提交者的电子邮件地址 %P 父对象（parent）的完整哈希字串 %cd 提交日期 %p 父对象的简短哈希字串 %cr 提交日期，按多久以前的方式显示 %an 作者（author）的名字 %s 提交说明 %ae 作者的电子邮件地址 - - Pretty Formats\n重写历史 git commit --amend # 改变最近一次提交 git rebase -i HEAD~3 # 修改最近三次的提交说明，或者其中任意一次 git commit --amend # 保存好了，这些指示很明确地告诉了你该干什么 git rebase --continue # 修改提交说明，退出编辑器。 pick f7f3f6d changed my name a bit pick 310154e updated README formatting and added blame pick a5f4a0d added cat-file 改成\npick 310154e updated README formatting and added blame pick f7f3f6d changed my name a bit 删除仓库 cd .. rm -rf repo.git Github官方教程\n其它 git help * # 获取命令的帮助信息 git status # 获取当前的状态，非常有用，因为git会提示接下来的能做的操作 报错问题解决 1. git fatal: protocol error: bad line length character: No s\n解决办法：更换remote地址为 http/https 的\n2. The requested URL returned error: 403 Forbidden while accessing\n解决github push错误的办法：\n#vim 编辑器打开 当前项目中的config文件 vim .git/config #修改 [remote \u0026#34;origin\u0026#34;] url = https://github.com/jaywcjlove/example.git #为下面代码 [remote \u0026#34;origin\u0026#34;] url = https://jaywcjlove@github.com/jaywcjlove/example.git 3. git status 显示中文问题\n在查看状态的时候 git status 如果是中文就显示下面的情况\n\\344\\272\\247\\345\\223\\201\\351\\234\\200\\346\\261\\202 解决这个问题方法是：\ngit config --global core.quotepath false 参考资料 Git官网 Github 15分钟学习Git Git参考手册 Git简明手册 Git Magic Git Community Book 中文版 Pro Git 图解Git git-简明指南 learnGitBranching 在线学习工具 初级教程 廖雪峰的Git教程 蒋鑫老师将带你入github的大门 git详解 oschina教程 How to undo (almost) anything with Git撤销一切，汇总各种回滚撤销的场景，加强学习。 Git 教程 | 菜鸟教程runoob.com Git 本地仓库和裸仓库 沉浸式学 Git Git进阶用法，主要是rebase高级用法 ","permalink":"https://liiqii.github.io/posts/tech/git/git/","summary":"git 是目前世界上最先进的分布式版本控制系统 补充说明 git命令 很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。 Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为","title":"Git 命令详解"},{"content":"创建型模式 创建型模式是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象，增加已有代码的灵活性和可复用性。\n工厂方法模式 Factory Method 问题 假设我们的业务需要一个支付渠道，我们开发了一个Pay方法，其可以用于支付。请看以下示例：\ntype Pay interface { Pay() string } type PayReq struct { OrderId string // 订单号 } func (p *PayReq) Pay() string { // todo fmt.Println(p.OrderId) return \u0026#34;支付成功\u0026#34; } 如上，我们定义了接口Pay，并实现了其方法Pay()。\n如果业务需求变更，需要我们提供多种支付方式，一种叫APay，一种叫BPay，这二种支付方式所需的参数不同，APay只需要订单号OrderId，BPay则需要订单号OrderId和Uid。此时如何修改？\n很容易想到的是在原有的代码基础上修改，比如：\ntype Pay interface { APay() string BPay() string } type PayReq struct { OrderId string // 订单号 Uid int64 } func (p *PayReq) APay() string { // todo fmt.Println(p.OrderId) return \u0026#34;APay支付成功\u0026#34; } func (p *PayReq) BPay() string { // todo fmt.Println(p.OrderId) fmt.Println(p.Uid) return \u0026#34;BPay支付成功\u0026#34; } 我们为Pay接口实现了APay() 和BPay() 方法。虽然暂时实现了业务需求，但却使得结构体PayReq变得冗余了，APay() 并不需要Uid参数。如果之后再增加CPay、DPay、EPay，可想而知，代码会变得越来越难以维护。\n随着后续业务迭代，将不得不编写出复杂的代码。\n解决 让我们想象一个工厂类，这个工厂类需要生产电线和开关等器具，我们可以为工厂类提供一个生产方法，当电线机器调用生产方法时，就产出电线，当开关机器调用生产方法时，就产出开关。\n套用到我们的支付业务来，就是我们不再为接口提供APay方法、BPay方法，而只提供一个Pay方法，并将A支付方式和B支付方式的区别下放到子类。\n请看示例：\npackage factorymethod import \u0026#34;fmt\u0026#34; type Pay interface { Pay(string) int } type PayReq struct { OrderId string } type APayReq struct { PayReq } func (p *APayReq) Pay() string { // todo fmt.Println(p.OrderId) return \u0026#34;APay支付成功\u0026#34; } type BPayReq struct { PayReq Uid int64 } func (p *BPayReq) Pay() string { // todo fmt.Println(p.OrderId) fmt.Println(p.Uid) return \u0026#34;BPay支付成功\u0026#34; } 我们用APay和BPay两个结构体重写了Pay() 方法，如果需要添加一种新的支付方式， 只需要重写新的Pay() 方法即可。\n工厂方法的优点就在于避免了创建者和具体产品之间的紧密耦合，从而使得代码更容易维护。\n测试代码：\npackage factorymethod import ( \u0026#34;testing\u0026#34; ) func TestPay(t *testing.T) { aPay := APayReq{} if aPay.Pay() != \u0026#34;APay支付成功\u0026#34; { t.Fatal(\u0026#34;aPay error\u0026#34;) } bPay := BPayReq{} if bPay.Pay() != \u0026#34;BPay支付成功\u0026#34; { t.Fatal(\u0026#34;bPay error\u0026#34;) } } 抽象工厂模式 Abstract Factory 问题 抽象工厂模式基于工厂方法模式。两者的区别在于：工厂方法模式是创建出一种产品，而抽象工厂模式是创建出一类产品。这二种都属于工厂模式，在设计上是相似的。\n假设，有一个存储工厂，提供redis和mysql两种存储数据的方式。如果使用工厂方法模式，我们就需要一个存储工厂，并提供SaveRedis方法和SaveMysql方法。\n如果此时业务还需要分成存储散文和古诗两种载体，这两种载体都可以进行redis和mysql存储。就可以使用抽象工厂模式，我们需要一个存储工厂作为父工厂，散文工厂和古诗工厂作为子工厂，并提供SaveRedis方法和SaveMysql方法。\n解决 以上文的存储工厂业务为例，用抽象工厂模式的思路来设计代码，就像下面这样：\npackage abstractfactory import \u0026#34;fmt\u0026#34; // SaveArticle 抽象模式工厂接口 type SaveArticle interface { CreateProse() Prose CreateAncientPoetry() AncientPoetry } type SaveRedis struct{} func (*SaveRedis) CreateProse() Prose { return \u0026amp;RedisProse{} } func (*SaveRedis) CreateAncientPoetry() AncientPoetry { return \u0026amp;RedisProse{} } type SaveMysql struct{} func (*SaveMysql) CreateProse() Prose { return \u0026amp;MysqlProse{} } func (*SaveMysql) CreateAncientPoetry() AncientPoetry { return \u0026amp;MysqlProse{} } // Prose 散文 type Prose interface { SaveProse() } // AncientPoetry 古诗 type AncientPoetry interface { SaveAncientPoetry() } type RedisProse struct{} func (*RedisProse) SaveProse() { fmt.Println(\u0026#34;Redis Save Prose\u0026#34;) } func (*RedisProse) SaveAncientPoetry() { fmt.Println(\u0026#34;Redis Save Ancient Poetry\u0026#34;) } type MysqlProse struct{} func (*MysqlProse) SaveProse() { fmt.Println(\u0026#34;Mysql Save Prose\u0026#34;) } func (*MysqlProse) SaveAncientPoetry() { fmt.Println(\u0026#34;Mysql Save Ancient Poetry\u0026#34;) } 我们定义了存储工厂，也就是SaveArticle接口，并实现了CreateProse方法和CreateAncientPoetry方法，这2个方法分别用于创建散文工厂和古诗工厂。\n然后我们又分别为散文工厂和古诗工厂实现了SaveProse方法和SaveAncientPoetry方法，并用Redis结构体和Mysql结构体分别重写了2种存储方法。\n测试代码：\npackage abstractfactory func Save(saveArticle SaveArticle) { saveArticle.CreateProse().SaveProse() saveArticle.CreateAncientPoetry().SaveAncientPoetry() } func ExampleSaveRedis() { var factory SaveArticle factory = \u0026amp;SaveRedis{} Save(factory) // Output: // Redis Save Prose // Redis Save Ancient Poetry } func ExampleSaveMysql() { var factory SaveArticle factory = \u0026amp;SaveMysql{} Save(factory) // Output: // Mysql Save Prose // Mysql Save Ancient Poetry } 建造者模式 Builder 问题 假设业务需要按步骤创建一系列复杂的对象，实现这些步骤的代码加在一起非常繁复，我们可以将这些代码放进一个包含了众多参数的构造函数中，但这个构造函数看起来将会非常杂乱无章，且难以维护。\n假设业务需要建造一个房子对象，需要先打地基、建墙、建屋顶、建花园、放置家具……。我们需要非常多的步骤，并且这些步骤之间是有联系的，即使将各个步骤从一个大的构造函数抽出到其他小函数中，整个程序的层次结构看起来依然很复杂。\n如何解决呢？像这种复杂的有许多步骤的构造函数，就可以用建造者模式来设计。\n建造者模式的用处就在于能够分步骤创建复杂对象。\n解决 在建造者模式中，我们需要清晰的定义每个步骤的代码，然后在一个构造函数中操作这些步骤，我们需要一个主管类，用这个主管类来管理各步骤。这样我们就只需要将所需参数传给一个构造函数，构造函数再将参数传递给对应的主管类，最后由主管类完成后续所有建造任务。\n请看以下代码：\npackage builder import \u0026#34;fmt\u0026#34; // 建造者接口 type Builder interface { Part1() Part2() Part3() } // 管理类 type Director struct { builder Builder } // 构造函数 func NewDirector(builder Builder) *Director { return \u0026amp;Director{ builder: builder, } } // 建造 func (d *Director) Construct() { d.builder.Part1() d.builder.Part2() d.builder.Part3() } type Builder struct {} func (b *Builder) Part1() { fmt.Println(\u0026#34;part1\u0026#34;) } func (b *Builder) Part2() { fmt.Println(\u0026#34;part2\u0026#34;) } func (b *Builder) Part3() { fmt.Println(\u0026#34;part3\u0026#34;) } 如上，我们实现part1、part2、part3这3个步骤，只需要执行构造函数，对应的管理类就可以运行建造方法Construct，完成3个步骤的执行。\n测试代码：\npackage builder func ExampleBuilder() { builder := \u0026amp;Builder{} director := NewDirector(builder) director.Construct() // Output: // part1 // part2 // part3 } 原型模式 Prototype 问题 如果你希望生成一个对象，其与另一个对象完全相同，该如何实现呢？\n如果遍历对象的所有成员，将其依次复制到新对象中，会稍显麻烦，而且有些对象可能会有私有成员变量遗漏。\n原型模式将这个克隆的过程委派给了被克隆的实际对象，被克隆的对象就叫做“原型”。\n解决 如果需要克隆一个新的对象，这个对象完全独立于它的原型，那么就可以使用原型模式。\n原型模式的实现非常简单，请看以下代码：\npackage prototype import \u0026#34;testing\u0026#34; var manager *PrototypeManager type Type1 struct { name string } func (t *Type1) Clone() *Type1 { tc := *t return \u0026amp;tc } func TestClone(t *testing.T) { t1 := \u0026amp;Type1{ name: \u0026#34;type1\u0026#34;, } t2 := t1.Clone() if t1 == t2 { t.Fatal(\u0026#34;error! get clone not working\u0026#34;) } } 我们依靠一个Clone方法实现了原型Type1的克隆。\n原型模式的用处就在于我们可以克隆对象，而无需与原型对象的依赖相耦合。\n单例模式 Singleton 问题 存储着重要对象的全局变量，往往意味着“不安全”，因为你无法保证这个全局变量的值不会在项目的某个引用处被覆盖掉。\n对数据的修改经常导致出乎意料的的结果和难以发现的bug。我在一处更新数据，却没有意识到软件中的另一处期望着完全不同的数据，于是一个功能就失效了，而且找出故障的原因也会非常困难。\n一个较好的解决方案是：将这样的“可变数据”封装起来，写一个查询方法专门用来获取这些值。\n单例模式则更进一步：除了要为“可变数据”提供一个全局访问方法，它还要保证获取到的只有同一个实例。也就是说，如果你打算用一个构造函数创建一个对象，单例模式将保证你得到的不是一个新的对象，而是之前创建过的对象，并且每次它所返回的都只有这同一个对象，也就是单例。这可以保护该对象实例不被篡改。\n解决 单例模式需要一个全局构造函数，这个构造函数会返回一个私有的对象，无论何时调用，它总是返回相同的对象。\n请看以下代码：\npackage singleton import ( \u0026#34;sync\u0026#34; ) // 单例实例 type singleton struct { Value int } type Singleton interface { getValue() int } func (s singleton) getValue() int { return s.Value } var ( instance *singleton once sync.Once ) // 构造方法，用于获取单例模式对象 func GetInstance(v int) Singleton { once.Do(func() { instance = \u0026amp;singleton{Value: v} }) return instance } 单例实例singleton被保存为一个私有的变量，以保证不被其他包的函数引用。\n用构造方法GetInstance可以获得单例实例，函数中使用了sync包的once方法，以保证实例只会在首次调用时被初始化一次，之后再调用构造方法都只会返回同一个实例。\n测试代码：\nfunc TestSingleton(t *testing.T) { ins1 := GetInstance2(1) ins2 := GetInstance2(2) if ins1 != ins2 { t.Fatal(\u0026#34;instance is not equal\u0026#34;) } } 如果你需要更加严格地控制全局变量，这确实很有必要，那么就使用单例模式吧。\n结构型模式 结构型模式将一些对象和类组装成更大的结构体，并同时保持结构的灵活和高效。\n适配器模式 Adapter 问题 适配器模式说白了就是兼容。\n假设一开始我们提供了A对象，后期随着业务迭代，又需要从A对象的基础之上衍生出不同的需求。如果有很多函数已经在线上调用了A对象，此时再对A对象进行修改就比较麻烦，因为需要考虑兼容问题。还有更糟糕的情况， 你可能没有程序库的源代码， 从而无法对其进行修改。\n此时就可以用一个适配器，它就像一个接口转换器，调用方只需要调用这个适配器接口，而不需要关注其背后的实现，由适配器接口封装复杂的过程。\n解决 假设有2个接口，一个将厘米转为米，一个将米转为厘米。我们提供一个适配器接口，使调用方不需要再操心调用哪个接口，直接由适配器做好兼容。\n请看以下代码：\npackage adapter // 提供一个获取米的接口和一个获取厘米的接口 type Cm interface { getLength(float64) float64 } type M interface { getLength(float64) float64 } func NewM() M { return \u0026amp;getLengthM{} } type getLengthM struct{} func (*getLengthM) getLength(cm float64) float64 { return cm / 10 } func NewCm() Cm { return \u0026amp;getLengthCm{} } type getLengthCm struct{} func (a *getLengthCm) getLength(m float64) float64 { return m * 10 } // 适配器 type LengthAdapter interface { getLength(string, float64) float64 } func NewLengthAdapter() LengthAdapter { return \u0026amp;getLengthAdapter{} } type getLengthAdapter struct{} func (*getLengthAdapter) getLength(isType string, into float64) float64 { if isType == \u0026#34;m\u0026#34; { return NewM().getLength(into) } return NewCm().getLength(into) } 上面实现了Cm和M两个接口，并由适配器LengthAdapter做兼容。\n测试代码：\npackage adapter import \u0026#34;testing\u0026#34; func TestAdapter(t *testing.T) { into := 10.5 getLengthAdapter := NewLengthAdapter().getLength(\u0026#34;m\u0026#34;, into) getLengthM := NewM().getLength(into) if getLengthAdapter != getLengthM { t.Fatalf(\u0026#34;getLengthAdapter: %f, getLengthM: %f\u0026#34;, getLengthAdapter, getLengthM) } } 桥接模式Bridge 问题 假设一开始业务需要两种发送信息的渠道，sms和email，我们可以分别实现sms和email两个接口。\n之后随着业务迭代，又产生了新的需求，需要提供两种系统发送方式，systemA和systemB，并且这两种系统发送方式都应该支持sms和email渠道。\n此时至少需要提供4种方法：systemA to sms，systemA to email，systemB to sms，systemB to email。\n如果再分别增加一种渠道和一种系统发送方式，就需要提供9种方法。这将导致代码的复杂程度指数增长。\n解决 其实之前我们是在用继承的想法来看问题，桥接模式则希望将继承关系转变为关联关系，使两个类独立存在。\n详细说一下：\n桥接模式需要将抽象和实现区分开； 桥接模式需要将“渠道”和“系统发送方式”这两种类别区分开； 最后在“系统发送方式”的类里调用“渠道”的抽象接口，使他们从继承关系转变为关联关系。 用一句话总结桥接模式的理念，就是：“将抽象与实现解耦，将不同类别的继承关系改为关联关系。 ”\n请看以下代码：\npackage bridge import \u0026#34;fmt\u0026#34; // 两种发送消息的方法 type SendMessage interface { send(text, to string) } type sms struct{} func NewSms() SendMessage { return \u0026amp;sms{} } func (*sms) send(text, to string) { fmt.Println(fmt.Sprintf(\u0026#34;send %s to %s sms\u0026#34;, text, to)) } type email struct{} func NewEmail() SendMessage { return \u0026amp;email{} } func (*email) send(text, to string) { fmt.Println(fmt.Sprintf(\u0026#34;send %s to %s email\u0026#34;, text, to)) } // 两种发送系统 type systemA struct { method SendMessage } func NewSystemA(method SendMessage) *systemA { return \u0026amp;systemA{ method: method, } } func (m *systemA) SendMessage(text, to string) { m.method.send(fmt.Sprintf(\u0026#34;[System A] %s\u0026#34;, text), to) } type systemB struct { method SendMessage } func NewSystemB(method SendMessage) *systemB { return \u0026amp;systemB{ method: method, } } func (m *systemB) SendMessage(text, to string) { m.method.send(fmt.Sprintf(\u0026#34;[System B] %s\u0026#34;, text), to) } 可以看到我们先定义了sms和email二种实现，以及接口SendMessage。接着我们实现了systemA和systemB，并调用了抽象接口SendMessage。\n测试代码：\npackage bridge func ExampleSystemA() { NewSystemA(NewSms()).SendMessage(\u0026#34;hi\u0026#34;, \u0026#34;baby\u0026#34;) NewSystemA(NewEmail()).SendMessage(\u0026#34;hi\u0026#34;, \u0026#34;baby\u0026#34;) // Output: // send [System A] hi to baby sms // send [System A] hi to baby email } func ExampleSystemB() { NewSystemB(NewSms()).SendMessage(\u0026#34;hi\u0026#34;, \u0026#34;baby\u0026#34;) NewSystemB(NewEmail()).SendMessage(\u0026#34;hi\u0026#34;, \u0026#34;baby\u0026#34;) // Output: // send [System B] hi to baby sms // send [System B] hi to baby email } 如果你想要拆分或重组一个具有多重功能的复杂类，可以使用桥接模式。\n对象树模式Object Tree 问题 在项目中，如果我们需要用到树状结构，就可以使用对象树模式。换言之，如果项目的核心模型不能以树状结构表示，则没必要使用对象树模式。\n对象树模式的用处就在于可以利用多态和递归机制更方便地使用复杂树结构。\n解决 请看以下代码：\npackage objecttree import \u0026#34;fmt\u0026#34; type Component interface { Parent() Component SetParent(Component) Name() string SetName(string) AddChild(Component) Search(string) } const ( LeafNode = iota CompositeNode ) func NewComponent(kind int, name string) Component { var c Component switch kind { case LeafNode: c = NewLeaf() case CompositeNode: c = NewComposite() } c.SetName(name) return c } type component struct { parent Component name string } func (c *component) Parent() Component { return c.parent } func (c *component) SetParent(parent Component) { c.parent = parent } func (c *component) Name() string { return c.name } func (c *component) SetName(name string) { c.name = name } func (c *component) AddChild(Component) {} type Leaf struct { component } func NewLeaf() *Leaf { return \u0026amp;Leaf{} } func (c *Leaf) Search(pre string) { fmt.Printf(\u0026#34;leaf %s-%s\\n\u0026#34;, pre, c.Name()) } type Composite struct { component childs []Component } func NewComposite() *Composite { return \u0026amp;Composite{ childs: make([]Component, 0), } } func (c *Composite) AddChild(child Component) { child.SetParent(c) c.childs = append(c.childs, child) } func (c *Composite) Search(pre string) { fmt.Printf(\u0026#34;%s+%s\\n\u0026#34;, pre, c.Name()) pre += \u0026#34; \u0026#34; for _, comp := range c.childs { comp.Search(pre) } } 在Search方法中使用递归打印出了整棵树结构。\n测试代码：\npackage objecttree func ExampleComposite() { root := NewComponent(CompositeNode, \u0026#34;root\u0026#34;) c1 := NewComponent(CompositeNode, \u0026#34;c1\u0026#34;) c2 := NewComponent(CompositeNode, \u0026#34;c2\u0026#34;) c3 := NewComponent(CompositeNode, \u0026#34;c3\u0026#34;) l1 := NewComponent(LeafNode, \u0026#34;l1\u0026#34;) l2 := NewComponent(LeafNode, \u0026#34;l2\u0026#34;) l3 := NewComponent(LeafNode, \u0026#34;l3\u0026#34;) root.AddChild(c1) root.AddChild(c2) c1.AddChild(c3) c1.AddChild(l1) c2.AddChild(l2) c2.AddChild(l3) root.Search(\u0026#34;\u0026#34;) // Output: // +root // +c1 // +c3 //leaf -l1 // +c2 //leaf -l2 //leaf -l3 } 装饰模式Decorator 问题 有时候我们需要在一个类的基础上扩展另一个类，例如，一个披萨类，你可以在披萨类的基础上增加番茄披萨类和芝士披萨类。此时就可以使用装饰模式，简单来说，装饰模式就是将对象封装到另一个对象中，用以为原对象绑定新的行为。\n如果你希望在无需修改代码的情况下使用对象，并且希望为对象新增额外的行为，就可以考虑使用装饰模式。\n解决 用上文的披萨类做例子。请看以下代码：\npackage decorator type pizza interface { getPrice() int } type base struct {} func (p *base) getPrice() int { return 15 } type tomatoTopping struct { pizza pizza } func (c *tomatoTopping) getPrice() int { pizzaPrice := c.pizza.getPrice() return pizzaPrice + 10 } type cheeseTopping struct { pizza pizza } func (c *cheeseTopping) getPrice() int { pizzaPrice := c.pizza.getPrice() return pizzaPrice + 20 } 首先我们定义了pizza接口，创建了base类，实现了方法getPrice。然后再用装饰模式的理念，实现了tomatoTopping和cheeseTopping类，他们都封装了pizza接口的getPrice方法。\n测试代码：\npackage decorator import \u0026#34;fmt\u0026#34; func ExampleDecorator() { pizza := \u0026amp;base{} //Add cheese topping pizzaWithCheese := \u0026amp;cheeseTopping{ pizza: pizza, } //Add tomato topping pizzaWithCheeseAndTomato := \u0026amp;tomatoTopping{ pizza: pizzaWithCheese, } fmt.Printf(\u0026#34;price is %d\\n\u0026#34;, pizzaWithCheeseAndTomato.getPrice()) // Output: // price is 45 } 外观模式Facade 问题 如果你需要初始化大量复杂的库或框架，就需要管理其依赖关系并且按正确的顺序执行。此时就可以用一个外观类来统一处理这些依赖关系，以对其进行整合。\n解决 外观模式和建造者模式很相似。两者的区别在于，外观模式是一种结构型模式，她的目的是将对象组合起来，而不是像建造者模式那样创建出不同的产品。\n请看以下代码：\npackage facade import \u0026#34;fmt\u0026#34; // 初始化APIA和APIB type APIA interface { TestA() string } func NewAPIA() APIA { return \u0026amp;apiRunA{} } type apiRunA struct{} func (*apiRunA) TestA() string { return \u0026#34;A api running\u0026#34; } type APIB interface { TestB() string } func NewAPIB() APIB { return \u0026amp;apiRunB{} } type apiRunB struct{} func (*apiRunB) TestB() string { return \u0026#34;B api running\u0026#34; } // 外观类 type API interface { Test() string } func NewAPI() API { return \u0026amp;apiRun{ a: NewAPIA(), b: NewAPIB(), } } type apiRun struct { a APIA b APIB } func (a *apiRun) Test() string { aRet := a.a.TestA() bRet := a.b.TestB() return fmt.Sprintf(\u0026#34;%s\\n%s\u0026#34;, aRet, bRet) } 假设要初始化APIA和APIB，我们就可以通过一个外观类API进行处理，在外观类接口Test方法中分别执行类TestA方法和TestB方法。\n测试代码：\npackage facade import \u0026#34;testing\u0026#34; var expect = \u0026#34;A api running\\nB api running\u0026#34; // TestFacadeAPI ... func TestFacadeAPI(t *testing.T) { api := NewAPI() ret := api.Test() if ret != expect { t.Fatalf(\u0026#34;expect %s, return %s\u0026#34;, expect, ret) } } 享元模式 Flyweight 问题 在一些情况下，程序没有足够的内存容量支持存储大量对象，或者大量的对象存储着重复的状态，此时就会造成内存资源的浪费。\n享元模式提出了这样的解决方案：如果多个对象中相同的状态可以共用，就能在在有限的内存容量中载入更多对象。\n解决 如上所说，享元模式希望抽取出能在多个对象间共享的重复状态。\n我们可以使用map结构来实现这一设想，假设需要存储一些代表颜色的对象，使用享元模式可以这样做，请看以下代码：\npackage flyweight import \u0026#34;fmt\u0026#34; // 享元工厂 type ColorFlyweightFactory struct { maps map[string]*ColorFlyweight } var colorFactory *ColorFlyweightFactory func GetColorFlyweightFactory() *ColorFlyweightFactory { if colorFactory == nil { colorFactory = \u0026amp;ColorFlyweightFactory{ maps: make(map[string]*ColorFlyweight), } } return colorFactory } func (f *ColorFlyweightFactory) Get(filename string) *ColorFlyweight { color := f.maps[filename] if color == nil { color = NewColorFlyweight(filename) f.maps[filename] = color } return color } type ColorFlyweight struct { data string } // 存储color对象 func NewColorFlyweight(filename string) *ColorFlyweight { // Load color file data := fmt.Sprintf(\u0026#34;color data %s\u0026#34;, filename) return \u0026amp;ColorFlyweight{ data: data, } } type ColorViewer struct { *ColorFlyweight } func NewColorViewer(name string) *ColorViewer { color := GetColorFlyweightFactory().Get(name) return \u0026amp;ColorViewer{ ColorFlyweight: color, } } 我们定义了一个享元工厂，使用map存储相同对象（key）的状态（value）。这个享元工厂可以使我们更方便和安全的访问各种享元，保证其状态不被修改。\n我们定义了NewColorViewer方法，它会调用享元工厂的Get方法存储对象，而在享元工厂的实现中可以看到，相同状态的对象只会占用一次。\n测试代码：\npackage flyweight import \u0026#34;testing\u0026#34; func TestFlyweight(t *testing.T) { viewer1 := NewColorViewer(\u0026#34;blue\u0026#34;) viewer2 := NewColorViewer(\u0026#34;blue\u0026#34;) if viewer1.ColorFlyweight != viewer2.ColorFlyweight { t.Fail() } } 当程序需要存储大量对象且没有足够的内存容量时，可以考虑使用享元模式。\n代理模式Proxy 问题 如果你需要在访问一个对象时，有一个像“代理”一样的角色，她可以在访问对象之前为你进行缓存检查、权限判断等访问控制，在访问对象之后为你进行结果缓存、日志记录等结果处理，那么就可以考虑使用代理模式。\n回忆一下一些web框架的router模块，当客户端访问一个接口时，在最终执行对应的接口之前，router模块会执行一些事前操作，进行权限判断等操作，在执行之后还会记录日志，这就是典型的代理模式。\n解决 代理模式需要一个代理类，其包含执行真实对象所需的成员变量，并由代理类管理整个生命周期。\n请看以下代码：\npackage proxy import \u0026#34;fmt\u0026#34; type Subject interface { Proxy() string } // 代理 type Proxy struct { real RealSubject } func (p Proxy) Proxy() string { var res string // 在调用真实对象之前，检查缓存，判断权限，等等 p.real.Pre() // 调用真实对象 p.real.Real() // 调用之后的操作，如缓存结果，对结果进行处理，等等 p.real.After() return res } // 真实对象 type RealSubject struct{} func (RealSubject) Real() { fmt.Print(\u0026#34;real\u0026#34;) } func (RealSubject) Pre() { fmt.Print(\u0026#34;pre:\u0026#34;) } func (RealSubject) After() { fmt.Print(\u0026#34;:after\u0026#34;) } 我们定义了代理类Proxy，执行Proxy之后，在调用真实对象Real之前，我们会先调用事前对象Pre，并在执行真实对象Real之后，调用事后对象After。\n测试代码：\npackage proxy func ExampleProxy() { var sub Subject sub = \u0026amp;Proxy{} sub.Proxy() // Output: // pre:real:after } 行为型模式 行为型模式处理对象和类之间的通信，并使其保持高效的沟通和委派。\n责任链模式Chain of Responsibility 问题 假设我们要让程序按照指定的步骤执行，并且这个步骤的顺序不是固定的，而是可以根据不同需求改变的，每个步骤都会对请求进行一些处理，并将结果传递给下一个步骤的处理者，就像一条流水线一样，我们该如何实现？\n当遇到这种必须按顺序执行多个处理者，并且处理者的顺序可以改变的需求，我们可以考虑使用责任链模式。\n解决 责任链模式使用了类似链表的结构。请看以下代码：\npackage chain import \u0026#34;fmt\u0026#34; type department interface { execute(*Do) setNext(department) } type aPart struct { next department } func (r *aPart) execute(p *Do) { if p.aPartDone { fmt.Println(\u0026#34;aPart done\u0026#34;) r.next.execute(p) return } fmt.Println(\u0026#34;aPart\u0026#34;) p.aPartDone = true r.next.execute(p) } func (r *aPart) setNext(next department) { r.next = next } type bPart struct { next department } func (d *bPart) execute(p *Do) { if p.bPartDone { fmt.Println(\u0026#34;bPart done\u0026#34;) d.next.execute(p) return } fmt.Println(\u0026#34;bPart\u0026#34;) p.bPartDone = true d.next.execute(p) } func (d *bPart) setNext(next department) { d.next = next } type endPart struct { next department } func (c *endPart) execute(p *Do) { if p.endPartDone { fmt.Println(\u0026#34;endPart Done\u0026#34;) } fmt.Println(\u0026#34;endPart\u0026#34;) } func (c *endPart) setNext(next department) { c.next = next } type Do struct { aPartDone bool bPartDone bool endPartDone bool } 我们实现了方法execute和setNext，并定义了aPart、bPart、endPart这3个处理者，每个处理者都可以通过execute方法执行其对应的业务代码，并可以通过setNext方法决定下一个处理者是谁。除了endPart是最终的处理者之外，在它之前的处理者aPart、bPart的顺序都可以任意调整。\n请看以下测试代码：\nfunc ExampleChain() { startPart := \u0026amp;endPart{} aPart := \u0026amp;aPart{} aPart.setNext(startPart) bPart := \u0026amp;bPart{} bPart.setNext(aPart) do := \u0026amp;Do{} bPart.execute(do) // Output: // bPart // aPart // endPart } 我们也可以调整处理者的执行顺序：\nfunc ExampleChain2() { startPart := \u0026amp;endPart{} bPart := \u0026amp;bPart{} bPart.setNext(startPart) aPart := \u0026amp;aPart{} aPart.setNext(bPart) do := \u0026amp;Do{} aPart.execute(do) // Output: // aPart // bPart // endPart } 命令模式Command 问题 假设你实现了开启和关闭电视机的功能，随着业务迭代，还需要实现开启和关闭冰箱的功能，开启和关闭电灯的功能，开启和关闭微波炉的功能……这些功能都基于你的基类，开启和关闭。如果你之后对基类进行修改，很可能会影响到其他功能，这使项目变得不稳定了。\n一个优秀的设计往往会关注于软件的分层与解耦，命令模式试图做到这样的结果：让命令和对应功能解耦，并能根据不同的请求将其方法参数化。\n解决 还是用开启和关闭家用电器的例子来举例吧。请看以下代码：\npackage command import \u0026#34;fmt\u0026#34; // 请求者 type button struct { command command } func (b *button) press() { b.command.execute() } // 具体命令接口 type command interface { execute() } type onCommand struct { device device } func (c *onCommand) execute() { c.device.on() } type offCommand struct { device device } func (c *offCommand) execute() { c.device.off() } // 接收者 type device interface { on() off() } type tv struct{} func (t *tv) on() { fmt.Println(\u0026#34;Turning tv on\u0026#34;) } func (t *tv) off() { fmt.Println(\u0026#34;Turning tv off\u0026#34;) } type airConditioner struct{} func (t *airConditioner) on() { fmt.Println(\u0026#34;Turning air conditioner on\u0026#34;) } func (t *airConditioner) off() { fmt.Println(\u0026#34;Turning air conditioner off\u0026#34;) } 我们分别实现了请求者button，命令接口command，接收者device。请求者button就像是那个可以执行开启或关闭的遥控器，命令接口command则是一个中间层，它使我们的请求者和接收者解藕。\n测试代码：\npackage command func ExampleCommand() { Tv() AirConditioner() // Output: // Turning tv on // Turning tv off // Turning air conditioner on // Turning air conditioner off } func Tv() { tv := \u0026amp;tv{} onTvCommand := \u0026amp;onCommand{ device: tv, } offTvCommand := \u0026amp;offCommand{ device: tv, } onTvButton := \u0026amp;button{ command: onTvCommand, } onTvButton.press() offTvButton := \u0026amp;button{ command: offTvCommand, } offTvButton.press() } func AirConditioner() { airConditioner := \u0026amp;airConditioner{} onAirConditionerCommand := \u0026amp;onCommand{ device: airConditioner, } offAirConditionerCommand := \u0026amp;offCommand{ device: airConditioner, } onAirConditionerButton := \u0026amp;button{ command: onAirConditionerCommand, } onAirConditionerButton.press() offAirConditionerButton := \u0026amp;button{ command: offAirConditionerCommand, } offAirConditionerButton.press() } 迭代器模式Iterator 问题 迭代器模式用于遍历集合中的元素，无论集合的数据结构是怎样的。\n解决 请看以下代码：\npackage iterator // 集合接口 type collection interface { createIterator() iterator } // 具体的集合 type part struct { title string number int } type partCollection struct { part parts []*part } func (u *partCollection) createIterator() iterator { return \u0026amp;partIterator{ parts: u.parts, } } // 迭代器 type iterator interface { hasNext() bool getNext() *part } // 具体的迭代器 type partIterator struct { index int parts []*part } func (u *partIterator) hasNext() bool { if u.index \u0026lt; len(u.parts) { return true } return false } func (u *partIterator) getNext() *part { if u.hasNext() { part := u.parts[u.index] u.index++ return part } return nil } 测试代码：\nfunc ExampleIterator() { part1 := \u0026amp;part{ title: \u0026#34;part1\u0026#34;, number: 10, } part2 := \u0026amp;part{ title: \u0026#34;part2\u0026#34;, number: 20, } part3 := \u0026amp;part{ title: \u0026#34;part3\u0026#34;, number: 30, } partCollection := \u0026amp;partCollection{ parts: []*part{part1, part2, part3}, } iterator := partCollection.createIterator() for iterator.hasNext() { part := iterator.getNext() fmt.Println(part) } // Output: // \u0026amp;{part1 10} // \u0026amp;{part2 20} // \u0026amp;{part3 30} } 中介者模式Mediator 问题 中介者模式试图解决网状关系的复杂关联，降低对象间的耦合度。\n举个例子，假设一个十字路口上的车都是对象，它们会执行不同的操作，前往不同的目的地，那么在十字路口指挥的交警就是“中介者”。\n各个对象通过执行中介者接口，再由中介者维护对象之间的联系。这能使对象变得更独立，比较适合用在一些对象是网状关系的案例上。\n解决 假设有p1，p2，p3这3个发送者，p1 发送的消息p2能收到，p2 发送的消息p1能收到，p3 发送的消息则p1和p2能收到，如何实现呢？像这种情况就很适合用中介者模式实现。\n请看以下代码：\npackage mediator import ( \u0026#34;fmt\u0026#34; ) type p1 struct{} func (p *p1) getMessage(data string) { fmt.Println(\u0026#34;p1 get message: \u0026#34; + data) } type p2 struct{} func (p *p2) getMessage(data string) { fmt.Println(\u0026#34;p2 get message: \u0026#34; + data) } type p3 struct{} func (p *p3) getMessage(data string) { fmt.Println(\u0026#34;p3 get message: \u0026#34; + data) } type Message struct { p1 *p1 p2 *p2 p3 *p3 } func (m *Message) sendMessage(i interface{}, data string) { switch i.(type) { case *p1: m.p2.getMessage(data) case *p2: m.p1.getMessage(data) case *p3: m.p1.getMessage(data) m.p2.getMessage(data) } } 我们定义了p1，p2，p3这3个对象，然后实现了中介者sendMessage。\n测试代码：\npackage mediator func ExampleMediator() { message := \u0026amp;Message{} p1 := \u0026amp;p1{} p2 := \u0026amp;p2{} p3 := \u0026amp;p3{} message.sendMessage(p1, \u0026#34;hi! my name is p1\u0026#34;) message.sendMessage(p2, \u0026#34;hi! my name is p2\u0026#34;) message.sendMessage(p3, \u0026#34;hi! my name is p3\u0026#34;) // Output: // p2 get message: hi! my name is p1 // p1 get message: hi! my name is p2 // p1 get message: hi! my name is p3 // p2 get message: hi! my name is p3 } 备忘录模式Memento 问题 常用的文字编辑器都支持保存和恢复一段文字的操作，如果我们想要在程序中实现保存和恢复的功能该怎么做呢？\n我们需要提供保存和恢复的功能，当保存功能被调用时，就会生成当前对象的快照，在恢复功能被调用时，就会用之前保存的快照覆盖当前的快照。这可以使用备忘录模式来做。\n解决 请看以下代码：\npackage memento import \u0026#34;fmt\u0026#34; type Memento interface{} type Text struct { content string } type textMemento struct { content string } func (t *Text) Write(content string) { t.content = content } func (t *Text) Save() Memento { return \u0026amp;textMemento{ content: t.content, } } func (t *Text) Load(m Memento) { tm := m.(*textMemento) t.content = tm.content } func (t *Text) Show() { fmt.Println(\u0026#34;content:\u0026#34;, t.content) } 我们定义了textMemento结构体用于保存当前快照，并在Load方法中将快照覆盖到当前内容。\n测试代码：\npackage memento func ExampleText() { text := \u0026amp;Text{ content: \u0026#34;how are you\u0026#34;, } text.Show() progress := text.Save() text.Write(\u0026#34;fine think you and you\u0026#34;) text.Show() text.Load(progress) text.Show() // Output: // content: how are you // content: fine think you and you // content: how are you } 观察者模式Observer 问题 如果你需要在一个对象的状态被改变时，其他对象能作为其“观察者”而被通知，就可以使用观察者模式。\n我们将自身的状态改变就会通知给其他对象的对象称为“发布者”，关注发布者状态变化的对象则称为“订阅者”。\n解决 请看以下代码：\npackage observer import \u0026#34;fmt\u0026#34; // 发布者 type Subject struct { observers []Observer content string } func NewSubject() *Subject { return \u0026amp;Subject{ observers: make([]Observer, 0), } } // 添加订阅者 func (s *Subject) AddObserver(o Observer) { s.observers = append(s.observers, o) } // 改变发布者的状态 func (s *Subject) UpdateContext(content string) { s.content = content s.notify() } // 通知订阅者接口 type Observer interface { Do(*Subject) } func (s *Subject) notify() { for _, o := range s.observers { o.Do(s) } } // 订阅者 type Reader struct { name string } func NewReader(name string) *Reader { return \u0026amp;Reader{ name: name, } } func (r *Reader) Do(s *Subject) { fmt.Println(r.name + \u0026#34; get \u0026#34; + s.content) } 很简单，我们只要实现一个通知notify方法，在发布者的状态改变时执行即可。\n测试代码：\npackage observer func ExampleObserver() { subject := NewSubject() boy := NewReader(\u0026#34;小明\u0026#34;) girl := NewReader(\u0026#34;小美\u0026#34;) subject.AddObserver(boy) subject.AddObserver(girl) subject.UpdateContext(\u0026#34;hi~\u0026#34;) // Output: // 小明 get hi~ // 小美 get hi~ } 状态模式 State 问题 如果一个对象的实现方法会根据自身的状态而改变，就可以使用状态模式。\n举个例子：假设有一个开门的方法，门的状态在一开始是“关闭”，你可以执行open方法和close方法，当你执行了open方法，门的状态就变成了“开启”，再执行open方法就不会执行开门的功能，而是返回“门已开启”，如果执行close方法，门的状态就变成了“关闭”，再执行close方法就不会执行关门的功能，而是返回“门已关闭”。这是一个简单的例子，我们将为每个状态提供不同的实现方法，将这些方法组织起来很麻烦，如果状态也越来越多呢？无疑，这将会使代码变得臃肿。\n解决 如果我们需要为一个门对象提供3种状态下的open和close方法：\n“开启”状态下，open方法返回“门已开启”，close方法返回“关闭成功”。 “关闭”状态下，open方法返回“开启成功”，close方法返回“门已关闭”。 “损坏”状态下，open方法返回“门已损坏，无法开启”，close方法返回“门已损坏，无法关闭”。 请看以下代码：\npackage state import \u0026#34;fmt\u0026#34; // 不同状态需要实现的接口 type state interface { open(*door) close(*door) } // 门对象 type door struct { opened state closed state damaged state currentState state // 当前状态 } func (d *door) open() { d.currentState.open(d) } func (d *door) close() { d.currentState.close(d) } func (d *door) setState(s state) { d.currentState = s } // 开启状态 type opened struct{} func (o *opened) open(d *door) { fmt.Println(\u0026#34;门已开启\u0026#34;) } func (o *opened) close(d *door) { fmt.Println(\u0026#34;关闭成功\u0026#34;) } // 关闭状态 type closed struct{} func (c *closed) open(d *door) { fmt.Println(\u0026#34;开启成功\u0026#34;) } func (c *closed) close(d *door) { fmt.Println(\u0026#34;门已关闭\u0026#34;) } // 损坏状态 type damaged struct{} func (a *damaged) open(d *door) { fmt.Println(\u0026#34;门已损坏，无法开启\u0026#34;) } func (a *damaged) close(d *door) { fmt.Println(\u0026#34;门已损坏，无法关闭\u0026#34;) } 我们的门对象door实现了open和close方法，在方法中，只需要调用当前状态currentState的open和close方法即可。\n测试代码：\npackage state func ExampleState() { door := \u0026amp;door{} // 开启状态 opened := \u0026amp;opened{} door.setState(opened) door.open() door.close() // 关闭状态 closed := \u0026amp;closed{} door.setState(closed) door.open() door.close() // 损坏状态 damaged := \u0026amp;damaged{} door.setState(damaged) door.open() door.close() // Output: // 门已开启 // 关闭成功 // 开启成功 // 门已关闭 // 门已损坏，无法开启 // 门已损坏，无法关闭 } 策略模式Strategy 问题 假设需要实现一组出行的功能，出现的方案可以选择步行、骑行、开车，最简单的做法就是分别实现这3种方法供客户端调用。但这样做就使对象与其代码实现变得耦合了，客户端需要决定出行方式，然后决定调用步行出行、骑行出行、开车出行等方法，这不符合开闭原则。\n而策略模式的区别在于，它会将这些出行方案抽取到一组被称为策略的类中，客户端还是调用同一个出行对象，不需要关注实现细节，只需要在参数中指定所需的策略即可。\n解决 请看以下代码：\npackage strategy import \u0026#34;fmt\u0026#34; type Travel struct { name string strategy Strategy } func NewTravel(name string, strategy Strategy) *Travel { return \u0026amp;Travel{ name: name, strategy: strategy, } } func (p *Travel) traffic() { p.strategy.traffic(p) } type Strategy interface { traffic(*Travel) } type Walk struct{} func (w *Walk) traffic(t *Travel) { fmt.Println(t.name + \u0026#34; walk\u0026#34;) } type Ride struct{} func (w *Ride) traffic(t *Travel) { fmt.Println(t.name + \u0026#34; ride\u0026#34;) } type Drive struct{} func (w *Drive) traffic(t *Travel) { fmt.Println(t.name + \u0026#34; drive\u0026#34;) } 我们定义了strategy一组策略接口，为其实现了Walk、Ride、Drive算法。客户端只需要执行traffic方法即可，无需关注实现细节。\n测试代码：\npackage strategy func ExampleTravel() { walk := \u0026amp;Walk{} Travel1 := NewTravel(\u0026#34;小明\u0026#34;, walk) Travel1.traffic() ride := \u0026amp;Ride{} Travel2 := NewTravel(\u0026#34;小美\u0026#34;, ride) Travel2.traffic() drive := \u0026amp;Drive{} Travel3 := NewTravel(\u0026#34;小刚\u0026#34;, drive) Travel3.traffic() // Output: // 小明 walk // 小美 ride // 小刚 drive } 模板方法模式Template Method 问题 模板方法模式就是将算法分解为一系列步骤，然后在一个模版方法中依次调用这些步骤。这样客户端就不需要了解各个步骤的实现细节，只需要调用模版即可。\n解决 一个非常简单的例子，请看以下代码：\npackage templatemethod import \u0026#34;fmt\u0026#34; type PrintTemplate interface { Print(name string) } type template struct { isTemplate PrintTemplate name string } func (t *template) Print() { t.isTemplate.Print(t.name) } type A struct{} func (a *A) Print(name string) { fmt.Println(\u0026#34;a: \u0026#34; + name) // 业务代码…… } type B struct{} func (b *B) Print(name string) { fmt.Println(\u0026#34;b: \u0026#34; + name) // 业务代码…… } 测试代码：\npackage templatemethod func ExamplePrintTemplate() { templateA := \u0026amp;A{} template := \u0026amp;template{ isTemplate: templateA, name: \u0026#34;hi~\u0026#34;, } template.Print() templateB := \u0026amp;B{} template.isTemplate = templateB template.Print() // Output: // a: hi~ // b: hi~ } 访问者模式Visitor 问题 访问者模式试图解决这样一个问题：在不改变类的对象结构的前提下增加新的操作。\n解决 请看以下代码：\npackage visitor import \u0026#34;fmt\u0026#34; type Shape interface { accept(visitor) } type square struct{} func (s *square) accept(v visitor) { v.visitForSquare(s) } type circle struct{} func (c *circle) accept(v visitor) { v.visitForCircle(c) } type visitor interface { visitForSquare(*square) visitForCircle(*circle) } type sideCalculator struct{} func (a *sideCalculator) visitForSquare(s *square) { fmt.Println(\u0026#34;square side\u0026#34;) } func (a *sideCalculator) visitForCircle(s *circle) { fmt.Println(\u0026#34;circle side\u0026#34;) } type radiusCalculator struct{} func (a *radiusCalculator) visitForSquare(s *square) { fmt.Println(\u0026#34;square radius\u0026#34;) } func (a *radiusCalculator) visitForCircle(c *circle) { fmt.Println(\u0026#34;circle radius\u0026#34;) } 测试代码：\npackage visitor func ExampleShape() { square := \u0026amp;square{} circle := \u0026amp;circle{} side := \u0026amp;sideCalculator{} square.accept(side) circle.accept(side) radius := \u0026amp;radiusCalculator{} square.accept(radius) circle.accept(radius) // Output: // square side // circle side // square radius // circle radius } 设计模式的“道” 上面那么多种设计模式你能记住几种呢？设计模式分为“术”的部分和“道”的部分，上面那些设计模式就是“术”的部分，他们是一些围绕着设计模式核心思路的经典解决方案。换句话说，重要的是理解为什么要用那些设计模式，具体问题，具体分析，而不是把某种设计模式生搬硬套进代码。\n设计模式有6大原则，以上的设计模式目的就是为了使软件系统能达到这些原则：\n开闭原则 软件应该对扩展开放，对修改关闭。\n对系统进行扩展，而无需修改现有的代码。这可以降低软件的维护成本，同时也增加可扩展性。\n里氏替换原则 任何基类可以出现的地方，子类一定可以出现。\n里氏替换原则是对开闭原则的补充，实现开闭原则的关键步骤就是抽象化，基类与子类的关系就是要尽可能的抽象化。\n依赖倒置原则 面向接口编程，抽象不应该依赖于具体类，具体类应当依赖于抽象。\n这是为了减少类间的耦合，使系统更适宜于扩展，也更便于维护。\n单一职责原则 一个类应该只有一个发生变化的原因。\n一个类承载的越多，耦合度就越高。如果类的职责单一，就可以降低出错的风险，也可以提高代码的可读性。\n最少知道原则 一个实体应当尽量少地与其他实体之间发生相互作用。\n还是为了降低耦合，一个类与其他类的关联越少，越易于扩展。\n接口分离原则 使用多个专门的接口，而不使用高耦合的单一接口。\n避免同一个接口占用过多的职责，更明确的划分，可以降低耦合。高耦合会导致程序不易扩展，提高出错的风险。\n","permalink":"https://liiqii.github.io/posts/tech/go/go_design_mode/","summary":"创建型模式 创建型模式是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象，增加已有代码的灵活性和可复用性。 工厂方法模式 Factory Method 问题 假设我们的业务需要一个支付渠道，我们开发了一个Pay方法，其可以用于支付。请看以下示例： type Pay interface { Pay() string } type PayReq struct { OrderId string // 订单号 } func (p *PayReq) Pay() string { // todo fmt.Println(p.OrderId)","title":"Go 23种设计模式"},{"content":"1. 介绍一下Channel Channel是Go语言中的一种并发原语，用于在goroutine之间传递数据和同步执行。Channel实际上是一种特殊类型的数据结构，可以将其想象成一个管道，通过它可以发送和接收数据，实现goroutine之间的通信和同步。\nChannel的特点包括：\nChannel是类型安全的，可以确保发送和接收的数据类型一致。 Channel是阻塞的，当发送或接收操作没有被满足时，会阻塞当前goroutine，直到满足条件。 Channel是有缓存的，可以指定缓存区大小，当缓存区已满时发送操作会被阻塞，当缓存区为空时接收操作会被阻塞。 Channel是可以关闭的，可以使用close()函数关闭Channel，关闭后的Channel不能再进行发送操作，但可以进行接收操作。 Channel的使用方式包括：\n创建Channel：使用make()函数创建Channel，指定Channel的类型和缓存区大小。 发送数据：使用\u0026lt;-运算符将数据发送到Channel中。 接收数据：使用\u0026lt;-运算符从Channel中接收数据。 关闭Channel：使用close()函数关闭Channel。 2. Channel在go中起什么作用 在 Go 中，channel 是一种用于在 goroutine 之间传递数据的并发原语。channel 可以让 goroutine 在发送和接收操作之间同步，从而避免了竞态条件，从而更加安全地共享内存。\nchannel 类似于一个队列，数据可以从一个 goroutine 中发送到 channel，然后从另一个 goroutine 中接收。channel 可以是有缓冲的，这意味着可以在 channel 中存储一定数量的值，而不仅仅是一个。如果 channel 是无缓冲的，则发送和接收操作将会同步阻塞，直到有 goroutine 准备好接收或发送数据。\n注：我这里提到了Channel底层用到了两个队列实现。所以就有了下面的问题\n3. Channel为什么需要两个队列实现 一个Channel可以被看作是一个通信通道，用于在不同的进程之间传递数据。在具体的实现中，一个Channel通常需要使用两个队列来实现。这两个队列是发送队列和接收队列。\n发送队列是用来存储将要发送的数据的队列。当一个进程想要通过Channel发送数据时，它会将数据添加到发送队列中。发送队列中的数据会按照先进先出的顺序被逐个发送到接收进程。如果发送队列已经满了，那么发送进程就需要等待，直到有足够的空间可以存储数据。\n接收队列是用来存储接收进程已经准备好接收的数据的队列。当一个进程从Channel中接收数据时，它会从接收队列中取出数据。如果接收队列是空的，那么接收进程就需要等待，直到有新的数据可以接收。\n使用两个队列实现Channel的主要原因是为了实现异步通信。发送进程可以在发送数据之后立即继续执行其他任务，而不需要等待接收进程确认收到数据。同样，接收进程也可以在等待数据到达的同时执行其他任务。这种异步通信的实现方式可以提高系统的吞吐量和响应速度。\n4. Go为什么要开发Channel，而别的语言为什么没有 在Go语言中，Channel是一种非常重要的并发原语。Go语言将Channel作为语言内置的原语，可能是出于以下几个方面的考虑：\n并发安全：在多线程并发环境下，使用Channel可以保证数据的安全性，避免多个线程同时访问共享数据导致的数据竞争和锁的开销。 简单易用：Go语言中的Channel是一种高度抽象的概念，可以非常方便地实现不同线程之间的数据传输和同步。通过Channel，程序员不需要手动地管理锁、条件变量等底层的同步原语，使得程序的编写更加简单和高效。 天然支持并发：Go语言中的Channel与goroutine密切相关，这使得Channel天然地支持并发。程序员可以通过使用Channel和goroutine来实现非常高效的并发编程。 虽然其他编程语言中没有像Go语言中的Channel这样的内置并发原语，但是许多编程语言提供了类似于Channel的实现，比如Java的ConcurrentLinkedQueue、Python的Queue、C++的std::queue等。这些实现虽然没有Go语言中的Channel那么简单易用和高效，但也能够满足多线程编程中的数据传输和同步需求。\n注：我这里提到了Channel底层是使用锁实现。所以就有了下面的问题\n5. Channel底层是使用锁控制并发的，为什么不直接使用锁 虽然在Go语言中，Channel底层实现是使用锁控制并发的，但是Channel和锁的使用场景是不同的，具有不同的优势和适用性。\n首先，Channel比锁更加高级和抽象。Channel可以实现多个goroutine之间的同步和数据传递，不需要程序员显式地使用锁来进行线程间的协调。Channel可以避免常见的同步问题，比如死锁、饥饿等问题。\n其次，Channel在语言层面提供了一种更高效的并发模型。在使用锁进行并发控制时，需要程序员自己手动管理锁的获取和释放，这增加了代码复杂度和错误的风险。而使用Channel时，可以通过goroutine的调度和Channel的阻塞机制来实现更加高效和简单的并发控制。\n此外，Channel还可以避免一些由锁导致的性能问题，如锁竞争、锁粒度过大或过小等问题。Channel提供了一种更加精细的控制机制，能够更好地平衡不同goroutine之间的并发性能。\n总的来说，虽然Channel底层是使用锁控制并发的，但是Channel在语言层面提供了更加高级、抽象和高效的并发模型，可以使程序员更加方便和安全地进行并发编程。\n三 扩展面试题 1. Channel的底层原理和数据结构 在Go语言中，Channel是通过一个有缓存的队列来实现的，底层数据结构是一个双向链表。是一个叫做hchan的结构体，每个Channel都有一个send队列和一个receive队列，用于存放发送和接收操作的goroutine。当发送操作和接收操作发生时，它们会被添加到对应的队列中，等待对方的操作来满足条件。\ntype hchan struct { //channel分为无缓冲和有缓冲两种。 //对于有缓冲的channel存储数据，借助的是如下循环数组的结构 qcount uint // 循环数组中的元素数量 dataqsiz uint // 循环数组的长度 buf unsafe.Pointer // 指向底层循环数组的指针 elemsize uint16 //能够收发元素的大小 closed uint32 //channel是否关闭的标志 elemtype *_type //channel中的元素类型 //有缓冲channel内的缓冲数组会被作为一个“环型”来使用。 //当下标超过数组容量后会回到第一个位置，所以需要有两个字段记录当前读和写的下标位置 sendx uint // 下一次发送数据的下标位置 recvx uint // 下一次读取数据的下标位置 //当循环数组中没有数据时，收到了接收请求，那么接收数据的变量地址将会写入读等待队列 //当循环数组中数据已满时，收到了发送请求，那么发送数据的变量地址将写入写等待队列 recvq waitq // 读等待队列 sendq waitq // 写等待队列 lock mutex //互斥锁，保证读写channel时不存在并发竞争问题 } 对于有缓存的Channel，缓存区的大小即为队列的长度，当缓存区已满时，发送操作会被阻塞，直到有接收操作来取走数据；当缓存区为空时，接收操作会被阻塞，直到有发送操作来填充数据。\nChannel底层的同步机制是基于等待队列和信号量实现的。每个Channel都维护着一个等待队列，其中包含了所有等待操作的goroutine；同时还维护着一个计数器，用于记录当前缓存区中的元素数量。当发送操作需要等待时，会将当前goroutine添加到等待队列中，并使计数器减一；当接收操作需要等待时，会将当前goroutine添加到等待队列中，并使计数器加一。当有其他操作满足条件时，会从等待队列中取出相应的goroutine，并将其重新加入到可执行队列中，等待调度器的调度。\n2. Channel的读写流程 向 channel 写数据:\n若等待接收队列 recvq 不为空，则缓冲区中无数据或无缓冲区，将直接从 recvq 取出 G ，并把数据写入，最后把该 G 唤醒，结束发送过程。\n若缓冲区中有空余位置，则将数据写入缓冲区，结束发送过程。\n若缓冲区中没有空余位置，则将发送数据写入 G，将当前 G 加入 sendq ，进入睡眠，等待被读 goroutine 唤醒。\n从 channel 读数据\n若等待发送队列 sendq 不为空，且没有缓冲区，直接从 sendq 中取出 G ，把 G 中数据读出，最后把 G 唤醒，结束读取过程。\n如果等待发送队列 sendq 不为空，说明缓冲区已满，从缓冲区中首部读出数据，把 G 中数据写入缓冲区尾部，把 G 唤醒，结束读取过程。\n如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程。\n将当前 goroutine 加入 recvq ，进入睡眠，等待被写 goroutine 唤醒。\n关闭 channel\n1.关闭 channel 时会将 recvq 中的 G 全部唤醒，本该写入 G 的数据位置为 nil。将 sendq 中的 G 全部唤醒，但是这些 G 会 panic。\npanic 出现的场景还有：\n关闭值为 nil 的 channel 关闭已经关闭的 channel 向已经关闭的 channel 中写数据 3. Channel为什么能做到线程安全 Channel的线程安全主要是通过其内部的同步机制实现的。\nChannel 可以理解是一个先进先出的队列，通过管道进行通信,发送一个数据到Channel和从Channel接收一个数据都是原子性的。不要通过共享内存来通信，而是通过通信来共享内存，前者就是传统的加锁，后者就是Channel。设计Channel的主要目的就是在多任务间传递数据的，本身就是安全的。\n当多个goroutine通过Channel进行通信时，Channel会保证每个操作的原子性和顺序性，避免了多个goroutine同时访问共享变量导致的数据竞争问题。Channel的阻塞特性也保证了在发送和接收操作发生时，它们会被添加到等待队列中，直到满足条件后才会被唤醒，从而避免了死锁问题。\n4. 操作Channel可能出现的情况 channel存在3种状态：\nnil，未初始化的状态，只进行了声明，或者手动赋值为nil active，正常的channel，可读或者可写 closed，已关闭，千万不要误认为关闭channel后，channel的值是nil 操作 一个零值nil通道 一个非零值但已关闭的通道 一个非零值且尚未关闭的通道 关闭 产生恐慌 产生恐慌 成功关闭 发送数据 永久阻塞 产生恐慌 阻塞或者成功发送 接收数据 永久阻塞 永不阻塞 阻塞或者成功接收 5. Channel有哪些常见的使用场景 任务分发和处理：可以通过Channel将任务分发给多个goroutine进行处理，并将处理结果发送回主goroutine进行汇总和处理。 并发控制：可以通过Channel来进行信号量控制，限制并发的数量，避免资源竞争和死锁等问题。 数据流处理：可以通过Channel实现数据流的处理，将数据按照一定的规则传递给不同的goroutine进行处理，提高并发处理效率。 事件通知和处理：可以通过Channel来实现事件的通知和处理，将事件发送到Channel中，让订阅了该Channel的goroutine进行相应的处理。 异步处理：可以通过Channel实现异步的处理，将任务交给其他goroutine处理，自己继续执行其他任务，等待处理结果时再从Channel中获取。 6. Channel的读写操作是否是原子性的，如何实现 Channel的读写操作是原子性的，并且是由Go语言内部的同步机制来保证的。\n当一个goroutine进行Channel的读写操作时，Go语言内部会自动进行同步，保证该操作的原子性和顺序性。这种同步机制主要涉及到两个部分：\n基于锁的同步：在Channel的底层实现中，使用了一种基于锁的同步机制，它可以保证每个读写操作都是原子性的，避免了多个goroutine同时读写导致的数据竞争问题。 基于等待的同步：当一个goroutine进行Channel的读写操作时，如果Channel当前为空或已满，它就会被添加到等待队列中，直到满足条件后才会被唤醒，这种等待的同步机制可以避免因Channel状态不满足条件而导致的死锁问题。 通过这种基于锁和等待的同步机制，Go语言保证了Channel的读写操作是原子性的，可以在多个goroutine之间安全地进行通信和同步。\n7. 如何避免在Channel中出现死锁的情况 避免在单个goroutine中对Channel进行读写操作：如果一个goroutine同时进行Channel的读写操作，很容易出现死锁的情况，因为该goroutine无法切换到其他任务，导致无法释放Channel的读写锁。因此，在进行Channel的读写操作时，应该尽量将它们分配到不同的goroutine中，以便能够及时切换任务。 使用缓冲Channel：缓冲Channel可以在一定程度上缓解读写操作的同步问题，避免因为Channel状态不满足条件而导致的死锁问题。如果Channel是非缓冲的，那么写操作必须等到读操作执行之后才能完成，反之亦然，这种同步会导致程序无法继续执行。而如果使用缓冲Channel，就可以避免这种同步问题，即使读写操作之间存在时间差，也不会导致死锁。 使用select语句：select语句可以在多个Channel之间进行选择操作，避免因为某个Channel状态不满足条件而导致的死锁问题。在使用select语句时，应该注意判断每个Channel的状态，避免出现同时等待多个Channel的情况，这可能导致死锁。 使用超时机制：在进行Channel的读写操作时，可以设置一个超时时间，避免因为Channel状态不满足条件而一直等待的情况。如果超过一定时间仍然无法读写Channel，就可以选择放弃或者进行其他操作，以避免死锁。 8. Channel可以在多个goroutine之间传递什么类型的数据 在Go语言中，Channel可以在多个goroutine之间传递任何类型的数据，包括基本数据类型、复合数据类型、结构体、自定义类型等。这些数据类型在传递过程中都会被封装成对应的指针类型，并由Channel进行传递。\n9. 如何在Channel中使用缓存区 在Go语言中，我们可以使用带缓冲的Channel来实现Channel的缓存区功能。带缓冲的Channel可以存储一定数量的元素，而不必立即将它们交给接收方。这样可以减少发送和接收操作之间的同步，从而提高程序的性能。\n使用带缓冲的Channel，可以通过在Channel声明时指定缓冲区的大小来实现。例如，声明一个容量为10的缓冲Channel可以使用以下语句：\nch := make(chan int, 10) 在这个例子中，我们创建了一个整型缓冲Channel，其容量为10。这意味着在Channel中可以存储10个整型元素，而不必立即将它们发送到接收方。当Channel中的元素数量达到缓冲区容量时，再进行写入操作时，写入操作就会被阻塞，直到有接收方读取了Channel中的元素。\n10. 在使用Channel时，如何保证数据的同步性和一致性 在使用Channel时，为了保证数据的同步性和一致性，可以采用以下几种方式：\n合理设计Channel的容量：当Channel容量过小时，容易出现发送者和接收者之间的阻塞，而当容量过大时，可能会出现数据不一致的问题。因此，在设计Channel时，需要根据实际情况合理设定容量大小，以避免数据同步性和一致性的问题。 使用互斥锁保证数据访问的互斥性：如果多个goroutine同时对某个共享的数据进行访问，可能会导致数据不一致的问题。此时，可以使用互斥锁来保证数据访问的互斥性，以避免多个goroutine同时对同一份数据进行访问。 使用同步机制实现数据同步：在某些情况下，我们可能需要在多个goroutine之间进行数据同步，以确保数据的一致性。此时，可以使用一些同步机制，例如WaitGroup、Barrier、Cond等，来实现数据同步。 11. 如何保证Channel的安全性 确保Channel的正确使用：在使用Channel时，需要确保发送和接收操作的正确性。特别是在并发环境下，必须正确处理并发操作，避免出现竞争条件或死锁等问题。因此，在使用Channel时，需要根据实际情况选择合适的同步机制，例如互斥锁、条件变量、原子操作等，以确保Channel的正确使用。 避免Channel的泄漏：如果Channel没有被及时关闭，可能会导致资源泄漏和性能问题。因此，在使用Channel时，需要确保及时关闭Channel，避免出现资源泄漏的情况。 避免Channel的阻塞：如果Channel的容量较小，可能会导致发送和接收操作的阻塞。此时，可以使用缓冲Channel或者带超时的发送和接收操作，避免Channel的阻塞。 避免Channel的死锁：如果多个goroutine之间出现死锁，可能会导致程序的停滞和性能问题。因此，在使用Channel时，需要避免死锁的情况，例如避免循环依赖、避免同时使用多个Channel等。 12. Channel的大小是否对性能有影响 Channel的大小对性能会产生一定的影响。Channel的大小是指Channel可以容纳的元素数量，可以通过在创建Channel时指定容量大小来控制。当Channel的容量较小时，可能会导致发送和接收操作的阻塞，从而影响程序的性能。而当Channel的容量较大时，可能会增加系统的内存开销，也可能会导致Channel中的元素被占用的时间较长，从而影响程序的响应性。\n13. Channel的内存模型是什么 在Go语言中，Channel的内存模型是基于通信顺序进程（Communicating Sequential Processes，CSP）模型的。CSP模型是一种并发计算模型，它将并发程序看作是一组顺序进程，这些进程通过Channel进行通信和同步。\n在CSP模型中，每个进程都是独立的，它们之间通过Channel进行通信。Channel是一个具有FIFO特性的数据结构，用于在多个进程之间传递数据。当一个进程向Channel发送数据时，它会阻塞等待，直到另一个进程从Channel中接收到数据。同样地，当一个进程从Channel中接收数据时，它也会阻塞等待，直到另一个进程向Channel发送数据。\n在Go语言中，Channel的内存模型采用了CSP模型的概念，即每个Channel都是一个独立的顺序进程。当一个进程向Channel发送数据时，数据会被复制到Channel的缓冲区或者直接发送到接收方。当一个进程从Channel中接收数据时，数据会被从Channel的缓冲区中取出或者等待发送方发送数据。\n14. 如何在Channel中传递复杂的数据类型 在Go语言中，Channel可以传递任何类型的数据，包括复杂的数据类型。如果要在Channel中传递复杂的数据类型，可以将其定义为一个结构体，然后通过Channel进行传递。\n例如，假设我们有一个结构体类型Person，它包含姓名和年龄两个字段：\ntype Person struct { Name string Age int } 我们可以定义一个Channel，用于传递Person类型的数据：\nch := make(chan Person) 现在我们可以在不同的Goroutine中向Channel发送和接收Person类型的数据：\n// 发送Person类型数据到Channel go func() { p := Person{Name: \u0026#34;Alice\u0026#34;, Age: 18} ch \u0026lt;- p }() // 从Channel接收Person类型数据 p := \u0026lt;-ch fmt.Println(p.Name, p.Age) 注意，如果要在Channel中传递复杂的数据类型，需要确保该类型是可导出的。\n15. Channel和goroutine之间的关系是什么 在Go语言中，Channel和Goroutine是密切相关的，它们可以说是Go语言并发编程的两个重要组件。\nGoroutine是Go语言中轻量级的线程实现，可以在一个进程中创建成千上万个Goroutine，并且它们的创建和销毁的代价非常小，因此非常适合在高并发的场景下使用。Goroutine的调度是由Go运行时系统（runtime）负责的，它采用协作式调度，可以自动地在多个线程之间切换，以达到高效利用CPU的目的。\nChannel是Goroutine之间通信的一种方式，它可以用于在不同的Goroutine之间传递数据。Channel提供了两个基本操作：发送和接收。通过向Channel发送数据，一个Goroutine可以将数据传递给另一个Goroutine；通过从Channel接收数据，一个Goroutine可以获取其他Goroutine传递过来的数据。\n因此，可以说Channel和Goroutine之间是一种协作关系：Goroutine可以通过Channel与其他Goroutine进行通信，以实现协作和共享数据，从而完成复杂的并发任务。同时，Channel的实现也依赖于Goroutine和Go运行时系统，它们共同构成了Go语言并发编程的基础。\n16. 在Go语言中，Channel和锁的使用场景有哪些区别 在Go语言中，Channel和锁（sync.Mutex等）都可以用于并发编程中的同步和共享数据，但它们的使用场景有一些区别。\nChannel通常用于Goroutine之间传递数据，并发的Goroutine之间可以通过Channel进行同步。使用Channel可以避免锁的问题，例如死锁、饥饿等问题。Channel可以将数据在多个Goroutine之间进行传递和共享，而且在数据传递的过程中，不需要使用锁来保证数据的安全性，这也是Channel比锁更加安全和高效的原因之一。因此，当需要在不同的Goroutine之间传递数据时，使用Channel是比较合适的选择。\n锁通常用于对共享资源进行保护，防止多个Goroutine同时访问和修改同一个共享资源，从而导致数据的竞争和不一致。使用锁可以保证同一时刻只有一个Goroutine能够访问和修改共享资源，从而保证数据的安全性和一致性。当需要对共享资源进行保护时，使用锁是比较合适的选择。\nChannel和锁都是Go语言中常用的并发编程工具，它们各自有不同的使用场景。在实际开发中，应根据具体的需求选择合适的并发编程工具来实现同步和共享数据。\n","permalink":"https://liiqii.github.io/posts/tech/go/go_channel/","summary":"1. 介绍一下Channel Channel是Go语言中的一种并发原语，用于在goroutine之间传递数据和同步执行。Channel实际上是一种特殊类型的数据结构，可以将其想象成一个管道，通过它可以发送和接收数据，实现goroutine之间的通信和同步。 Channel的特点包括： Ch","title":"Go Channel详解"},{"content":"在Go中，搭建一个HTTP server简单到令人难以置信。只需要引入net/http包，写几行代码，一个HTTP服务器就可以正常运行并接受访问请求。\n下面就是Go最简单的HTTP服务器：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) func myfunc(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;hi\u0026#34;) } func main() { http.HandleFunc(\u0026#34;/\u0026#34;, myfunc) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } 编译运行程序，然后打开浏览器访问 http://localhost:8080/ , 我们可以看到网页输出\u0026quot;hi\u0026quot; ! 就这么简单，我们实现了一个HTTPserver！\n下面我们通过分析net/http的源代码，来深入理解这个包的实现原理。在net/http源代码中，我们可以深深体会到Go语言的结构体（以及自定义类型）、接口、方法简单组合的设计哲学。这个包最主要的文件有4个，分别是： client.go server.go request.go response.go\n这四个文件也分别代表了HTTP中最重要的4个部分，HTTP Request 请求、 HTTP Response 响应、HTTP Client客户端和HTTP Server 服务端，所以我们先从这四个方面来了解net/http包：\n1 Request HTTP Request请求是由客户端发出的消息, 用来使服务器执行动作.发出的消息包括起始行, Headers, Body。\n在net/http包中，request.go文件定义了结构：\ntype Request struct HTTP Request请求是HTTP Client客户端向HTTP Server服务端发出的消息，或者是HTTP Server服务端收到的一个请求，但是HTTP Server服务端和HTTP Client客户端使用Request时语义区别很大。我们一般使用 http.NewRequest来构造一个HTTP Request请求，可能包括HTTP Headers信息，cookies信息等，然后发给服务端：\n// 利用指定的method, url以及可选的body返回一个新的请求.如果body参数实现了 // io.Closer接口，Request返回值的Body 字段会被设置为body，并会被Client // 类型的Do、Post和PostForm方法以及Transport.RoundTrip方法关闭。 func NewRequest(method, urlStr string, body io.Reader) (*Request, error) // 从b中读取和解析一个请求. func ReadRequest(b *bufio.Reader) (req *Request, err error) // 给request添加cookie, AddCookie向请求中添加一个cookie.按照RFC 6265 // section 5.4的规则, AddCookie不会添加超过一个Cookie头字段. // 这表示所有的cookie都写在同一行, 用分号分隔（cookie内部用逗号分隔属性） func (r *Request) AddCookie(c *Cookie) // 返回request中指定名name的cookie，如果没有发现，返回ErrNoCookie func (r *Request) Cookie(name string) (*Cookie, error) // 返回该请求的所有cookies func (r *Request) Cookies() []*Cookie // 利用提供的用户名和密码给http基本权限提供具有一定权限的header。 // 当使用http基本授权时，用户名和密码是不加密的 func (r *Request) SetBasicAuth(username, password string) // 如果在request中发送，该函数返回客户端的user-Agent func (r *Request) UserAgent() string // 对于指定格式的key，FormFile返回符合条件的第一个文件，如果有必要的话， // 该函数会调用ParseMultipartForm和ParseForm。 func (r *Request) FormFile(key string) (multipart.File, *multipart.FileHeader, error) // 返回key获取的队列中第一个值。在查询过程中post和put中的主题参数优先级 // 高于url中的value。为了访问相同key的多个值，调用ParseForm然后直接 // 检查RequestForm。 func (r *Request) FormValue(key string) string // 如果这是一个有多部分组成的post请求，该函数将会返回一个MIME 多部分reader， // 否则的话将会返回一个nil和error。使用本函数代替ParseMultipartForm // 可以将请求body当做流stream来处理。 func (r *Request) MultipartReader() (*multipart.Reader, error) // 解析URL中的查询字符串，并将解析结果更新到r.Form字段。对于POST或PUT // 请求，ParseForm还会将body当作表单解析，并将结果既更新到r.PostForm也 // 更新到r.Form。解析结果中，POST或PUT请求主体要优先于URL查询字符串 // （同名变量，主体的值在查询字符串的值前面）。如果请求的主体的大小没有被 // MaxBytesReader函数设定限制，其大小默认限制为开头10MB。 // ParseMultipartForm会自动调用ParseForm。重复调用本方法是无意义的。 func (r *Request) ParseForm() error // ParseMultipartForm将请求的主体作为multipart/form-data解析。 // 请求的整个主体都会被解析，得到的文件记录最多 maxMemery字节保存在内存， // 其余部分保存在硬盘的temp文件里。如果必要，ParseMultipartForm会 // 自行调用 ParseForm。重复调用本方法是无意义的。 func (r *Request) ParseMultipartForm(maxMemory int64) error // 返回post或者put请求body指定元素的第一个值，其中url中的参数被忽略。 func (r *Request) PostFormValue(key string) string // 检测在request中使用的http协议是否至少是major.minor func (r *Request) ProtoAtLeast(major，minor int) bool // 如果request中有refer，那么refer返回相应的url。Referer在request // 中是拼错的，这个错误从http初期就已经存在了。该值也可以从Headermap中 // 利用Header[\u0026#34;Referer\u0026#34;]获取；在使用过程中利用Referer这个方法而 // 不是map的形式的好处是在编译过程中可以检查方法的错误，而无法检查map中 // key的错误。 func (r *Request) Referer() string // Write方法以有线格式将HTTP/1.1请求写入w（用于将请求写入下层TCPConn等） // 。本方法会考虑请求的如下字段：Host URL Method (defaults to \u0026#34;GET\u0026#34;) // Header ContentLength TransferEncoding Body如果存在Body， // ContentLength字段\u0026lt;= 0且TransferEncoding字段未显式设置为 // [\u0026#34;identity\u0026#34;]，Write方法会显式添加”Transfer-Encoding: chunked” // 到请求的头域。Body字段会在发送完请求后关闭。 func (r *Request) Write(w io.Writer) error // 该函数与Write方法类似，但是该方法写的request是按照http代理的格式去写。 // 尤其是，按照RFC 2616 Section 5.1.2，WriteProxy会使用绝对URI // （包括协议和主机名）来初始化请求的第1行（Request-URI行）。无论何种情况， // WriteProxy都会使用r.Host或r.URL.Host设置Host头。 func (r *Request) WriteProxy(w io.Writer) error 2 Response HTTP Response响应是由HTTP Server服务端发出的消息，用来响应HTTP Client端发出的HTTP Request请求。发出的消息包括起始行, Headers, Body。\n// 注意是在response.go中定义的，而在server.go有一个 // type response struct ，注意大小写。这个结构是体现在server端的功能。 type Response struct // ReadResponse从r读取并返回一个HTTP 回复。req参数是可选的，指定该回复 // 对应的请求（即是对该请求的回复）。如果是nil，将假设请 求是GET请求。 // 客户端必须在结束resp.Body的读取后关闭它。读取完毕并关闭后，客户端可以 // 检查resp.Trailer字段获取回复的 trailer的键值对。 func ReadResponse(r *bufio.Reader, req *Request) (*Response, error) // 解析cookie并返回在header中利用set-Cookie设定的cookie值。 func (r *Response) Cookies() []*Cookie // 返回response中Location的header值的url。如果该值存在的话，则对于 // 请求问题可以解决相对重定向的问题，如果该值为nil，则返回ErrNOLocation。 func (r *Response) Location() (*url.URL，error) // 判定在response中使用的http协议是否至少是major.minor的形式。 func (r *Response) ProtoAtLeast(major, minor int) bool // 将response中信息按照线性格式写入w中。 func (r *Response) Write(w io.Writer) error 3 client HTTP Client客户端主要用来发送HTTP Request请求给HTTP Server服务端，比如以Do方法，Get方法以及Post或PostForm方法发送HTTP Request请求。\n// Client具有Do，Get，Head，Post以及PostForm等方法。 其中Do方法可以对 // Request进行一系列的设定，而其他的对request设定较少。如果Client使用默认的 // Client，则其中的Get，Head，Post以及PostForm方法相当于默认的http.Get, // http.Post, http.Head以及http.PostForm函数。 type Client struct // 利用GET方法对一个指定的URL进行请求，如果response是如下重定向中的一个 // 代码，则Get之后将会调用重定向内容，最多10次重定向。 // 301 (永久重定向，告诉客户端以后应该从新地址访问) // 302 (暂时性重定向，作为HTTP1.0的标准，PHP的默认Location重定向用到 // 也是302)，注：303和307其实是对302的细化。 // 303 (对于Post请求，它表示请求已经被处理，客户端可以接着使用GET方法去 // 请求Location里的URl) // 307 (临时重定向，对于Post请求，表示请求还没有被处理，客户端应该向 // Location里的URL重新发起Post请求) func Get(url string) (resp *Response, err error) // 该函数功能见net中Head方法功能。该方法与默认的defaultClient中 // Head方法一致。 func Head(url string) (resp *Response, err error) // 该方法与默认的defaultClient中Post方法一致。 func Post(url string, bodyType string, body io.Reader) (resp *Response, err error) // 该方法与默认的defaultClient中PostForm方法一致。 func PostForm(url string, data url.Values) (resp *Response, err error) // Do发送http请求并且返回一个http响应, 遵守client的策略, 如重定向, // cookies以及auth等.错误经常是由于策略引起的, 当err是nil时, resp // 总会包含一个非nil的resp.body.当调用者读完resp.body之后应该关闭它, // 如果resp.body没有关闭, 则Client底层RoundTripper将无法重用存在的 // TCP连接去服务接下来的请求, 如果resp.body非nil, 则必须对其进行关闭. // 通常来说, 经常使用Get, Post, 或者PostForm来替代Do. func (c *Client) Do(req *Request) (resp *Response, err error) // 利用get方法请求指定的url.Get请求指定的页面信息，并返回实体主体。 func (c *Client) Get(url string) (resp *Response, err error) // 利用head方法请求指定的url，Head只返回页面的首部。 func (c *Client) Head(url string) (resp *Response, err error) // post方法请求指定的URl, 如果body也是一个io.Closer, 则在请求之后关闭它 func (c *Client) Post(url string, bodyType string, body io.Reader) (resp *Response, err error) // 利用post方法请求指定的url, 利用data的key和value作为请求体. func (c *Client) PostForm(url string, data url.Values) (resp *Response, err error) http.NewRequest可以灵活的对http Request进行配置，然后再使用http.Client的Do方法发送这个http Request请求。注意：如果使用Post或者PostForm方法，是不能使用http.NewRequest配置请求的，只有Do方法可以定制http.NewRequest。\n利用http.Client以及http.NewRequest就可以完整模拟一个HTTP Request请求，包括自定义的HTTP Request请求的头部信息。有了前面介绍的 HTTP Request 请求、HTTP Response 响应、HTTP Client 客户端 三个部分，我们已经可以模拟各种HTTP Request 请求的发送，接收HTTP Response 响应了。\n下面我们来模拟HTTP Request请求，请求中附带有cookie信息，通过http.Client的Do方法发送这个请求。\n先配置http.NewRequest，然后我们通过http.Client的Do方法来发送任何HTTP Request请求。示例如下：\n模拟任何HTTP Request请求： package main import ( \u0026#34;compress/gzip\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;strconv\u0026#34; ) func main() { // 简式声明一个http.Client空结构体指针对象 client := \u0026amp;http.Client{} // 使用http.NewRequest构建http Request请求 request, err := http.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;http://www.baidu.com\u0026#34;, nil) if err != nil { fmt.Println(err) } // 使用http.Cookie结构体初始化一个cookie键值对 cookie := \u0026amp;http.Cookie{Name: \u0026#34;userId\u0026#34;, Value: strconv.Itoa(12345)} // 使用前面构建的request方法AddCookie往请求中添加cookie request.AddCookie(cookie) // 设置request的Header，具体可参考http协议 request.Header.Set(\u0026#34;Accept\u0026#34;, \u0026#34;text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8\u0026#34;) request.Header.Set(\u0026#34;Accept-Charset\u0026#34;, \u0026#34;GBK, utf-8;q=0.7, *;q=0.3\u0026#34;) request.Header.Set(\u0026#34;Accept-Encoding\u0026#34;, \u0026#34;gzip, deflate, sdch\u0026#34;) request.Header.Set(\u0026#34;Accept-Language\u0026#34;, \u0026#34;zh-CN, zh;q=0.8\u0026#34;) request.Header.Set(\u0026#34;Cache-Control\u0026#34;, \u0026#34;max-age=0\u0026#34;) request.Header.Set(\u0026#34;Connection\u0026#34;, \u0026#34;keep-alive\u0026#34;) // 使用http.Client 来发送request，这里使用了Do方法。 response, err := client.Do(request) if err != nil { fmt.Println(err) return } // 程序结束时关闭response.Body响应流 defer response.Body.Close() // 接收到的http Response 状态值 fmt.Println(response.StatusCode) if response.StatusCode == 200 { // 200意味成功得到http Server返回的http Response信息 // gzip.NewReader对压缩的返回信息解压（考虑网络传输量，http Server // 一般都会对响应压缩后再返回） body, err := gzip.NewReader(response.Body) if err != nil { fmt.Println(err) } defer body.Close() r, err := ioutil.ReadAll(body) if err != nil { fmt.Println(err) } // 打印出http Server返回的http Response信息 fmt.Println(string(r)) } } 使用http.Get 发送HTTP Get请求非常简单，在一般简单不需要对http.Request配置的场景下我们可以使用，只需要提供URL即可。\n发送一个HTTP Get请求： package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { // var DefaultClient = \u0026amp;Client{} // func Get(url string) (resp *Response, err error) { // return DefaultClient.Get(url) // } /* func (c *Client) Get(url string) (resp *Response, err error) { req, err := NewRequest(\u0026#34;GET\u0026#34;, url, nil) if err != nil { return nil, err } return c.Do(req) } */ // http.Get实际上是DefaultClient.Get(url)，Get函数是高度封装的，只有一个参数url。 // 对于一般的http Request是可以使用，但是不能定制Request response, err := http.Get(\u0026#34;http://www.baidu.com\u0026#34;) if err != nil { fmt.Println(err) } //程序在使用完回复后必须关闭回复的主体。 defer response.Body.Close() body, _ := ioutil.ReadAll(response.Body) fmt.Println(string(body)) } 使用http.Post 发送HTTP Post请求也非常简单，在一般简单不需要对http.Request配置的场景下我们可以使用。\n发送一个http.Post请求： package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;strings\u0026#34; ) func main() { // application/x-www-form-urlencoded：为POST的contentType // strings.NewReader(\u0026#34;mobile=xxxxxxxxxx\u0026amp;isRemberPwd=1\u0026#34;) 理解为传递的参数 resp, err := http.Post(\u0026#34;http://localhost:8080/login.do\u0026#34;, \u0026#34;application/x-www-form-urlencoded\u0026#34;, strings.NewReader(\u0026#34;mobile=xxxxxxxxxx\u0026amp;isRemberPwd=1\u0026#34;)) if err != nil { fmt.Println(err) return } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) if err != nil { fmt.Println(err) return } fmt.Println(string(body)) } 使用http.PostForm 发送HTTP Request请求也非常简单，而且可以附带参数的键值对作为请求的body传递到服务端。\n发送一个http.PostForm请求： package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;net/url\u0026#34; ) func main() { postParam := url.Values{ \u0026#34;mobile\u0026#34;: {\u0026#34;xxxxxx\u0026#34;}, \u0026#34;isRemberPwd\u0026#34;: {\u0026#34;1\u0026#34;}, } // 数据的键值会经过URL编码后作为请求的body传递 resp, err := http.PostForm(\u0026#34;http://localhost：8080/login.do\u0026#34;, postParam) if err != nil { fmt.Println(err) return } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) if err != nil { fmt.Println(err) return } fmt.Println(string(body)) } 上面列举了四种HTTP Client客户端发送HTTP Request请求的方式，其中只有Do方法最灵活。\nhttp.Client与http.NewRequest结合可以模拟任何HTTP Request请求，方法是Do。像Get方法，Post方法和PostForm方法，http.NewRequest都是定制好的，所以使用方便但灵活性不够。不过好在有Do方法，我们可以更灵活来配置http.NewRequest。\nfunc NewRequest(method, url string, body io.Reader) (*Request, error) func (c *Client) Get(url string) (resp *Response, err error) { req, err := NewRequest(\u0026#34;GET\u0026#34;, url, nil) ...... func (c *Client) Post(url string, contentType string, body io.Reader) (resp *Response, err error) { req, err := NewRequest(\u0026#34;POST\u0026#34;, url, body) ...... 4 HTTP Server 服务端 HTTP Server服务端用来接收并响应HTTP Client端发出的HTTP Request请求，是net/http包中非常重要和关键的一个功能。我们在Go语言中简单就能搭建HTTP服务器，就是因为它的存在。\n在server.go文件中还定义了一个非常重要的接口：Handler，另外还有一个结构体response，这和http.Response结构体只有首字母大小写不一致，不过这个response 也是响应，只不过是专门用在服务端，和http.Response结构体是完全两回事。\ntype Handler interface { ServeHTTP(ResponseWriter, *Request) } type Server struct // 监听TCP网络地址srv.Addr然后调用Serve来处理接下来连接的请求。 // 如果srv.Addr是空的话，则使用“:http”。 func (srv *Server) ListenAndServe() error // ListenAndServeTLS监听srv.Addr确定的TCP地址，并且会调用Serve // 方法处理接收到的连接。必须提供证书文件和对应的私钥文 件。如果证书是由 // 权威机构签发的，certFile参数必须是顺序串联的服务端证书和CA证书。 // 如果srv.Addr为空字符串，会使 用”:https”。 func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error // 接受Listener l的连接，创建一个新的服务协程。该服务协程读取请求然后调用 // srv.Handler来应答。实际上就是实现了对某个端口进行监听，然后创建相应的连接。 func (srv *Server) Serve(l net.Listener) error // 该函数控制是否http的keep-alives能够使用，默认情况下，keep-alives总是可用的。 // 只有资源非常紧张的环境或者服务端在关闭进程中时，才应该关闭该功能。 func (s *Server) SetKeepAlivesEnabled(v bool) // 是一个http请求多路复用器，它将每一个请求的URL和 // 一个注册模式的列表进行匹配，然后调用和URL最匹配的模式的处理器进行后续操作。 type ServeMux // 初始化一个新的ServeMux func NewServeMux() *ServeMux // 将handler注册为指定的模式，如果该模式已经有了handler，则会出错panic。 func (mux *ServeMux) Handle(pattern string, handler Handler) // 将handler注册为指定的模式 func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) // 根据指定的r.Method, r.Host以及r.RUL.Path返回一个用来处理给定请求的handler。 // 该函数总是返回一个非nil的 handler，如果path不是一个规范格式，则handler会 // 重定向到其规范path。Handler总是返回匹配该请求的的已注册模式；在内建重定向 // 处理器的情况下，pattern会在重定向后进行匹配。如果没有已注册模式可以应用于该请求， // 本方法将返回一个内建的”404 page not found”处理器和一个空字符串模式。 func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) // 该函数用于将最接近请求url模式的handler分配给指定的请求。 func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) Handler接口应该算是server.go中最关键的接口了，如果我们仔细看这个文件的源代码，将会发现很多结构体实现了这个接口的ServeHTTP方法。\n注意这个接口的注释：Handler响应HTTP请求。没错，最终我们的HTTP服务是通过实现ServeHTTP(ResponseWriter, *Request)来达到服务端接收客户端请求并响应。\n理解 HTTP 构建的网络应用只要关注两个端\u0026mdash;客户端（Clinet）和服务端（Server），两个端的交互来自 Clinet 的 Request，以及Server端的Response。HTTP服务器，主要在于如何接受 Clinet端的 Request，Server端向Client端返回Response。\n那这个过程是什么样的呢？要讲清楚这个过程，还需要回到开始的HTTP服务器程序。这里以前面我们了解到的HTTP Request、HTTP Response、HTTP Client作为基础，并重点分析server.go源代码才能讲清楚：\nfunc main() { http.HandleFunc(\u0026#34;/\u0026#34;, myfunc) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } 以上两行代码，就成功启动了一个HTTP服务器。我们通过net/http 包源代码分析发现，调用Http.HandleFunc，按顺序做了几件事：\n1.Http.HandleFunc调用了DefaultServeMux的HandleFunc\nfunc HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { DefaultServeMux.HandleFunc(pattern, handler) } 2.DefaultServeMux.HandleFunc调用了DefaultServeMux的Handle，DefaultServeMux是一个ServeMux 指针变量。而ServeMux 是Go语言中的Multiplexer（多路复用器），通过Handle匹配pattern 和我们定义的handler（其实就是http.HandlerFunc函数类型变量）。\nvar DefaultServeMux = \u0026amp;defaultServeMux var defaultServeMux ServeMux func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { mux.Handle(pattern, HandlerFunc(handler)) } 注意： 上面的方法命名Handle，HandleFunc和HandlerFunc，Handler（接口），他们很相似，容易混淆。记住Handle和HandleFunc和pattern 匹配有关，也即往DefaultServeMux的map[string]muxEntry中增加对应的handler和路由规则。\n接着我们看看myfunc的声明和定义：\nfunc myfunc(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;hi\u0026#34;) } 而type HandlerFunc func(ResponseWriter, *Request) 是一个函数类型，而我们定义的myfunc的函数签名刚好符合这个函数类型。\n所以http.HandleFunc(\u0026quot;/\u0026quot;, myfunc)，实际上是mux.Handle(\u0026quot;/\u0026quot;, HandlerFunc(myfunc))。\nHandlerFunc(myfunc) 让myfunc成为了HandlerFunc类型，我们称myfunc为handler。而HandlerFunc类型是具有ServeHTTP方法的，而有了ServeHTTP方法也就是实现了Handler接口。\nfunc (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) { f(w, r) // 这相当于自身的调用 } 现在ServeMux和Handler都和我们的myfunc联系上了，myfunc是一个Handler接口变量也是HandlerFunc类型变量，接下来和结构体server有关了。\n从http.ListenAndServe的源码可以看出，它创建了一个server对象，并调用server对象的ListenAndServe方法：\nfunc ListenAndServe(addr string, handler Handler) error { server := \u0026amp;Server{Addr: addr, Handler: handler} return server.ListenAndServe() } 而我们HTTP服务器中第二行代码：\nhttp.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) 创建了一个server对象，并调用server对象的ListenAndServe方法，这里没有直接传递Handler，而是默认使用DefautServeMux作为multiplexer，myfunc是存在于handler和路由规则中的。\nServer的ListenAndServe方法中，会初始化监听地址Addr，同时调用Listen方法设置监听。\nfor { rw, e := l.Accept() ... c := srv.newConn(rw) c.setState(c.rwc, StateNew) go c.serve(ctx) } 监听开启之后，一旦客户端请求过来，Go就开启一个协程go c.serve(ctx)处理请求，主要逻辑都在serve方法之中。\nfunc (c *conn) serve(ctx context.Context)，这个方法很长，里面主要的一句：serverHandler{c.server}.ServeHTTP(w, w.req)。其中w由w, err := c.readRequest(ctx)得到，因为有传递context。\n还是来看源代码：\ntype serverHandler struct { srv *Server } func (sh serverHandler) ServeHTTP(rw ResponseWriter, req Request) { handler := sh.srv.Handler if handler == nil { handler = DefaultServeMux } if req.RequestURI == \u0026#34;\u0026#34; \u0026amp;\u0026amp; req.Method == \u0026#34;OPTIONS\u0026#34; { handler = globalOptionsHandler{} } handler.ServeHTTP(rw, req) } 从http.ListenAndServe(\u0026quot;:8080\u0026quot;, nil)开始，handler是nil，所以最后实际ServeHTTP方法是DefaultServeMux.ServeHTTP(rw, req)。\nfunc (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) { if r.RequestURI == \u0026#34;*\u0026#34; { if r.ProtoAtLeast(1, 1) { w.Header().Set(\u0026#34;Connection\u0026#34;, \u0026#34;close\u0026#34;) } w.WriteHeader(StatusBadRequest) return } h, _ := mux.Handler(r) h.ServeHTTP(w, r) } 通过func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string)，我们得到Handler h，然后执行h.ServeHTTP(w, r)方法，也就是执行我们的myfunc函数（别忘了myfunc是HandlerFunc类型，而他的ServeHTTP(w, r)方法这里其实就是自己调用自己），把response写到http.ResponseWriter对象返回给客户端，fmt.Fprintf(w, \u0026ldquo;hi\u0026rdquo;)，我们在客户端会接收到hi 。至此整个HTTP服务执行完成。\n总结下，HTTP服务整个过程大概是这样：\nRequest -\u0026gt; ServeMux(Multiplexer) -\u0026gt; handler-\u0026gt; Response 我们再看下面代码：\nhttp.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) func ListenAndServe(addr string, handler Handler) error { server := \u0026amp;Server{Addr: addr, Handler: handler} return server.ListenAndServe() } 上面代码实际上就是server.ListenAndServe()执行的实际效果，只不过简单声明了一个结构体Server{Addr: addr, Handler: handler}实例。如果我们声明一个Server实例，完全可以达到深度自定义 http.Server的目的：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) func myfunc(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;hi\u0026#34;) } func main() { // 更多http.Server的字段可以根据情况初始化 server := http.Server{ Addr: \u0026#34;:8080\u0026#34;, ReadTimeout: 0, WriteTimeout: 0, } http.HandleFunc(\u0026#34;/\u0026#34;, myfunc) server.ListenAndServe() } 这样服务也能跑起来，而且我们完全可以根据情况来自定义我们的Server！ 还可以指定Servemux的用法: GOPATH\\src\\go42\\chapter-15\\15.3\\7\\main.go package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) func myfunc(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;hi\u0026#34;) } func main() { mux := http.NewServeMux() mux.HandleFunc(\u0026#34;/\u0026#34;, myfunc) http.ListenAndServe(\u0026#34;:8080\u0026#34;, mux) } 如果既指定Servemux又自定义 http.Server，因为Server中有字段Handler，所以我们可以直接把Servemux变量作为Server.Handler：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) func myfunc(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;hi\u0026#34;) } func main() { server := http.Server{ Addr: \u0026#34;:8080\u0026#34;, ReadTimeout: 0, WriteTimeout: 0, } mux := http.NewServeMux() server.Handler = mux mux.HandleFunc(\u0026#34;/\u0026#34;, myfunc) server.ListenAndServe() } 在前面pprof 包的内容中我们也用了本章开头这段代码，当我们访问http://localhost:8080/debug/pprof/ 时可以看到对应的性能分析报告。 因为我们这样导入 _\u0026ldquo;net/http/pprof\u0026rdquo; 包时，在文件 pprof.go 文件中init 函数已经定义好了handler：\nfunc init() { http.HandleFunc(\u0026#34;/debug/pprof/\u0026#34;, Index) http.HandleFunc(\u0026#34;/debug/pprof/cmdline\u0026#34;, Cmdline) http.HandleFunc(\u0026#34;/debug/pprof/profile\u0026#34;, Profile) http.HandleFunc(\u0026#34;/debug/pprof/symbol\u0026#34;, Symbol) http.HandleFunc(\u0026#34;/debug/pprof/trace\u0026#34;, Trace) } 所以，我们就可以通过浏览器访问上面地址来看到报告。现在再来看这些代码，我们就明白怎么回事了！\n5 自定义处理器（Custom Handlers） 自定义的Handler：\n标准库http提供了Handler接口，用于开发者实现自己的handler。只要实现接口的ServeHTTP方法即可。\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; ) type timeHandler struct { format string } func (th *timeHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { tm := time.Now().Format(th.format) w.Write([]byte(\u0026#34;The time is: \u0026#34; + tm)) } func main() { mux := http.NewServeMux() th := \u0026amp;timeHandler{format: time.RFC1123} mux.Handle(\u0026#34;/time\u0026#34;, th) log.Println(\u0026#34;Listening...\u0026#34;) http.ListenAndServe(\u0026#34;:3000\u0026#34;, mux) } 我们知道，NewServeMux可以创建一个ServeMux实例，ServeMux同时也实现了ServeHTTP方法，因此代码中的mux也是一种handler。把它当成参数传给http.ListenAndServe方法，后者会把mux传给Server实例。因为指定了handler，因此整个http服务就不再是DefaultServeMux，而是mux，无论是在注册路由还是提供请求服务的时候。\n任何有 func(http.ResponseWriter，*http.Request) 签名的函数都能转化为一个 HandlerFunc 类型。这很有用，因为 HandlerFunc 对象内置了 ServeHTTP 方法，后者可以聪明又方便的调用我们最初提供的函数内容。\n6 将函数作为处理器 package main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; ) func timeHandler(w http.ResponseWriter, r *http.Request) { tm := time.Now().Format(time.RFC1123) w.Write([]byte(\u0026#34;The time is: \u0026#34; + tm)) } func main() { mux := http.NewServeMux() // Convert the timeHandler function to a HandlerFunc type th := http.HandlerFunc(timeHandler) // And add it to the ServeMux mux.Handle(\u0026#34;/time\u0026#34;, th) log.Println(\u0026#34;Listening...\u0026#34;) http.ListenAndServe(\u0026#34;:3000\u0026#34;, mux) } 创建新的server：\nfunc index(w http.ResponseWriter, r *http.Request) { w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/html\u0026#34;) html := `\u0026lt;doctype html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Hello World\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt; Welcome \u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;` fmt.Fprintln(w, html) } func main(){ http.HandleFunc(\u0026#34;/\u0026#34;, index) server := \u0026amp;http.Server{ Addr: \u0026#34;:8000\u0026#34;, ReadTimeout: 60 * time.Second, WriteTimeout: 60 * time.Second, } server.ListenAndServe() } 7 中间件Middleware 所谓中间件，就是连接上下级不同功能的函数或者软件，通常进行一些包裹函数的行为，为被包裹函数提供添加一些功能或行为。前文的HandleFunc就能把签名为 func(w http.ResponseWriter, r *http.Reqeust)的函数包裹成handler。这个函数也算是中间件。\nGo的HTTP中间件很简单，只要实现一个函数签名为func(http.Handler) http.Handler的函数即可。http.Handler是一个接口，接口方法我们熟悉的为serveHTTP。返回也是一个handler。因为Go中的函数也可以当成变量传递或者或者返回，因此也可以在中间件函数中传递定义好的函数，只要这个函数是一个handler即可，即实现或者被handlerFunc包裹成为handler处理器。\nfunc index(w http.ResponseWriter, r *http.Request) { w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/html\u0026#34;) html := `\u0026lt;doctype html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Hello World\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt; Welcome \u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;` fmt.Fprintln(w, html) } func middlewareHandler(next http.Handler) http.Handler{ return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request){ // 执行handler之前的逻辑 next.ServeHTTP(w, r) // 执行完毕handler后的逻辑 }) } func loggingHandler(next http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { start := time.Now() log.Printf(\u0026#34;Started %s %s\u0026#34;, r.Method, r.URL.Path) next.ServeHTTP(w, r) log.Printf(\u0026#34;Completed %s in %v\u0026#34;, r.URL.Path, time.Since(start)) }) } func main() { http.Handle(\u0026#34;/\u0026#34;, loggingHandler(http.HandlerFunc(index))) http.ListenAndServe(\u0026#34;:8000\u0026#34;, nil) } 8 静态站点 下面代码通过指定目录，作为静态站点：\npackage main import ( \u0026#34;net/http\u0026#34; ) func main() { http.Handle(\u0026#34;/\u0026#34;, http.FileServer(http.Dir(\u0026#34;D:/html/static/\u0026#34;))) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } ","permalink":"https://liiqii.github.io/posts/tech/go/go_http/","summary":"在Go中，搭建一个HTTP server简单到令人难以置信。只需要引入net/http包，写几行代码，一个HTTP服务器就可以正常运行并接受访问请求。 下面就是Go最简单的HTTP服务器： package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) func myfunc(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;hi\u0026#34;) } func main() { http.HandleFunc(\u0026#34;/\u0026#34;, myfunc) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } 编译运行程序，然后打开浏览器访问 http://localhost:8080/ , 我们可以看到","title":"Go net http包"},{"content":"转自：RPC 工作原理\nGo RPC Go 标准包中已经提供了对 RPC 的支持，而且支持三个级别的 RPC：TCP、HTTP、JSONRPC。但 Go 的 RPC 包是独一无二的 RPC，它和传统的 RPC 系统不同，它只支持 Go 开发的服务器与客户端之间的交互，因为在内部，它们采用了 Gob 来编码。\nGo RPC 的函数只有符合下面的条件才能被远程访问，不然会被忽略，详细的要求如下：\n函数必须是导出的 (首字母大写) 必须有两个导出类型的参数， 第一个参数是接收的参数，第二个参数是返回给客户端的参数，第二个参数必须是指针类型的 函数还要有一个返回值 error 举个例子，正确的 RPC 函数格式如下：\nfunc (t *T) MethodName(argType T1, replyType *T2) error T、T1 和 T2 类型必须能被 encoding/gob 包编解码。\n任何的 RPC 都需要通过网络来传递数据，Go RPC 可以利用 HTTP 和 TCP 来传递数据，利用 HTTP 的好处是可以直接复用 net/http 里面的一些函数。详细的例子请看下面的实现\nHTTP RPC http 的服务端代码实现如下：\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;net/rpc\u0026#34; ) type Args struct { A, B int } type Quotient struct { Quo, Rem int } type Arith int func (t *Arith) Multiply(args *Args, reply *int) error { *reply = args.A * args.B return nil } func (t *Arith) Divide(args *Args, quo *Quotient) error { if args.B == 0 { return errors.New(\u0026#34;divide by zero\u0026#34;) } quo.Quo = args.A / args.B quo.Rem = args.A % args.B return nil } func main() { arith := new(Arith) rpc.Register(arith) rpc.HandleHTTP() err := http.ListenAndServe(\u0026#34;:1234\u0026#34;, nil) if err != nil { fmt.Println(err.Error()) } } 通过上面的例子可以看到，我们注册了一个 Arith 的 RPC 服务，然后通过 rpc.HandleHTTP 函数把该服务注册到了 HTTP 协议上，然后我们就可以利用 http 的方式来传递数据了。\n请看下面的客户端代码：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/rpc\u0026#34; \u0026#34;os\u0026#34; ) type Args struct { A, B int } type Quotient struct { Quo, Rem int } func main() { if len(os.Args) != 2 { fmt.Println(\u0026#34;Usage: \u0026#34;, os.Args[0], \u0026#34;server\u0026#34;) os.Exit(1) } serverAddress := os.Args[1] client, err := rpc.DialHTTP(\u0026#34;tcp\u0026#34;, serverAddress+\u0026#34;:1234\u0026#34;) if err != nil { log.Fatal(\u0026#34;dialing:\u0026#34;, err) } // Synchronous call args := Args{17, 8} var reply int err = client.Call(\u0026#34;Arith.Multiply\u0026#34;, args, \u0026amp;reply) if err != nil { log.Fatal(\u0026#34;arith error:\u0026#34;, err) } fmt.Printf(\u0026#34;Arith: %d*%d=%d\\n\u0026#34;, args.A, args.B, reply) var quot Quotient err = client.Call(\u0026#34;Arith.Divide\u0026#34;, args, \u0026amp;quot) if err != nil { log.Fatal(\u0026#34;arith error:\u0026#34;, err) } fmt.Printf(\u0026#34;Arith: %d/%d=%d remainder %d\\n\u0026#34;, args.A, args.B, quot.Quo, quot.Rem) } 我们把上面的服务端和客户端的代码分别编译，然后先把服务端开启，然后开启客户端，输入代码，就会输出如下信息：\n$ ./http_c localhost Arith: 17*8=136 Arith: 17/8=2 remainder 1 通过上面的调用可以看到参数和返回值是我们定义的 struct 类型，在服务端我们把它们当做调用函数的参数的类型，在客户端作为 client.Call 的第 2，3 两个参数的类型。客户端最重要的就是这个 Call 函数，它有 3 个参数，第 1 个要调用的函数的名字，第 2 个是要传递的参数，第 3 个要返回的参数 (注意是指针类型)，通过上面的代码例子我们可以发现，使用 Go 的 RPC 实现相当的简单，方便。\nTCP RPC 上面我们实现了基于 HTTP 协议的 RPC，接下来我们要实现基于 TCP 协议的 RPC，服务端的实现代码如下所示：\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; \u0026#34;net/rpc\u0026#34; \u0026#34;os\u0026#34; ) type Args struct { A, B int } type Quotient struct { Quo, Rem int } type Arith int func (t *Arith) Multiply(args *Args, reply *int) error { *reply = args.A * args.B return nil } func (t *Arith) Divide(args *Args, quo *Quotient) error { if args.B == 0 { return errors.New(\u0026#34;divide by zero\u0026#34;) } quo.Quo = args.A / args.B quo.Rem = args.A % args.B return nil } func main() { arith := new(Arith) rpc.Register(arith) tcpAddr, err := net.ResolveTCPAddr(\u0026#34;tcp\u0026#34;, \u0026#34;:1234\u0026#34;) checkError(err) listener, err := net.ListenTCP(\u0026#34;tcp\u0026#34;, tcpAddr) checkError(err) for { conn, err := listener.Accept() if err != nil { continue } rpc.ServeConn(conn) } } func checkError(err error) { if err != nil { fmt.Println(\u0026#34;Fatal error \u0026#34;, err.Error()) os.Exit(1) } } 上面这个代码和 http 的服务器相比，不同在于：在此处我们采用了 TCP 协议，然后需要自己控制连接，当有客户端连接上来后，我们需要把这个连接交给 rpc 来处理。\n如果你留心了，你会发现这它是一个阻塞型的单用户的程序，如果想要实现多并发，那么可以使用 goroutine 来实现，我们前面在 socket 小节的时候已经介绍过如何处理 goroutine。\n下面展现了 TCP 实现的 RPC 客户端：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/rpc\u0026#34; \u0026#34;os\u0026#34; ) type Args struct { A, B int } type Quotient struct { Quo, Rem int } func main() { if len(os.Args) != 2 { fmt.Println(\u0026#34;Usage: \u0026#34;, os.Args[0], \u0026#34;server:port\u0026#34;) os.Exit(1) } service := os.Args[1] client, err := rpc.Dial(\u0026#34;tcp\u0026#34;, service) if err != nil { log.Fatal(\u0026#34;dialing:\u0026#34;, err) } // Synchronous call args := Args{17, 8} var reply int err = client.Call(\u0026#34;Arith.Multiply\u0026#34;, args, \u0026amp;reply) if err != nil { log.Fatal(\u0026#34;arith error:\u0026#34;, err) } fmt.Printf(\u0026#34;Arith: %d*%d=%d\\n\u0026#34;, args.A, args.B, reply) var quot Quotient err = client.Call(\u0026#34;Arith.Divide\u0026#34;, args, \u0026amp;quot) if err != nil { log.Fatal(\u0026#34;arith error:\u0026#34;, err) } fmt.Printf(\u0026#34;Arith: %d/%d=%d remainder %d\\n\u0026#34;, args.A, args.B, quot.Quo, quot.Rem) } 这个客户端代码和 http 的客户端代码对比，唯一的区别一个是 DialHTTP，一个是 Dial (tcp)，其他处理一模一样。\nJSON RPC JSON RPC 是数据编码采用了 JSON，而不是 gob 编码，其他和上面介绍的 RPC 概念一模一样，下面我们来演示一下，如何使用 Go 提供的 json-rpc 标准包，请看服务端代码的实现：\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; \u0026#34;net/rpc\u0026#34; \u0026#34;net/rpc/jsonrpc\u0026#34; \u0026#34;os\u0026#34; ) type Args struct { A, B int } type Quotient struct { Quo, Rem int } type Arith int func (t *Arith) Multiply(args *Args, reply *int) error { *reply = args.A * args.B return nil } func (t *Arith) Divide(args *Args, quo *Quotient) error { if args.B == 0 { return errors.New(\u0026#34;divide by zero\u0026#34;) } quo.Quo = args.A / args.B quo.Rem = args.A % args.B return nil } func main() { arith := new(Arith) rpc.Register(arith) tcpAddr, err := net.ResolveTCPAddr(\u0026#34;tcp\u0026#34;, \u0026#34;:1234\u0026#34;) checkError(err) listener, err := net.ListenTCP(\u0026#34;tcp\u0026#34;, tcpAddr) checkError(err) for { conn, err := listener.Accept() if err != nil { continue } jsonrpc.ServeConn(conn) } } func checkError(err error) { if err != nil { fmt.Println(\u0026#34;Fatal error \u0026#34;, err.Error()) os.Exit(1) } } 通过示例我们可以看出 json-rpc 是基于 TCP 协议实现的，目前它还不支持 HTTP 方式。\n请看客户端的实现代码：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/rpc/jsonrpc\u0026#34; \u0026#34;os\u0026#34; ) type Args struct { A, B int } type Quotient struct { Quo, Rem int } func main() { if len(os.Args) != 2 { fmt.Println(\u0026#34;Usage: \u0026#34;, os.Args[0], \u0026#34;server:port\u0026#34;) log.Fatal(1) } service := os.Args[1] client, err := jsonrpc.Dial(\u0026#34;tcp\u0026#34;, service) if err != nil { log.Fatal(\u0026#34;dialing:\u0026#34;, err) } // Synchronous call args := Args{17, 8} var reply int err = client.Call(\u0026#34;Arith.Multiply\u0026#34;, args, \u0026amp;reply) if err != nil { log.Fatal(\u0026#34;arith error:\u0026#34;, err) } fmt.Printf(\u0026#34;Arith: %d*%d=%d\\n\u0026#34;, args.A, args.B, reply) var quot Quotient err = client.Call(\u0026#34;Arith.Divide\u0026#34;, args, \u0026amp;quot) if err != nil { log.Fatal(\u0026#34;arith error:\u0026#34;, err) } fmt.Printf(\u0026#34;Arith: %d/%d=%d remainder %d\\n\u0026#34;, args.A, args.B, quot.Quo, quot.Rem) } ","permalink":"https://liiqii.github.io/posts/tech/go/go_rpc/","summary":"转自：RPC 工作原理 Go RPC Go 标准包中已经提供了对 RPC 的支持，而且支持三个级别的 RPC：TCP、HTTP、JSONRPC。但 Go 的 RPC 包是独一无二的 RPC，它和传统的 RPC 系统不同，它只支持 Go 开发的服务器与客户端之间的交互，因为在内部，它们采用了 Gob 来编码。 Go RPC 的函数只有符合下面的条件才能被远程","title":"GO RPC 工作原理"},{"content":"转自：Iris\n安装 Iris是一个跨平台的软件。\n唯一的要求是 Go 编程语言，版本 1.20 及更高版本。\n$ mkdir myapp $ cd myapp $ go mod init myapp $ go get github.com/kataras/iris/v12@latest 将其导入到代码中：\nimport \u0026#34;github.com/kataras/iris/v12\u0026#34; 故障 排除 如果在安装过程中遇到网络错误，请确保设置了有效的 GOPROXY 环境变量。\ngo env -w GOPROXY=https://goproxy.io,direct 如果上述方法均无效，请清理 go 模块缓存：\ngo clean --modcache 快速入门 # assume the following codes in main.go file $ cat main.go package main import \u0026#34;github.com/kataras/iris/v12\u0026#34; func main() { app := iris.New() booksAPI := app.Party(\u0026#34;/books\u0026#34;) { booksAPI.Use(iris.Compression) // GET: http://localhost:8080/books booksAPI.Get(\u0026#34;/\u0026#34;, list) // POST: http://localhost:8080/books booksAPI.Post(\u0026#34;/\u0026#34;, create) } app.Listen(\u0026#34;:8080\u0026#34;) } // Book example. type Book struct { Title string `json:\u0026#34;title\u0026#34;` } func list(ctx iris.Context) { books := []Book{ {\u0026#34;Mastering Concurrency in Go\u0026#34;}, {\u0026#34;Go Design Patterns\u0026#34;}, {\u0026#34;Black Hat Go\u0026#34;}, } ctx.JSON(books) // TIP: negotiate the response between server\u0026#39;s prioritizes // and client\u0026#39;s requirements, instead of ctx.JSON: // ctx.Negotiation().JSON().MsgPack().Protobuf() // ctx.Negotiate(books) } func create(ctx iris.Context) { var b Book err := ctx.ReadJSON(\u0026amp;b) // TIP: use ctx.ReadBody(\u0026amp;b) to bind // any type of incoming data instead. if err != nil { ctx.StopWithProblem(iris.StatusBadRequest, iris.NewProblem(). Title(\u0026#34;Book creation failure\u0026#34;).DetailErr(err)) // TIP: use ctx.StopWithError(code, err) when only // plain text responses are expected on errors. return } println(\u0026#34;Received Book: \u0026#34; + b.Title) ctx.StatusCode(iris.StatusCreated) } MVC 等效项：\nimport \u0026#34;github.com/kataras/iris/v12/mvc\u0026#34; m := mvc.New(booksAPI) m.Handle(new(BookController)) type BookController struct { /* dependencies */ } // GET: http://localhost:8080/books func (c *BookController) Get() []Book { return []Book{ {\u0026#34;Mastering Concurrency in Go\u0026#34;}, {\u0026#34;Go Design Patterns\u0026#34;}, {\u0026#34;Black Hat Go\u0026#34;}, } } // POST: http://localhost:8080/books func (c *BookController) Post(b Book) int { println(\u0026#34;Received Book: \u0026#34; + b.Title) return iris.StatusCreated } 运行您的鸢尾花网络服务器：\n$ go run main.go \u0026gt; Now listening on: http://localhost:8080 \u0026gt; Application started. Press CTRL+C to shut down. 列表书：\n$ curl --header \u0026#39;Accept-Encoding:gzip\u0026#39; http://localhost:8080/books [ { \u0026#34;title\u0026#34;: \u0026#34;Mastering Concurrency in Go\u0026#34; }, { \u0026#34;title\u0026#34;: \u0026#34;Go Design Patterns\u0026#34; }, { \u0026#34;title\u0026#34;: \u0026#34;Black Hat Go\u0026#34; } ] 创建新图书：\n$ curl -i -X POST \\ --header \u0026#39;Content-Encoding:gzip\u0026#39; \\ --header \u0026#39;Content-Type:application/json\u0026#39; \\ --data \u0026#34;{\\\u0026#34;title\\\u0026#34;:\\\u0026#34;Writing An Interpreter In Go\\\u0026#34;}\u0026#34; \\ http://localhost:8080/books \u0026gt; HTTP/1.1 201 Created 这就是错误响应的样子：\n$ curl -X POST --data \u0026#34;{\\\u0026#34;title\\\u0026#34; \\\u0026#34;not valid one\\\u0026#34;}\u0026#34; \\ http://localhost:8080/books \u0026gt; HTTP/1.1 400 Bad Request { \u0026#34;status\u0026#34;: 400, \u0026#34;title\u0026#34;: \u0026#34;Book creation failure\u0026#34; \u0026#34;detail\u0026#34;: \u0026#34;invalid character \u0026#39;\\\u0026#34;\u0026#39; after object key\u0026#34;, } 基准 Iris使用muxie的自定义版本。\n查看所有基准\n📖 使用 int 的动态参数触发 200000 个请求，将 JSON 作为请求正文发送，并接收 JSON 作为响应。\n名字 语言 要求/秒 延迟 吞吐量 完成时间 虹膜 去 238954 521.69乌秒 64.15兆字节 0.84秒 琴酒 去 229665 541.96乌秒 62.86兆字节 0.87秒 池 去 228072 545.78乌秒 62.61兆字节 0.88秒 回波 去 224491 553.84乌秒 61.70兆字节 0.89秒 马提尼酒 去 198166 627.46乌秒 54.47兆字节 1.01秒 茶隼 C# 163486 766.90乌秒 47.42兆字节 1.23秒 水牛 去 102478 1.22毫秒 28.14兆字节 1.95秒 科阿 爪哇语 48425 2.56毫秒 15.39兆字节 4.14秒 表达 爪哇语 23622 5.25毫秒 9.04兆字节 8.41秒 接口示例 您可以在 Iris 示例存储库中找到许多随时可以运行的示例。\n使用获取、发布、放置、修补、删除和选项 func main() { // Creates an iris application with default middleware: // Default with \u0026#34;debug\u0026#34; Logger Level. // Localization enabled on \u0026#34;./locales\u0026#34; directory // and HTML templates on \u0026#34;./views\u0026#34; or \u0026#34;./templates\u0026#34; directory. // It runs with the AccessLog on \u0026#34;./access.log\u0026#34;, // Recovery (crash-free) and Request ID middleware already attached. app := iris.Default() app.Get(\u0026#34;/someGet\u0026#34;, getting) app.Post(\u0026#34;/somePost\u0026#34;, posting) app.Put(\u0026#34;/somePut\u0026#34;, putting) app.Delete(\u0026#34;/someDelete\u0026#34;, deleting) app.Patch(\u0026#34;/somePatch\u0026#34;, patching) app.Header(\u0026#34;/someHead\u0026#34;, head) app.Options(\u0026#34;/someOptions\u0026#34;, options) app.Listen(\u0026#34;:8080\u0026#34;) } 路径中的参数 func main() { app := iris.Default() // This handler will match /user/john but will not match /user/ or /user app.Get(\u0026#34;/user/{name}\u0026#34;, func(ctx iris.Context) { name := ctx.Params().Get(\u0026#34;name\u0026#34;) ctx.Writef(\u0026#34;Hello %s\u0026#34;, name) }) // However, this one will match /user/john/ and also /user/john/send // If no other routers match /user/john, it will redirect to /user/john/ app.Get(\u0026#34;/user/{name}/{action:path}\u0026#34;, func(ctx iris.Context) { name := ctx.Params().Get(\u0026#34;name\u0026#34;) action := ctx.Params().Get(\u0026#34;action\u0026#34;) message := name + \u0026#34; is \u0026#34; + action ctx.WriteString(message) }) // For each matched request Context will hold the route definition app.Post(\u0026#34;/user/{name:string}/{action:path}\u0026#34;, func(ctx iris.Context) { ctx.GetCurrentRoute().Tmpl().Src == \u0026#34;/user/{name:string}/{action:path}\u0026#34; // true }) app.Listen(\u0026#34;:8080\u0026#34;) } 内置可用参数类型：\n参数类型 去类型 验证 检索帮助程序 :string 字符串 任何（单路径段） Params().Get :uuid 字符串 uuidv4 或 v1（单路径段） Params().Get :int 国际 -9223372036854775808 到 9223372036854775807 （x64） 或 -2147483648 到 2147483647 （x32），取决于主机架构 Params().GetInt :int8 国际8 -128 到 127 Params().GetInt8 :int16 国际16 -32768 到 32767 Params().GetInt16 :int32 国际32 -2147483648 到 2147483647 Params().GetInt32 :int64 国际64 -9223372036854775808 到 9223372036854775807 Params().GetInt64 :uint 乌因特 0 到 18446744073709551615 （x64） 或 0 到 4294967295 （x32），取决于主机架构 Params().GetUint :uint8 uint8 0 到 255 Params().GetUint8 :uint16 uint16 0 到 65535 Params().GetUint16 :uint32 uint32 0 到 4294967295 Params().GetUint32 :uint64 uint64 0 到 18446744073709551615 Params().GetUint64 :bool 布尔 “1”或“t”或“T”或“真”或“真”或“真”或“0”或“f”或“F”或“假”或“假”或“假” Params().GetBool :alphabetical 字符串 小写或大写字母 Params().Get :file 字符串 小写或大写字母、数字、下划线 （_）、短划线 （-）、点 （.） 并且没有空格或其他对文件名无效的特殊字符 Params().Get :path 字符串 任何内容都可以用斜杠（路径段）分隔，但应该是路由路径的最后一部分 Params().Get :mail 字符串 未经域验证的电子邮件 Params().Get :email 字符串 具有域验证功能的电子邮件 Params().Get :date 字符串 年/月/日格式，例如 /博客/{参数：日期} 匹配 /博客/2022/04/21 Params().GetTime和Params().SimpleDate :weekday uint （0-6） 或字符串 时间串。工作日长名称格式（“星期日”到“星期一”或“星期日”到“星期一”）格式，例如 /schedule/{param：weekday} 匹配 /schedule/星期一 Params().GetWeekday 更多示例可在以下位置找到：_examples/路由。\n查询字符串参数 func main() { app := iris.Default() // Query string parameters are parsed using the existing underlying request object. // The request responds to a url matching: /welcome?firstname=Jane\u0026amp;lastname=Doe app.Get(\u0026#34;/welcome\u0026#34;, func(ctx iris.Context) { firstname := ctx.URLParamDefault(\u0026#34;firstname\u0026#34;, \u0026#34;Guest\u0026#34;) lastname := ctx.URLParam(\u0026#34;lastname\u0026#34;) // shortcut for ctx.Request().URL.Query().Get(\u0026#34;lastname\u0026#34;) ctx.Writef(\u0026#34;Hello %s %s\u0026#34;, firstname, lastname) }) app.Listen(\u0026#34;:8080\u0026#34;) } 多部分/乌伦编码形式 func main() { app := iris.Default() app.Post(\u0026#34;/form_post\u0026#34;, func(ctx iris.Context) { message := ctx.PostValue(\u0026#34;message\u0026#34;) nick := ctx.PostValueDefault(\u0026#34;nick\u0026#34;, \u0026#34;anonymous\u0026#34;) ctx.JSON(iris.Map{ \u0026#34;status\u0026#34;: \u0026#34;posted\u0026#34;, \u0026#34;message\u0026#34;: message, \u0026#34;nick\u0026#34;: nick, }) }) app.Listen(\u0026#34;:8080\u0026#34;) } 再比如：查询+帖子表单 POST /post?id=1234\u0026amp;page=1 HTTP/1.1 Content-Type: application/x-www-form-urlencoded name=kataras\u0026amp;message=this_is_great func main() { app := iris.Default() app.Post(\u0026#34;/post\u0026#34;, func(ctx iris.Context) { id, err := ctx.URLParamInt(\u0026#34;id\u0026#34;, 0) if err != nil { ctx.StopWithError(iris.StatusBadRequest, err) return } page := ctx.URLParamIntDefault(\u0026#34;page\u0026#34;, 0) name := ctx.PostValue(\u0026#34;name\u0026#34;) message := ctx.PostValue(\u0026#34;message\u0026#34;) ctx.Writef(\u0026#34;id: %d; page: %d; name: %s; message: %s\u0026#34;, id, page, name, message) }) app.Listen(\u0026#34;:8080\u0026#34;) } id: 1234; page: 1; name: kataras; message: this_is_great (adsbygoogle = window.adsbygoogle || []).push({});\n查询和发布表单参数 POST /post?id=a\u0026amp;id=b\u0026amp;id=c\u0026amp;name=john\u0026amp;name=doe\u0026amp;name=kataras Content-Type: application/x-www-form-urlencoded func main() { app := iris.Default() app.Post(\u0026#34;/post\u0026#34;, func(ctx iris.Context) { ids := ctx.URLParamSlice(\u0026#34;id\u0026#34;) names, err := ctx.PostValues(\u0026#34;name\u0026#34;) if err != nil { ctx.StopWithError(iris.StatusBadRequest, err) return } ctx.Writef(\u0026#34;ids: %v; names: %v\u0026#34;, ids, names) }) app.Listen(\u0026#34;:8080\u0026#34;) } ids: [a b c], names: [john doe kataras] 上传文件 单个文件 const maxSize = 8 * iris.MB func main() { app := iris.Default() app.Post(\u0026#34;/upload\u0026#34;, func(ctx iris.Context) { // Set a lower memory limit for multipart forms (default is 32 MiB) ctx.SetMaxRequestBodySize(maxSize) // OR // app.Use(iris.LimitRequestBodySize(maxSize)) // OR // OR iris.WithPostMaxMemory(maxSize) // single file file, fileHeader, err:= ctx.FormFile(\u0026#34;file\u0026#34;) if err != nil { ctx.StopWithError(iris.StatusBadRequest, err) return } // Upload the file to specific destination. dest := filepath.Join(\u0026#34;./uploads\u0026#34;, fileHeader.Filename) ctx.SaveFormFile(fileHeader, dest) ctx.Writef(\u0026#34;File: %s uploaded!\u0026#34;, fileHeader.Filename) }) app.Listen(\u0026#34;:8080\u0026#34;) } 如何：curl\ncurl -X POST http://localhost:8080/upload \\ -F \u0026#34;file=@/Users/kataras/test.zip\u0026#34; \\ -H \u0026#34;Content-Type: multipart/form-data\u0026#34; 多个文件 请参阅详细的示例代码。\nfunc main() { app := iris.Default() app.Post(\u0026#34;/upload\u0026#34;, func(ctx iris.Context) { files, n, err := ctx.UploadFormFiles(\u0026#34;./uploads\u0026#34;) if err != nil { ctx.StopWithStatus(iris.StatusInternalServerError) return } ctx.Writef(\u0026#34;%d files of %d total size uploaded!\u0026#34;, len(files), n)) }) app.Listen(\u0026#34;:8080\u0026#34;, iris.WithPostMaxMemory(8 * iris.MB)) } 如何：curl\ncurl -X POST http://localhost:8080/upload \\ -F \u0026#34;upload[]=@/Users/kataras/test1.zip\u0026#34; \\ -F \u0026#34;upload[]=@/Users/kataras/test2.zip\u0026#34; \\ -H \u0026#34;Content-Type: multipart/form-data\u0026#34; 对路线进行分组 func main() { app := iris.Default() // Simple group: v1 v1 := app.Party(\u0026#34;/v1\u0026#34;) { v1.Post(\u0026#34;/login\u0026#34;, loginEndpoint) v1.Post(\u0026#34;/submit\u0026#34;, submitEndpoint) v1.Post(\u0026#34;/read\u0026#34;, readEndpoint) } // Simple group: v2 v2 := app.Party(\u0026#34;/v2\u0026#34;) { v2.Post(\u0026#34;/login\u0026#34;, loginEndpoint) v2.Post(\u0026#34;/submit\u0026#34;, submitEndpoint) v2.Post(\u0026#34;/read\u0026#34;, readEndpoint) } app.Listen(\u0026#34;:8080\u0026#34;) } 默认不带中间件的空白光圈 用\napp := iris.New() 而不是\n// Default with \u0026#34;debug\u0026#34; Logger Level. // Localization enabled on \u0026#34;./locales\u0026#34; directory // and HTML templates on \u0026#34;./views\u0026#34; or \u0026#34;./templates\u0026#34; directory. // It runs with the AccessLog on \u0026#34;./access.log\u0026#34;, // Recovery and Request ID middleware already attached. app := iris.Default() 使用中间件 package main import ( \u0026#34;github.com/kataras/iris/v12\u0026#34; \u0026#34;github.com/kataras/iris/v12/middleware/recover\u0026#34; ) func main() { // Creates an iris application without any middleware by default app := iris.New() // Global middleware using `UseRouter`. // // Recovery middleware recovers from any panics and writes a 500 if there was one. app.UseRouter(recover.New()) // Per route middleware, you can add as many as you desire. app.Get(\u0026#34;/benchmark\u0026#34;, MyBenchLogger(), benchEndpoint) // Authorization group // authorized := app.Party(\u0026#34;/\u0026#34;, AuthRequired()) // exactly the same as: authorized := app.Party(\u0026#34;/\u0026#34;) // per group middleware! in this case we use the custom created // AuthRequired() middleware just in the \u0026#34;authorized\u0026#34; group. authorized.Use(AuthRequired()) { authorized.Post(\u0026#34;/login\u0026#34;, loginEndpoint) authorized.Post(\u0026#34;/submit\u0026#34;, submitEndpoint) authorized.Post(\u0026#34;/read\u0026#34;, readEndpoint) // nested group testing := authorized.Party(\u0026#34;testing\u0026#34;) testing.Get(\u0026#34;/analytics\u0026#34;, analyticsEndpoint) } // Listen and serve on 0.0.0.0:8080 app.Listen(\u0026#34;:8080\u0026#34;) } (adsbygoogle = window.adsbygoogle || []).push({});\n应用程序文件记录器 func main() { app := iris.Default() // Logging to a file. // Colors are automatically disabled when writing to a file. f, _ := os.Create(\u0026#34;iris.log\u0026#34;) app.Logger().SetOutput(f) // Use the following code if you need to write the logs // to file and console at the same time. // app.Logger().AddOutput(os.Stdout) app.Get(\u0026#34;/ping\u0026#34;, func(ctx iris.Context) { ctx.WriteString(\u0026#34;pong\u0026#34;) }) app.Listen(\u0026#34;:8080\u0026#34;) } 控制日志输出着色 默认情况下，控制台上的日志输出应根据检测到的 TTY 进行着色。\n自定义关卡标题，文本，颜色和样式。\n导入和 ：golog``pio\nimport ( \u0026#34;github.com/kataras/golog\u0026#34; \u0026#34;github.com/kataras/pio\u0026#34; // [...] ) 获取要自定义的级别，例如：DebugLevel\nlevel := golog.Levels[golog.DebugLevel] 您可以完全控制他的文字、标题和风格：\n// The Name of the Level // that named (lowercased) will be used // to convert a string level on `SetLevel` // to the correct Level type. Name string // AlternativeNames are the names that can be referred to this specific log level. // i.e Name = \u0026#34;warn\u0026#34; // AlternativeNames = []string{\u0026#34;warning\u0026#34;}, it\u0026#39;s an optional field, // therefore we keep Name as a simple string and created this new field. AlternativeNames []string // Tha Title is the prefix of the log level. // See `ColorCode` and `Style` too. // Both `ColorCode` and `Style` should be respected across writers. Title string // ColorCode a color for the `Title`. ColorCode int // Style one or more rich options for the `Title`. Style []pio.RichOption 示例代码：\nlevel := golog.Levels[golog.DebugLevel] level.Name = \u0026#34;debug\u0026#34; // default level.Title = \u0026#34;[DBUG]\u0026#34; // default level.ColorCode = pio.Yellow // default 要更改输出格式：\napp.Logger().SetFormat(\u0026#34;json\u0026#34;, \u0026#34; \u0026#34;) 注册自定义格式化程序：\napp.Logger().RegisterFormatter(new(myFormatter)) 嘟嘟。格式化程序界面如下所示：\n// Formatter is responsible to print a log to the logger\u0026#39;s writer. type Formatter interface { // The name of the formatter. String() string // Set any options and return a clone, // generic. See `Logger.SetFormat`. Options(opts ...interface{}) Formatter // Writes the \u0026#34;log\u0026#34; to \u0026#34;dest\u0026#34; logger. Format(dest io.Writer, log *Log) bool } 要更改每个级别的输出和格式：\napp.Logger().SetLevelOutput(\u0026#34;error\u0026#34;, os.Stderr) app.Logger().SetLevelFormat(\u0026#34;json\u0026#34;) 请求日志记录 我们在上面看到的应用程序记录器用于记录与应用程序相关的信息和错误。另一方面，我们在下面看到的访问记录器用于记录传入的HTTP请求和响应。\npackage main import ( \u0026#34;os\u0026#34; \u0026#34;github.com/kataras/iris/v12\u0026#34; \u0026#34;github.com/kataras/iris/v12/middleware/accesslog\u0026#34; ) // Read the example and its comments carefully. func makeAccessLog() *accesslog.AccessLog { // Initialize a new access log middleware. ac := accesslog.File(\u0026#34;./access.log\u0026#34;) // Remove this line to disable logging to console: ac.AddOutput(os.Stdout) // The default configuration: ac.Delim = \u0026#39;|\u0026#39; ac.TimeFormat = \u0026#34;2006-01-02 15:04:05\u0026#34; ac.Async = false ac.IP = true ac.BytesReceivedBody = true ac.BytesSentBody = true ac.BytesReceived = false ac.BytesSent = false ac.BodyMinify = true ac.RequestBody = true ac.ResponseBody = false ac.KeepMultiLineError = true ac.PanicLog = accesslog.LogHandler // Default line format if formatter is missing: // Time|Latency|Code|Method|Path|IP|Path Params Query Fields|Bytes Received|Bytes Sent|Request|Response| // // Set Custom Formatter: ac.SetFormatter(\u0026amp;accesslog.JSON{ Indent: \u0026#34; \u0026#34;, HumanTime: true, }) // ac.SetFormatter(\u0026amp;accesslog.CSV{}) // ac.SetFormatter(\u0026amp;accesslog.Template{Text: \u0026#34;{{.Code}}\u0026#34;}) return ac } func main() { ac := makeAccessLog() defer ac.Close() // Close the underline file. app := iris.New() // Register the middleware (UseRouter to catch http errors too). app.UseRouter(ac.Handler) app.Get(\u0026#34;/\u0026#34;, indexHandler) app.Listen(\u0026#34;:8080\u0026#34;) } func indexHandler(ctx iris.Context) { ctx.WriteString(\u0026#34;OK\u0026#34;) } 阅读更多示例：_examples/logging/request-logger。\n(adsbygoogle = window.adsbygoogle || []).push({});\n模型绑定和验证 若要将请求正文绑定到类型中，请使用模型绑定。我们目前支持绑定、、、、和标准表单值（foo=bar\u0026amp;boo=baz）。JSON``JSONProtobuf``Protobuf``MsgPack``XML``YAML\nReadJSON(outPtr interface{}) error ReadJSONProtobuf(ptr proto.Message, opts ...ProtoUnmarshalOptions) error ReadProtobuf(ptr proto.Message) error ReadMsgPack(ptr interface{}) error ReadXML(outPtr interface{}) error ReadYAML(outPtr interface{}) error ReadForm(formObject interface{}) error ReadQuery(ptr interface{}) error 使用 时，Iris 会尝试根据内容类型标头推断绑定程序。如果您确定要绑定的内容，则可以使用特定方法，例如 或和等ReadBody``ReadXXX``ReadJSON``ReadProtobuf\nReadBody(ptr interface{}) error 明智的是，Iris没有内置的数据验证功能。但是，它确实允许您附加一个验证器，该验证器将自动调用诸如 ， \u0026hellip;.在这个例子中，我们将学习如何使用 go-playground/validator/v10 进行请求正文验证。ReadJSON``ReadXML\n请注意，您需要在要绑定的所有字段上设置相应的绑定标记。例如，从 JSON 绑定时，设置 .json:\u0026quot;fieldname\u0026quot;\n您还可以指定特定字段为必填字段。如果字段在绑定时用空值修饰，并且值为空，则会返回错误。binding:\u0026quot;required\u0026quot;\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/kataras/iris/v12\u0026#34; \u0026#34;github.com/go-playground/validator/v10\u0026#34; ) func main() { app := iris.New() app.Validator = validator.New() userRouter := app.Party(\u0026#34;/user\u0026#34;) { userRouter.Get(\u0026#34;/validation-errors\u0026#34;, resolveErrorsDocumentation) userRouter.Post(\u0026#34;/\u0026#34;, postUser) } app.Listen(\u0026#34;:8080\u0026#34;) } // User contains user information. type User struct { FirstName string `json:\u0026#34;fname\u0026#34; validate:\u0026#34;required\u0026#34;` LastName string `json:\u0026#34;lname\u0026#34; validate:\u0026#34;required\u0026#34;` Age uint8 `json:\u0026#34;age\u0026#34; validate:\u0026#34;gte=0,lte=130\u0026#34;` Email string `json:\u0026#34;email\u0026#34; validate:\u0026#34;required,email\u0026#34;` FavouriteColor string `json:\u0026#34;favColor\u0026#34; validate:\u0026#34;hexcolor|rgb|rgba\u0026#34;` Addresses []*Address `json:\u0026#34;addresses\u0026#34; validate:\u0026#34;required,dive,required\u0026#34;` } // Address houses a users address information. type Address struct { Street string `json:\u0026#34;street\u0026#34; validate:\u0026#34;required\u0026#34;` City string `json:\u0026#34;city\u0026#34; validate:\u0026#34;required\u0026#34;` Planet string `json:\u0026#34;planet\u0026#34; validate:\u0026#34;required\u0026#34;` Phone string `json:\u0026#34;phone\u0026#34; validate:\u0026#34;required\u0026#34;` } type validationError struct { ActualTag string `json:\u0026#34;tag\u0026#34;` Namespace string `json:\u0026#34;namespace\u0026#34;` Kind string `json:\u0026#34;kind\u0026#34;` Type string `json:\u0026#34;type\u0026#34;` Value string `json:\u0026#34;value\u0026#34;` Param string `json:\u0026#34;param\u0026#34;` } func wrapValidationErrors(errs validator.ValidationErrors) []validationError { validationErrors := make([]validationError, 0, len(errs)) for _, validationErr := range errs { validationErrors = append(validationErrors, validationError{ ActualTag: validationErr.ActualTag(), Namespace: validationErr.Namespace(), Kind: validationErr.Kind().String(), Type: validationErr.Type().String(), Value: fmt.Sprintf(\u0026#34;%v\u0026#34;, validationErr.Value()), Param: validationErr.Param(), }) } return validationErrors } func postUser(ctx iris.Context) { var user User err := ctx.ReadJSON(\u0026amp;user) if err != nil { // Handle the error, below you will find the right way to do that... if errs, ok := err.(validator.ValidationErrors); ok { // Wrap the errors with JSON format, the underline library returns the errors as interface. validationErrors := wrapValidationErrors(errs) // Fire an application/json+problem response and stop the handlers chain. ctx.StopWithProblem(iris.StatusBadRequest, iris.NewProblem(). Title(\u0026#34;Validation error\u0026#34;). Detail(\u0026#34;One or more fields failed to be validated\u0026#34;). Type(\u0026#34;/user/validation-errors\u0026#34;). Key(\u0026#34;errors\u0026#34;, validationErrors)) return } // It\u0026#39;s probably an internal JSON error, let\u0026#39;s dont give more info here. ctx.StopWithStatus(iris.StatusInternalServerError) return } ctx.JSON(iris.Map{\u0026#34;message\u0026#34;: \u0026#34;OK\u0026#34;}) } func resolveErrorsDocumentation(ctx iris.Context) { ctx.WriteString(\u0026#34;A page that should document to web developers or users of the API on how to resolve the validation errors\u0026#34;) } 样品请求\n{ \u0026#34;fname\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;lname\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;age\u0026#34;: 45, \u0026#34;email\u0026#34;: \u0026#34;mail@example.com\u0026#34;, \u0026#34;favColor\u0026#34;: \u0026#34;#000\u0026#34;, \u0026#34;addresses\u0026#34;: [{ \u0026#34;street\u0026#34;: \u0026#34;Eavesdown Docks\u0026#34;, \u0026#34;planet\u0026#34;: \u0026#34;Persphone\u0026#34;, \u0026#34;phone\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;Unknown\u0026#34; }] } 示例响应\n{ \u0026#34;title\u0026#34;: \u0026#34;Validation error\u0026#34;, \u0026#34;detail\u0026#34;: \u0026#34;One or more fields failed to be validated\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;http://localhost:8080/user/validation-errors\u0026#34;, \u0026#34;status\u0026#34;: 400, \u0026#34;fields\u0026#34;: [ { \u0026#34;tag\u0026#34;: \u0026#34;required\u0026#34;, \u0026#34;namespace\u0026#34;: \u0026#34;User.FirstName\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;param\u0026#34;: \u0026#34;\u0026#34; }, { \u0026#34;tag\u0026#34;: \u0026#34;required\u0026#34;, \u0026#34;namespace\u0026#34;: \u0026#34;User.LastName\u0026#34;, \u0026#34;kind\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;param\u0026#34;: \u0026#34;\u0026#34; } ] } 有关模型验证的更多信息，请访问：https://github.com/go-playground/validator/blob/master/_examples\n绑定查询字符串 该方法仅绑定查询参数，而不绑定帖子数据，而是用于绑定帖子数据。ReadQuery``ReadForm\npackage main import \u0026#34;github.com/kataras/iris/v12\u0026#34; type Person struct { Name string `url:\u0026#34;name,required\u0026#34;` Address string `url:\u0026#34;address\u0026#34;` } func main() { app := iris.Default() app.Any(\u0026#34;/\u0026#34;, index) app.Listen(\u0026#34;:8080\u0026#34;) } func index(ctx iris.Context) { var person Person if err := ctx.ReadQuery(\u0026amp;person); err!=nil { ctx.StopWithError(iris.StatusBadRequest, err) return } ctx.Application().Logger().Infof(\u0026#34;Person: %#+v\u0026#34;, person) ctx.WriteString(\u0026#34;Success\u0026#34;) } 绑定任何 根据客户端发送数据的内容类型将请求正文绑定到“ptr”，例如 JSON、XML、YAML、MessagePack、Protobuf、Form 和 URL Query。\npackage main import ( \u0026#34;time\u0026#34; \u0026#34;github.com/kataras/iris/v12\u0026#34; ) type Person struct { Name string `form:\u0026#34;name\u0026#34; json:\u0026#34;name\u0026#34; url:\u0026#34;name\u0026#34; msgpack:\u0026#34;name\u0026#34;` Address string `form:\u0026#34;address\u0026#34; json:\u0026#34;address\u0026#34; url:\u0026#34;address\u0026#34; msgpack:\u0026#34;address\u0026#34;` Birthday time.Time `form:\u0026#34;birthday\u0026#34; time_format:\u0026#34;2006-01-02\u0026#34; time_utc:\u0026#34;1\u0026#34; json:\u0026#34;birthday\u0026#34; url:\u0026#34;birthday\u0026#34; msgpack:\u0026#34;birthday\u0026#34;` CreateTime time.Time `form:\u0026#34;createTime\u0026#34; time_format:\u0026#34;unixNano\u0026#34; json:\u0026#34;create_time\u0026#34; url:\u0026#34;create_time\u0026#34; msgpack:\u0026#34;createTime\u0026#34;` UnixTime time.Time `form:\u0026#34;unixTime\u0026#34; time_format:\u0026#34;unix\u0026#34; json:\u0026#34;unix_time\u0026#34; url:\u0026#34;unix_time\u0026#34; msgpack:\u0026#34;unixTime\u0026#34;` } func main() { app := iris.Default() app.Any(\u0026#34;/\u0026#34;, index) app.Listen(\u0026#34;:8080\u0026#34;) } func index(ctx iris.Context) { var person Person if err := ctx.ReadBody(\u0026amp;person); err!=nil { ctx.StopWithError(iris.StatusBadRequest, err) return } ctx.Application().Logger().Infof(\u0026#34;Person: %#+v\u0026#34;, person) ctx.WriteString(\u0026#34;Success\u0026#34;) } 测试它：\n$ curl -X GET \u0026#34;localhost:8085/testing?name=kataras\u0026amp;address=xyz\u0026amp;birthday=1992-03-15\u0026amp;createTime=1562400033000000123\u0026amp;unixTime=1562400033\u0026#34; 绑定网址路径参数 package main import \u0026#34;github.com/kataras/iris/v12\u0026#34; type myParams struct { Name string `param:\u0026#34;name\u0026#34;` Age int `param:\u0026#34;age\u0026#34;` Tail []string `param:\u0026#34;tail\u0026#34;` } // All parameters are required, as we already know, // the router will fire 404 if name or int or tail are missing. func main() { app := iris.Default() app.Get(\u0026#34;/{name}/{age:int}/{tail:path}\u0026#34;, func(ctx iris.Context) { var p myParams if err := ctx.ReadParams(\u0026amp;p); err != nil { ctx.StopWithError(iris.StatusInternalServerError, err) return } ctx.Writef(\u0026#34;myParams: %#v\u0026#34;, p) }) app.Listen(\u0026#34;:8088\u0026#34;) } 请求\n$ curl -v http://localhost:8080/kataras/27/iris/web/framework (adsbygoogle = window.adsbygoogle || []).push({});\n绑定标头 package main import \u0026#34;github.com/kataras/iris/v12\u0026#34; type myHeaders struct { RequestID string `header:\u0026#34;X-Request-Id,required\u0026#34;` Authentication string `header:\u0026#34;Authentication,required\u0026#34;` } func main() { app := iris.Default() r.GET(\u0026#34;/\u0026#34;, func(ctx iris.Context) { var hs myHeaders if err := ctx.ReadHeaders(\u0026amp;hs); err != nil { ctx.StopWithError(iris.StatusInternalServerError, err) return } ctx.JSON(hs) }) app.Listen(\u0026#34;:8080\u0026#34;) } 请求\ncurl -H \u0026#34;x-request-id:373713f0-6b4b-42ea-ab9f-e2e04bc38e73\u0026#34; -H \u0026#34;authentication: Bearer my-token\u0026#34; \\ http://localhost:8080 响应\n{ \u0026#34;RequestID\u0026#34;: \u0026#34;373713f0-6b4b-42ea-ab9f-e2e04bc38e73\u0026#34;, \u0026#34;Authentication\u0026#34;: \u0026#34;Bearer my-token\u0026#34; } “绑定 HTML ”复选框 package main import \u0026#34;github.com/kataras/iris/v12\u0026#34; func main() { app := iris.New() app.RegisterView(iris.HTML(\u0026#34;./templates\u0026#34;, \u0026#34;.html\u0026#34;)) app.Get(\u0026#34;/\u0026#34;, showForm) app.Post(\u0026#34;/\u0026#34;, handleForm) app.Listen(\u0026#34;:8080\u0026#34;) } func showForm(ctx iris.Context) { if err := ctx.View(\u0026#34;form.html\u0026#34;); err!=nil { ctx.HTML(\u0026#34;\u0026lt;h3\u0026gt;%s\u0026lt;/h3\u0026gt;\u0026#34;, err.Error()) return } } type formExample struct { Colors []string `form:\u0026#34;colors[]\u0026#34;` // or just \u0026#34;colors\u0026#34;. } func handleForm(ctx iris.Context) { var form formExample err := ctx.ReadForm(\u0026amp;form) if err != nil { ctx.StopWithError(iris.StatusBadRequest, err) return } ctx.JSON(iris.Map{\u0026#34;Colors\u0026#34;: form.Colors}) } templates/form.html\n\u0026lt;form action=\u0026#34;/\u0026#34; method=\u0026#34;POST\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Check one or more colors\u0026lt;/p\u0026gt; \u0026lt;label for=\u0026#34;red\u0026#34;\u0026gt;Red\u0026lt;/label\u0026gt; \u0026lt;!-- name can be \u0026#34;colors\u0026#34; too --\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;colors[]\u0026#34; value=\u0026#34;red\u0026#34; id=\u0026#34;red\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;green\u0026#34;\u0026gt;Green\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;colors[]\u0026#34; value=\u0026#34;green\u0026#34; id=\u0026#34;green\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;blue\u0026#34;\u0026gt;Blue\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;colors[]\u0026#34; value=\u0026#34;blue\u0026#34; id=\u0026#34;blue\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 响应\n{ \u0026#34;Colors\u0026#34;: [ \u0026#34;red\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;blue\u0026#34; ] } JSON、JSONP、XML、Markdown、YAML 和 MsgPack 渲染 详细示例可在此处找到。\nfunc main() { app := iris.New() // iris.Map is an alias of map[string]interface{} app.Get(\u0026#34;/json\u0026#34;, func(ctx iris.Context) { ctx.JSON(iris.Map{\u0026#34;message\u0026#34;: \u0026#34;hello\u0026#34;, \u0026#34;status\u0026#34;: iris.StatusOK}) }) // Use Secure field to prevent json hijacking. // It prepends `\u0026#34;while(1),\u0026#34;` to the body when the data is array. app.Get(\u0026#34;/json_secure\u0026#34;, func(ctx iris.Context) { response := []string{\u0026#34;val1\u0026#34;, \u0026#34;val2\u0026#34;, \u0026#34;val3\u0026#34;} options := iris.JSON{Indent: \u0026#34;\u0026#34;, Secure: true} ctx.JSON(response, options) // Will output: while(1);[\u0026#34;val1\u0026#34;,\u0026#34;val2\u0026#34;,\u0026#34;val3\u0026#34;] }) // Use ASCII field to generate ASCII-only JSON // with escaped non-ASCII characters. app.Get(\u0026#34;/json_ascii\u0026#34;, func(ctx iris.Context) { response := iris.Map{\u0026#34;lang\u0026#34;: \u0026#34;GO-虹膜\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;\u0026lt;br\u0026gt;\u0026#34;} options := iris.JSON{Indent: \u0026#34; \u0026#34;, ASCII: true} ctx.JSON(response, options) /* Will output: { \u0026#34;lang\u0026#34;: \u0026#34;GO-\\u8679\\u819c\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;\\u003cbr\\u003e\u0026#34; } */ }) // Normally, JSON replaces special HTML characters with their unicode entities. // If you want to encode such characters literally, // you SHOULD set the UnescapeHTML field to true. app.Get(\u0026#34;/json_raw\u0026#34;, func(ctx iris.Context) { options := iris.JSON{UnescapeHTML: true} ctx.JSON(iris.Map{ \u0026#34;html\u0026#34;: \u0026#34;\u0026lt;b\u0026gt;Hello, world!\u0026lt;/b\u0026gt;\u0026#34;, }, options) // Will output: {\u0026#34;html\u0026#34;:\u0026#34;\u0026lt;b\u0026gt;Hello, world!\u0026lt;/b\u0026gt;\u0026#34;} }) app.Get(\u0026#34;/json_struct\u0026#34;, func(ctx iris.Context) { // You also can use a struct. var msg struct { Name string `json:\u0026#34;user\u0026#34;` Message string Number int } msg.Name = \u0026#34;Mariah\u0026#34; msg.Message = \u0026#34;hello\u0026#34; msg.Number = 42 // Note that msg.Name becomes \u0026#34;user\u0026#34; in the JSON. // Will output: {\u0026#34;user\u0026#34;: \u0026#34;Mariah\u0026#34;, \u0026#34;Message\u0026#34;: \u0026#34;hello\u0026#34;, \u0026#34;Number\u0026#34;: 42} ctx.JSON(msg) }) app.Get(\u0026#34;/jsonp\u0026#34;, func(ctx iris.Context) { ctx.JSONP(iris.Map{\u0026#34;hello\u0026#34;: \u0026#34;jsonp\u0026#34;}, iris.JSONP{Callback: \u0026#34;callbackName\u0026#34;}) }) app.Get(\u0026#34;/xml\u0026#34;, func(ctx iris.Context) { ctx.XML(iris.Map{\u0026#34;message\u0026#34;: \u0026#34;hello\u0026#34;, \u0026#34;status\u0026#34;: iris.StatusOK}) }) app.Get(\u0026#34;/markdown\u0026#34;, func(ctx iris.Context) { ctx.Markdown([]byte(\u0026#34;# Hello Dynamic Markdown -- iris\u0026#34;)) }) app.Get(\u0026#34;/yaml\u0026#34;, func(ctx iris.Context) { ctx.YAML(iris.Map{\u0026#34;message\u0026#34;: \u0026#34;hello\u0026#34;, \u0026#34;status\u0026#34;: iris.StatusOK}) }) app.Get(\u0026#34;/msgpack\u0026#34;, func(ctx iris.Context) { u := User{ Firstname: \u0026#34;John\u0026#34;, Lastname: \u0026#34;Doe\u0026#34;, City: \u0026#34;Neither FBI knows!!!\u0026#34;, Age: 25, } ctx.MsgPack(u) }) // Render using jsoniter instead of the encoding/json: app.Listen(\u0026#34;:8080\u0026#34;, iris.WithOptimizations) } 普罗托布夫 Iris 支持原生 protobuf with 和 protobuf to JSON 编码和解码。Protobuf\npackage main import ( \u0026#34;app/protos\u0026#34; \u0026#34;github.com/kataras/iris/v12\u0026#34; ) func main() { app := iris.New() app.Get(\u0026#34;/\u0026#34;, send) app.Get(\u0026#34;/json\u0026#34;, sendAsJSON) app.Post(\u0026#34;/read\u0026#34;, read) app.Post(\u0026#34;/read_json\u0026#34;, readFromJSON) app.Listen(\u0026#34;:8080\u0026#34;) } func send(ctx iris.Context) { response := \u0026amp;protos.HelloReply{Message: \u0026#34;Hello, World!\u0026#34;} ctx.Protobuf(response) } func sendAsJSON(ctx iris.Context) { response := \u0026amp;protos.HelloReply{Message: \u0026#34;Hello, World!\u0026#34;} options := iris.JSON{ Proto: iris.ProtoMarshalOptions{ AllowPartial: true, Multiline: true, Indent: \u0026#34; \u0026#34;, }, } ctx.JSON(response, options) } func read(ctx iris.Context) { var request protos.HelloRequest err := ctx.ReadProtobuf(\u0026amp;request) if err != nil { ctx.StopWithError(iris.StatusBadRequest, err) return } ctx.Writef(\u0026#34;HelloRequest.Name = %s\u0026#34;, request.Name) } func readFromJSON(ctx iris.Context) { var request protos.HelloRequest err := ctx.ReadJSONProtobuf(\u0026amp;request) if err != nil { ctx.StopWithError(iris.StatusBadRequest, err) return } ctx.Writef(\u0026#34;HelloRequest.Name = %s\u0026#34;, request.Name) } 提供静态文件 func main() { app := iris.New() app.Favicon(\u0026#34;./resources/favicon.ico\u0026#34;) app.HandleDir(\u0026#34;/assets\u0026#34;, iris.Dir(\u0026#34;./assets\u0026#34;)) app.Listen(\u0026#34;:8080\u0026#34;) } 该方法接受第三个可选参数：HandleDir``DirOptions\ntype DirOptions struct { // Defaults to \u0026#34;/index.html\u0026#34;, if request path is ending with **/*/$IndexName // then it redirects to **/*(/) which another handler is handling it, // that another handler, called index handler, is auto-registered by the framework // if end developer does not managed to handle it by hand. IndexName string // PushTargets filenames (map\u0026#39;s value) to // be served without additional client\u0026#39;s requests (HTTP/2 Push) // when a specific request path (map\u0026#39;s key WITHOUT prefix) // is requested and it\u0026#39;s not a directory (it\u0026#39;s an `IndexFile`). // // Example: // \u0026#34;/\u0026#34;: { // \u0026#34;favicon.ico\u0026#34;, // \u0026#34;js/main.js\u0026#34;, // \u0026#34;css/main.css\u0026#34;, // } PushTargets map[string][]string // PushTargetsRegexp like `PushTargets` but accepts regexp which // is compared against all files under a directory (recursively). // The `IndexName` should be set. // // Example: // \u0026#34;/\u0026#34;: regexp.MustCompile(\u0026#34;((.*).js|(.*).css|(.*).ico)$\u0026#34;) // See `iris.MatchCommonAssets` too. PushTargetsRegexp map[string]*regexp.Regexp // Cache to enable in-memory cache and pre-compress files. Cache DirCacheOptions // When files should served under compression. Compress bool // List the files inside the current requested directory if `IndexName` not found. ShowList bool // If `ShowList` is true then this function will be used instead // of the default one to show the list of files of a current requested directory(dir). // See `DirListRich` package-level function too. DirList DirListFunc // Files downloaded and saved locally. Attachments Attachments // Optional validator that loops through each requested resource. AssetValidator func(ctx *context.Context, name string) bool } 详细了解文件服务器。\n(adsbygoogle = window.adsbygoogle || []).push({});\n从上下文中提供数据 SendFile(filename string, destinationName string) error SendFileWithRate(src, destName string, limit float64, burst int) error 用法\n强制将文件发送到客户端：\nfunc handler(ctx iris.Context) { src := \u0026#34;./files/first.zip\u0026#34; ctx.SendFile(src, \u0026#34;client.zip\u0026#34;) } 将下载速度限制为 ~50Kb/s，突发 100KB：\nfunc handler(ctx iris.Context) { src := \u0026#34;./files/big.zip\u0026#34; // optionally, keep it empty to resolve the filename based on the \u0026#34;src\u0026#34;. dest := \u0026#34;\u0026#34; limit := 50.0 * iris.KB burst := 100 * iris.KB ctx.SendFileWithRate(src, dest, limit, burst) } ServeContent(content io.ReadSeeker, filename string, modtime time.Time) ServeContentWithRate(content io.ReadSeeker, filename string, modtime time.Time, limit float64, burst int) ServeFile(filename string) error ServeFileWithRate(filename string, limit float64, burst int) error 用法\nfunc handler(ctx iris.Context) { ctx.ServeFile(\u0026#34;./public/main.js\u0026#34;) } 模板渲染 Iris开箱即用支持8个模板引擎，开发者仍然可以使用任何外部golang模板引擎， 就像一个.Context.ResponseWriter()``io.Writer\n所有模板引擎共享一个通用 API，即 使用嵌入资源、布局和特定于参与方的布局、模板功能、部分渲染等进行解析。\n# 名字 解析 器 1 .HTML 网页/模板 2 块 卡塔拉斯/方块 3 姜戈 弗洛施/蓬戈2 4 帕格 小丑/翡翠 5 车把 艾默里克/雷蒙德 6 琥珀 eknkc/琥珀色 7 噴氣機 云套件/喷气机 8 高手 约西/艾斯 示例列表。\n基准列表。\n视图引擎可以按缔约方注册。要注册视图引擎，请使用如下所示的方法。Application/Party.RegisterView(ViewEngine)\n从扩展名为“.html”的“./views”文件夹中加载所有模板，并使用标准包解析它们。html/template\n// [app := iris.New...] tmpl := iris.HTML(\u0026#34;./views\u0026#34;, \u0026#34;.html\u0026#34;) app.RegisterView(tmpl) 若要呈现或执行视图，请使用主路由处理程序中的方法。Context.View\nif err := ctx.View(\u0026#34;hi.html\u0026#34;); err!=nil { ctx.HTML(\u0026#34;\u0026lt;h3\u0026gt;%s\u0026lt;/h3\u0026gt;\u0026#34;, err.Error()) return } 要通过中间件或主处理程序在视图中将 Go 值与键值模式绑定，请使用 go 值之前的方法。Context.ViewData``Context.View\n绑定：与 .{{.message}}``\u0026quot;Hello world!\u0026quot;\nctx.ViewData(\u0026#34;message\u0026#34;, \u0026#34;Hello world!\u0026#34;) 根绑定：\nif err := ctx.View(\u0026#34;user-page.html\u0026#34;, User{}); err!=nil { ctx.HTML(\u0026#34;\u0026lt;h3\u0026gt;%s\u0026lt;/h3\u0026gt;\u0026#34;, err.Error()) return } // root binding as {{.Name}} 要**添加模板函数，**请使用首选视图引擎的方法。AddFunc\n// func name, input arguments, render value tmpl.AddFunc(\u0026#34;greet\u0026#34;, func(s string) string { return \u0026#34;Greetings \u0026#34; + s + \u0026#34;!\u0026#34; }) 要在每个请求上重新加载，请调用视图引擎的方法。Reload\ntmpl.Reload(true) 要使用嵌入式模板而不依赖于本地文件系统，请使用 go-bindata 外部工具，并将其生成的函数传递给首选视图引擎的第一个输入参数。AssetFile()\ntmpl := iris.HTML(AssetFile(), \u0026#34;.html\u0026#34;) 示例代码：\n// file: main.go package main import \u0026#34;github.com/kataras/iris/v12\u0026#34; func main() { app := iris.New() // Parse all templates from the \u0026#34;./views\u0026#34; folder // where extension is \u0026#34;.html\u0026#34; and parse them // using the standard `html/template` package. tmpl := iris.HTML(\u0026#34;./views\u0026#34;, \u0026#34;.html\u0026#34;) // Set custom delimeters. tmpl.Delims(\u0026#34;{{\u0026#34;, \u0026#34;}}\u0026#34;) // Enable re-build on local template files changes. tmpl.Reload(true) // Default template funcs are: // // - {{ urlpath \u0026#34;myNamedRoute\u0026#34; \u0026#34;pathParameter_ifNeeded\u0026#34; }} // - {{ render \u0026#34;header.html\u0026#34; . }} // and partial relative path to current page: // - {{ render_r \u0026#34;header.html\u0026#34; . }} // - {{ yield . }} // - {{ current }} // Register a custom template func: tmpl.AddFunc(\u0026#34;greet\u0026#34;, func(s string) string { return \u0026#34;Greetings \u0026#34; + s + \u0026#34;!\u0026#34; }) // Register the view engine to the views, // this will load the templates. app.RegisterView(tmpl) // Method: GET // Resource: http://localhost:8080 app.Get(\u0026#34;/\u0026#34;, func(ctx iris.Context) { // Bind: {{.message}} with \u0026#34;Hello world!\u0026#34; ctx.ViewData(\u0026#34;message\u0026#34;, \u0026#34;Hello world!\u0026#34;) // Render template file: ./views/hi.html if err := ctx.View(\u0026#34;hi.html\u0026#34;); err!=nil { ctx.HTML(\u0026#34;\u0026lt;h3\u0026gt;%s\u0026lt;/h3\u0026gt;\u0026#34;, err.Error()) return } }) app.Listen(\u0026#34;:8080\u0026#34;) } \u0026lt;!-- file: ./views/hi.html --\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Hi Page\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;{{.message}}\u0026lt;/h1\u0026gt; \u0026lt;strong\u0026gt;{{greet \u0026#34;to you\u0026#34;}}\u0026lt;/strong\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在 http://localhost:8080 处打开浏览器选项卡。\n渲染的结果将如下所示：\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Hi Page\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello world!\u0026lt;/h1\u0026gt; \u0026lt;strong\u0026gt;Greetings to you!\u0026lt;/strong\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 多模板 Iris 允许每个应用程序注册无限数量的视图引擎。除此之外，您还可以为每个派对或通过中间件注册一个视图引擎！\n// Register a view engine per group of routes. adminGroup := app.Party(\u0026#34;/admin\u0026#34;) adminGroup.RegisterView(iris.Blocks(\u0026#34;./views/admin\u0026#34;, \u0026#34;.html\u0026#34;)) 通过中间件 func middleware(views iris.ViewEngine) iris.Handler { return func(ctx iris.Context) { ctx.ViewEngine(views) ctx.Next() } } 用法\n// Register a view engine on-fly for the current chain of handlers. views := iris.Blocks(\u0026#34;./views/on-fly\u0026#34;, \u0026#34;.html\u0026#34;) views.Load() app.Get(\u0026#34;/\u0026#34;, setViews(views), onFly) 重 定向 发出 HTTP 重定向很容易。支持内部和外部位置。我们所说的位置是指路径、子域、域等。\n从处理程序 app.Get(\u0026#34;/\u0026#34;, func(ctx iris.Context) { ctx.Redirect(\u0026#34;https://go.dev/dl\u0026#34;, iris.StatusMovedPermanently) }) 从开机自检发出 HTTP 重定向。\napp.Post(\u0026#34;/\u0026#34;, func(ctx iris.Context) { ctx.Redirect(\u0026#34;/login\u0026#34;, iris.StatusFound) }) 从处理程序发出本地路由器重定向，使用或类似如下。Application.ServeHTTPC``Exec()\napp.Get(\u0026#34;/test\u0026#34;, func(ctx iris.Context) { r := ctx.Request() r.URL.Path = \u0026#34;/test2\u0026#34; ctx.Application().ServeHTTPC(ctx) // OR // ctx.Exec(\u0026#34;GET\u0026#34;, \u0026#34;/test2\u0026#34;) }) app.Get(\u0026#34;/test2\u0026#34;, func(ctx iris.Context) { ctx.JSON(iris.Map{\u0026#34;hello\u0026#34;: \u0026#34;world\u0026#34;}) }) 全球 使用我们都喜欢的语法。\nimport \u0026#34;github.com/kataras/iris/v12/middleware/rewrite\u0026#34; func main() { app := iris.New() // [...routes] redirects := rewrite.Load(\u0026#34;redirects.yml\u0026#34;) app.WrapRouter(redirects) app.Listen(\u0026#34;:80\u0026#34;) } 该文件如下所示：\u0026quot;redirects.yml\u0026quot;\nRedirectMatch: # Redirects /seo/* to /* - 301 /seo/(.*) /$1 # Redirects /docs/v12* to /docs - 301 /docs/v12(.*) /docs # Redirects /old(.*) to / - 301 /old(.*) / # Redirects http or https://test.* to http or https://newtest.* - 301 ^(http|https)://test.(.*) $1://newtest.$2 # Handles /*.json or .xml as *?format=json or xml, # without redirect. See /users route. # When Code is 0 then it does not redirect the request, # instead it changes the request URL # and leaves a route handle the request. - 0 /(.*).(json|xml) /$1?format=$2 # Redirects root domain to www. # Creation of a www subdomain inside the Application is unnecessary, # all requests are handled by the root Application itself. PrimarySubdomain: www 完整的代码可以在重写中间件示例中找到。\n自定义中间件 func Logger() iris.Handler { return func(ctx iris.Context) { t := time.Now() // Set a shared variable between handlers ctx.Values().Set(\u0026#34;framework\u0026#34;, \u0026#34;iris\u0026#34;) // before request ctx.Next() // after request latency := time.Since(t) log.Print(latency) // access the status we are sending status := ctx.GetStatusCode() log.Println(status) } } func main() { app := iris.New() app.Use(Logger()) app.Get(\u0026#34;/test\u0026#34;, func(ctx iris.Context) { // retrieve a value set by the middleware. framework := ctx.Values().GetString(\u0026#34;framework\u0026#34;) // it would print: \u0026#34;iris\u0026#34; log.Println(framework) }) app.Listen(\u0026#34;:8080\u0026#34;) } (adsbygoogle = window.adsbygoogle || []).push({});\n使用基本身份验证 HTTP 基本身份验证是对 Web 资源实施访问控制的最简单技术，因为它不需要 Cookie、会话标识符或登录页面;相反，HTTP 基本身份验证使用 HTTP 标头中的标准字段。\n基本身份验证中间件包含在 Iris 框架中，因此无需单独安装。\n1. 导入中间件\nimport \u0026#34;github.com/kataras/iris/v12/middleware/basicauth\u0026#34; 2. 使用其结构配置中间件：Options\nopts := basicauth.Options{ Allow: basicauth.AllowUsers(map[string]string{ \u0026#34;username\u0026#34;: \u0026#34;password\u0026#34;, }), Realm: \u0026#34;Authorization Required\u0026#34;, ErrorHandler: basicauth.DefaultErrorHandler, // [...more options] } 3. 初始化中间件：\nauth := basicauth.New(opts) 3.1 以上步骤与函数相同：Default\nauth := basicauth.Default(map[string]string{ \u0026#34;username\u0026#34;: \u0026#34;password\u0026#34;, }) 3.2 使用自定义用户切片：\n// The struct value MUST contain a Username and Passwords fields // or GetUsername() string and GetPassword() string methods. type User struct { Username string Password string } // [...] auth := basicauth.Default([]User{...}) 3.3 从文件加载用户 或者，密码使用 pkg.go.dev/golang.org/x/crypto/bcrypt 包进行加密：\nauth := basicauth.Load(\u0026#34;users.yml\u0026#34;, basicauth.BCRYPT) 3.3.1 使用（推荐）也可以实现相同的目的：Options\nopts := basicauth.Options{ Allow: basicauth.AllowUsersFile(\u0026#34;users.yml\u0026#34;, basicauth.BCRYPT), Realm: basicauth.DefaultRealm, // [...more options] } auth := basicauth.New(opts) 其中可能看起来像这样：users.yml\n- username: kataras password: $2a$10$Irg8k8HWkDlvL0YDBKLCYee6j6zzIFTplJcvZYKA.B8/clHPZn2Ey # encrypted of kataras_pass role: admin - username: makis password: $2a$10$3GXzp3J5GhHThGisbpvpZuftbmzPivDMo94XPnkTnDe7254x7sJ3O # encrypted of makis_pass role: member 4. 注册中间件：\n// Register to all matched routes // under a Party and its children. app.Use(auth) // OR/and register to all http error routes. app.UseError(auth) // OR register under a path prefix of a specific Party, // including all http errors of this path prefix. app.UseRouter(auth) // OR register to a specific Route before its main handler. app.Post(\u0026#34;/protected\u0026#34;, auth, routeHandler) 5. 检索用户名和密码：\nfunc routeHandler(ctx iris.Context) { username, password, _ := ctx.Request().BasicAuth() // [...] } 5.1 检索 User 值（当您在以下位置注册自定义用户结构的一部分时很有用）：Options.AllowUsers\nfunc routeHandler(ctx iris.Context) { user := ctx.User().(*iris.SimpleUser) // user.Username // user.Password } 在 _examples/auth 中阅读更多授权和身份验证示例。\n中间件中的 Goroutines 在中间件或处理程序中启动新的 Goroutines 时，您不应该使用其中的原始上下文，您必须使用只读副本。\nfunc main() { app := iris.Default() app.Get(\u0026#34;/long_async\u0026#34;, func(ctx iris.Context) { // create a clone to be used inside the goroutine ctxCopy := ctx.Clone() go func() { // simulate a long task with time.Sleep(). 5 seconds time.Sleep(5 * time.Second) // note that you are using the copied context \u0026#34;ctxCopy\u0026#34;, IMPORTANT log.Printf(\u0026#34;Done! in path: %s\u0026#34;, ctxCopy.Path()) }() }) app.Get(\u0026#34;/long_sync\u0026#34;, func(ctx iris.Context) { // simulate a long task with time.Sleep(). 5 seconds time.Sleep(5 * time.Second) // since we are NOT using a goroutine, we do not have to copy the context log.Printf(\u0026#34;Done! in path: %s\u0026#34;, ctx.Path()) }) app.Listen(\u0026#34;:8080\u0026#34;) } 自定义 HTTP 配置 在 _examples/http-server 文件夹中可以找到超过 12 个有关 http 服务器配置的示例。\n直接使用，如下所示：http.ListenAndServe()\nfunc main() { app := iris.New() // [...routes] if err := app.Build(); err!=nil{ panic(err) } http.ListenAndServe(\u0026#34;:8080\u0026#34;, app) } 请注意，在将其用作 .Build``http.Handler\n再比如：\nfunc main() { app := iris.New() // [...routes] app.Build() srv := \u0026amp;http.Server{ Addr: \u0026#34;:8080\u0026#34;, Handler: app, ReadTimeout: 10 * time.Second, WriteTimeout: 10 * time.Second, MaxHeaderBytes: 1 \u0026lt;\u0026lt; 20, } srv.ListenAndServe() } 但是，您很少需要具有 IRIS 的外部实例。您可以使用任何 tcp 侦听器、http 服务器或通过方法自定义函数进行侦听。http.Server``Application.Run\napp.Run(iris.Listener(l net.Listener)) // listen using a custom net.Listener app.Run(iris.Server(srv *http.Server)) // listen using a custom http.Server app.Run(iris.Addr(addr string)) // the app.Listen is a shortcut of this method. app.Run(iris.TLS(addr string, certFileOrContents, keyFileOrContents string)) // listen TLS. app.Run(iris.AutoTLS(addr, domain, email string)) // listen using letsencrypt (see below). // and any custom function that returns an error: app.Run(iris.Raw(f func() error)) 套接字分片 此选项允许在多 CPU 服务器上线性扩展服务器性能。有关详细信息，请参阅 https://www.nginx.com/blog/socket-sharding-nginx-release-1-9-1/。使用配置器启用。iris.WithSocketSharding\n示例代码：\npackage main import ( \u0026#34;time\u0026#34; \u0026#34;github.com/kataras/iris/v12\u0026#34; ) func main() { startup := time.Now() app := iris.New() app.Get(\u0026#34;/\u0026#34;, func(ctx iris.Context) { s := startup.Format(ctx.Application().ConfigurationReadOnly().GetTimeFormat()) ctx.Writef(\u0026#34;This server started at: %s\\n\u0026#34;, s) }) app.Listen(\u0026#34;:8080\u0026#34;, iris.WithSocketSharding) // or app.Run(..., iris.WithSocketSharding) } 支持让我们加密 1 行 LetsEncrypt HTTPS 服务器的示例。\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;github.com/iris-gonic/autotls\u0026#34; \u0026#34;github.com/kataras/iris/v12\u0026#34; ) func main() { app := iris.Default() // Ping handler app.Get(\u0026#34;/ping\u0026#34;, func(ctx iris.Context) { ctx.WriteString(\u0026#34;pong\u0026#34;) }) app.Run(iris.AutoTLS(\u0026#34;:443\u0026#34;, \u0026#34;example.com example2.com\u0026#34;, \u0026#34;mail@example.com\u0026#34;)) } 自定义 TLS 示例（您也可以绑定自动证书管理器）：\napp.Run( iris.TLS(\u0026#34;:443\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, func(su *iris.Supervisor) { su.Server.TLSConfig = \u0026amp;tls.Config{ /* your custom fields */ }, }), ) 所有方法（如：Addr，TLS，AutoTLS，Server，Listener和e.t.c）都接受可变参数，以在构建状态上配置http服务器实例。iris.Runner``func(*iris.Supervisor)\n使用鸢尾花运行多个服务 package main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/kataras/iris/v12\u0026#34; \u0026#34;github.com/kataras/iris/v12/middleware/recover\u0026#34; \u0026#34;golang.org/x/sync/errgroup\u0026#34; ) var g errgroup.Group func startApp1() error { app := iris.New().SetName(\u0026#34;app1\u0026#34;) app.Use(recover.New()) app.Get(\u0026#34;/\u0026#34;, func(ctx iris.Context) { app.Get(\u0026#34;/\u0026#34;, func(ctx iris.Context) { ctx.JSON(iris.Map{ \u0026#34;code\u0026#34;: iris.StatusOK, \u0026#34;message\u0026#34;: \u0026#34;Welcome server 1\u0026#34;, }) }) }) app.Build() return app.Listen(\u0026#34;:8080\u0026#34;) } func startApp2() error { app := iris.New().SetName(\u0026#34;app2\u0026#34;) app.Use(recover.New()) app.Get(\u0026#34;/\u0026#34;, func(ctx iris.Context) { ctx.JSON(iris.Map{ \u0026#34;code\u0026#34;: iris.StatusOK, \u0026#34;message\u0026#34;: \u0026#34;Welcome server 2\u0026#34;, }) }) return app.Listen(\u0026#34;:8081\u0026#34;) } func main() { g.Go(startApp1) g.Go(startApp2) if err := g.Wait(); err != nil { log.Fatal(err) } } 通过包管理多个鸢尾花实例。在此处阅读更多内容。apps\n(adsbygoogle = window.adsbygoogle || []).push({});\n正常关机或重启 有几种方法可用于执行正常关机或重新启动。您可以使用专门为此构建的第三方包，也可以使用该方法。可以在此处找到示例。app.Shutdown(context.Context)\n使用 CTRL/CMD+C 在 CTRL/CMD+C 上注册事件：iris.RegisterOnInterrupt\nidleConnsClosed := make(chan struct{}) iris.RegisterOnInterrupt(func() { timeout := 10 * time.Second ctx, cancel := stdContext.WithTimeout(stdContext.Background(), timeout) defer cancel() // close all hosts. app.Shutdown(ctx) close(idleConnsClosed) }) // [...] app.Listen(\u0026#34;:8080\u0026#34;, iris.WithoutInterruptHandler, iris.WithoutServerError(iris.ErrServerClosed)) \u0026lt;-idleConnsClosed 使用模板构建单个二进制文件 您可以使用 [go-bindata][https://github.com/go-bindata/go-bindata] 的生成函数将服务器构建到包含模板的单个二进制文件中。AssetFile\n$ go get -u github.com/go-bindata/go-bindata/... $ go-bindata -fs -prefix \u0026#34;templates\u0026#34; ./templates/... $ go run . 示例代码：\nfunc main() { app := iris.New() tmpl := iris.HTML(AssetFile(), \u0026#34;.html\u0026#34;) tmpl.Layout(\u0026#34;layouts/layout.html\u0026#34;) tmpl.AddFunc(\u0026#34;greet\u0026#34;, func(s string) string { return \u0026#34;Greetings \u0026#34; + s + \u0026#34;!\u0026#34; }) app.RegisterView(tmpl) // [...] } 在_examples/视图中查看完整示例。\n尝试将身体绑定到不同的结构中 绑定请求正文的常规方法消耗，它们 不能多次调用，除非将配置器传递给 。ctx.Request().Body``iris.WithoutBodyConsumptionOnUnmarshal``app.Run/Listen\npackage main import \u0026#34;github.com/kataras/iris/v12\u0026#34; func main() { app := iris.New() app.Post(\u0026#34;/\u0026#34;, logAllBody, logJSON, logFormValues, func(ctx iris.Context) { // body, err := os.ReadAll(ctx.Request().Body) once or body, err := ctx.GetBody() // as many times as you need. if err != nil { ctx.StopWithError(iris.StatusInternalServerError, err) return } if len(body) == 0 { ctx.WriteString(`The body was empty.`) } else { ctx.WriteString(\u0026#34;OK body is still:\\n\u0026#34;) ctx.Write(body) } }) app.Listen(\u0026#34;:8080\u0026#34;, iris.WithoutBodyConsumptionOnUnmarshal) } func logAllBody(ctx iris.Context) { body, err := ctx.GetBody() if err == nil \u0026amp;\u0026amp; len(body) \u0026gt; 0 { ctx.Application().Logger().Infof(\u0026#34;logAllBody: %s\u0026#34;, string(body)) } ctx.Next() } func logJSON(ctx iris.Context) { var p interface{} if err := ctx.ReadJSON(\u0026amp;p); err == nil { ctx.Application().Logger().Infof(\u0026#34;logJSON: %#+v\u0026#34;, p) } ctx.Next() } func logFormValues(ctx iris.Context) { values := ctx.FormValues() if values != nil { ctx.Application().Logger().Infof(\u0026#34;logFormValues: %v\u0026#34;, values) } ctx.Next() } 可以使用 将结构绑定到基于客户端内容类型的请求。您还可以使用内容协商。下面是一个完整的示例：ReadBody\npackage main import ( \u0026#34;github.com/kataras/iris/v12\u0026#34; ) func main() { app := newApp() // See main_test.go for usage. app.Listen(\u0026#34;:8080\u0026#34;) } func newApp() *iris.Application { app := iris.New() // To automatically decompress using gzip: // app.Use(iris.GzipReader) app.Use(setAllowedResponses) app.Post(\u0026#34;/\u0026#34;, readBody) return app } type payload struct { Message string `json:\u0026#34;message\u0026#34; xml:\u0026#34;message\u0026#34; msgpack:\u0026#34;message\u0026#34; yaml:\u0026#34;Message\u0026#34; url:\u0026#34;message\u0026#34; form:\u0026#34;message\u0026#34;` } func readBody(ctx iris.Context) { var p payload // Bind request body to \u0026#34;p\u0026#34; depending on the content-type that client sends the data, // e.g. JSON, XML, YAML, MessagePack, Protobuf, Form and URL Query. err := ctx.ReadBody(\u0026amp;p) if err != nil { ctx.StopWithProblem(iris.StatusBadRequest, iris.NewProblem().Title(\u0026#34;Parser issue\u0026#34;).Detail(err.Error())) return } // For the sake of the example, log the received payload. ctx.Application().Logger().Infof(\u0026#34;Received: %#+v\u0026#34;, p) // Send back the payload depending on the accept content type and accept-encoding of the client, // e.g. JSON, XML and so on. ctx.Negotiate(p) } func setAllowedResponses(ctx iris.Context) { // Indicate that the Server can send JSON, XML, YAML and MessagePack for this request. ctx.Negotiation().JSON().XML().YAML().MsgPack() // Add more, allowed by the server format of responses, mime types here... // If client is missing an \u0026#34;Accept: \u0026#34; header then default it to JSON. ctx.Negotiation().Accept.JSON() ctx.Next() } (adsbygoogle = window.adsbygoogle || []).push({});\nHTTP2 服务器推送 完整的示例代码可以在 _examples/response-writer/http2push 中找到。\n服务器推送让服务器抢先“推送”网站资产 到客户端，而无需用户明确请求它们。 谨慎使用时，我们可以发送我们知道用户要去的内容 需要他们请求的页面。\npackage main import ( \u0026#34;net/http\u0026#34; \u0026#34;github.com/kataras/iris/v12\u0026#34; ) func main() { app := iris.New() app.Get(\u0026#34;/\u0026#34;, pushHandler) app.Get(\u0026#34;/main.js\u0026#34;, simpleAssetHandler) app.Run(iris.TLS(\u0026#34;127.0.0.1:443\u0026#34;, \u0026#34;mycert.crt\u0026#34;, \u0026#34;mykey.key\u0026#34;)) // $ openssl req -new -newkey rsa:4096 -x509 -sha256 \\ // -days 365 -nodes -out mycert.crt -keyout mykey.key } func pushHandler(ctx iris.Context) { // The target must either be an absolute path (like \u0026#34;/path\u0026#34;) or an absolute // URL that contains a valid host and the same scheme as the parent request. // If the target is a path, it will inherit the scheme and host of the // parent request. target := \u0026#34;/main.js\u0026#34; if pusher, ok := ctx.ResponseWriter().Naive().(http.Pusher); ok { err := pusher.Push(target, nil) if err != nil { if err == iris.ErrPushNotSupported { ctx.StopWithText(iris.StatusHTTPVersionNotSupported, \u0026#34;HTTP/2 push not supported.\u0026#34;) } else { ctx.StopWithError(iris.StatusInternalServerError, err) } return } } ctx.HTML(`\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;\u0026lt;script src=\u0026#34;%s\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;`, target) } func simpleAssetHandler(ctx iris.Context) { ctx.ServeFile(\u0026#34;./public/main.js\u0026#34;) } 设置并获取饼干 安全 Cookie、编码和解码、会话（和会话缩放）、闪存消息等可以在 _examples/cookie 和 _examples/会话目录中找到。\nimport \u0026#34;github.com/kataras/iris/v12\u0026#34; func main() { app := iris.Default() app.Get(\u0026#34;/cookie\u0026#34;, func(ctx iris.Context) { value := ctx.GetCookie(\u0026#34;my_cookie\u0026#34;) if value == \u0026#34;\u0026#34; { value = \u0026#34;NotSet\u0026#34; ctx.SetCookieKV(\u0026#34;my_cookie\u0026#34;, value) // Alternatively: ctx.SetCookie(\u0026amp;http.Cookie{...}) ctx.SetCookie(\u0026#34;\u0026#34;, \u0026#34;test\u0026#34;, 3600, \u0026#34;/\u0026#34;, \u0026#34;localhost\u0026#34;, false, true) } ctx.Writef(\u0026#34;Cookie value: %s \\n\u0026#34;, cookie) }) app.Listen(\u0026#34;:8080\u0026#34;) } 如果要设置自定义路径：\nctx.SetCookieKV(name, value, iris.CookiePath(\u0026#34;/custom/path/cookie/will/be/stored\u0026#34;)) 如果希望仅对当前请求路径可见：\nctx.SetCookieKV(name, value, iris.CookieCleanPath /* or iris.CookiePath(\u0026#34;\u0026#34;) */) 更多：\niris.CookieAllowReclaim iris.CookieAllowSubdomains iris.CookieSecure iris.CookieHTTPOnly iris.CookieSameSite iris.CookiePath iris.CookieCleanPath iris.CookieExpires iris.CookieEncoding 您也可以在中间件中为整个请求添加 cookie 选项：\nfunc setCookieOptions(ctx iris.Context) { ctx.AddCookieOptions(iris.CookieHTTPOnly(true), iris.CookieExpires(1*time.Hour)) ctx.Next() } JSON 网络令牌 JSON Web 令牌 （JWT） 是一种开放标准 （RFC 7519），它定义了一种紧凑且独立的方式，用于在各方之间以 JSON 对象的形式安全地传输信息。此信息可以验证和信任，因为它是经过数字签名的。JWT 可以使用密钥（使用 HMAC 算法）或使用 RSA 或 ECDSA 的公钥/私钥对进行签名。\n何时应使用 JSON Web 令牌？ 以下是 JSON Web 令牌有用的一些方案：\n授权：这是使用 JWT 的最常见方案。用户登录后，每个后续请求都将包含 JWT，允许用户访问使用该令牌允许的路由、服务和资源。单点登录是当今广泛使用 JWT 的一项功能，因为它的开销很小，并且能够跨不同域轻松使用。\n信息交换：JSON Web 令牌是在各方之间安全传输信息的好方法。由于 JWT 可以签名（例如，使用公钥/私钥对），因此您可以确定发件人是他们所说的人。此外，由于签名是使用标头和有效负载计算的，因此您还可以验证内容是否未被篡改。\n阅读更多关于智威汤逊的信息： https://jwt.io/introduction/\n将 JWT 与虹膜配合使用 Iris JWT 中间件在设计时考虑了安全性、性能和简单性，它可以保护您的令牌免受您可能在其他库中发现的关键漏洞的影响。它基于kataras/jwt包。\npackage main import ( \u0026#34;time\u0026#34; \u0026#34;github.com/kataras/iris/v12\u0026#34; \u0026#34;github.com/kataras/iris/v12/middleware/jwt\u0026#34; ) var ( sigKey = []byte(\u0026#34;signature_hmac_secret_shared_key\u0026#34;) encKey = []byte(\u0026#34;GCM_AES_256_secret_shared_key_32\u0026#34;) ) type fooClaims struct { Foo string `json:\u0026#34;foo\u0026#34;` } func main() { app := iris.New() signer := jwt.NewSigner(jwt.HS256, sigKey, 10*time.Minute) // Enable payload encryption with: // signer.WithEncryption(encKey, nil) app.Get(\u0026#34;/\u0026#34;, generateToken(signer)) verifier := jwt.NewVerifier(jwt.HS256, sigKey) // Enable server-side token block feature (even before its expiration time): verifier.WithDefaultBlocklist() // Enable payload decryption with: // verifier.WithDecryption(encKey, nil) verifyMiddleware := verifier.Verify(func() interface{} { return new(fooClaims) }) protectedAPI := app.Party(\u0026#34;/protected\u0026#34;) // Register the verify middleware to allow access only to authorized clients. protectedAPI.Use(verifyMiddleware) // ^ or UseRouter(verifyMiddleware) to disallow unauthorized http error handlers too. protectedAPI.Get(\u0026#34;/\u0026#34;, protected) // Invalidate the token through server-side, even if it\u0026#39;s not expired yet. protectedAPI.Get(\u0026#34;/logout\u0026#34;, logout) // http://localhost:8080 // http://localhost:8080/protected?token=$token (or Authorization: Bearer $token) // http://localhost:8080/protected/logout?token=$token // http://localhost:8080/protected?token=$token (401) app.Listen(\u0026#34;:8080\u0026#34;) } func generateToken(signer *jwt.Signer) iris.Handler { return func(ctx iris.Context) { claims := fooClaims{Foo: \u0026#34;bar\u0026#34;} token, err := signer.Sign(claims) if err != nil { ctx.StopWithStatus(iris.StatusInternalServerError) return } ctx.Write(token) } } func protected(ctx iris.Context) { // Get the verified and decoded claims. claims := jwt.Get(ctx).(*fooClaims) // Optionally, get token information if you want to work with them. // Just an example on how you can retrieve all the standard claims (set by signer\u0026#39;s max age, \u0026#34;exp\u0026#34;). standardClaims := jwt.GetVerifiedToken(ctx).StandardClaims expiresAtString := standardClaims.ExpiresAt().Format(ctx.Application().ConfigurationReadOnly().GetTimeFormat()) timeLeft := standardClaims.Timeleft() ctx.Writef(\u0026#34;foo=%s\\nexpires at: %s\\ntime left: %s\\n\u0026#34;, claims.Foo, expiresAtString, timeLeft) } func logout(ctx iris.Context) { err := ctx.Logout() if err != nil { ctx.WriteString(err.Error()) } else { ctx.Writef(\u0026#34;token invalidated, a new token is required to access the protected API\u0026#34;) } } 有关刷新令牌、阻止列表等的信息，请访问：_examples/auth/jwt。\n测试 Iris为httpexpect提供了令人难以置信的支持，httpexpect是Web应用程序的测试框架。子包为 Iris + httpexpect 提供了帮助程序。iris/httptest\n如果你更喜欢Go的标准net/http/httptest包，你仍然可以使用它。Iris与每个http Web框架都与任何用于测试的外部工具兼容，最后它是HTTP。\n测试基本身份验证 在第一个示例中，我们将使用子包来测试基本身份验证。iris/httptest\n1. 源文件如下所示：main.go\npackage main import ( \u0026#34;github.com/kataras/iris/v12\u0026#34; \u0026#34;github.com/kataras/iris/v12/middleware/basicauth\u0026#34; ) func newApp() *iris.Application { app := iris.New() opts := basicauth.Options{ Allow: basicauth.AllowUsers(map[string]string{\u0026#34;myusername\u0026#34;: \u0026#34;mypassword\u0026#34;}), } authentication := basicauth.New(opts) // or just: basicauth.Default(map...) app.Get(\u0026#34;/\u0026#34;, func(ctx iris.Context) { ctx.Redirect(\u0026#34;/admin\u0026#34;) }) // to party needAuth := app.Party(\u0026#34;/admin\u0026#34;, authentication) { //http://localhost:8080/admin needAuth.Get(\u0026#34;/\u0026#34;, h) // http://localhost:8080/admin/profile needAuth.Get(\u0026#34;/profile\u0026#34;, h) // http://localhost:8080/admin/settings needAuth.Get(\u0026#34;/settings\u0026#34;, h) } return app } func h(ctx iris.Context) { // username, password, _ := ctx.Request().BasicAuth() // third parameter it will be always true because the middleware // makes sure for that, otherwise this handler will not be executed. // OR: user := ctx.User().(*iris.SimpleUser) ctx.Writef(\u0026#34;%s %s:%s\u0026#34;, ctx.Path(), user.Username, user.Password) // ctx.Writef(\u0026#34;%s %s:%s\u0026#34;, ctx.Path(), username, password) } func main() { app := newApp() app.Listen(\u0026#34;:8080\u0026#34;) } **2.**现在，创建一个文件并复制粘贴以下内容。main_test.go\npackage main import ( \u0026#34;testing\u0026#34; \u0026#34;github.com/kataras/iris/v12/httptest\u0026#34; ) func TestNewApp(t *testing.T) { app := newApp() e := httptest.New(t, app) // redirects to /admin without basic auth e.GET(\u0026#34;/\u0026#34;).Expect().Status(httptest.StatusUnauthorized) // without basic auth e.GET(\u0026#34;/admin\u0026#34;).Expect().Status(httptest.StatusUnauthorized) // with valid basic auth e.GET(\u0026#34;/admin\u0026#34;).WithBasicAuth(\u0026#34;myusername\u0026#34;, \u0026#34;mypassword\u0026#34;).Expect(). Status(httptest.StatusOK).Body().Equal(\u0026#34;/admin myusername:mypassword\u0026#34;) e.GET(\u0026#34;/admin/profile\u0026#34;).WithBasicAuth(\u0026#34;myusername\u0026#34;, \u0026#34;mypassword\u0026#34;).Expect(). Status(httptest.StatusOK).Body().Equal(\u0026#34;/admin/profile myusername:mypassword\u0026#34;) e.GET(\u0026#34;/admin/settings\u0026#34;).WithBasicAuth(\u0026#34;myusername\u0026#34;, \u0026#34;mypassword\u0026#34;).Expect(). Status(httptest.StatusOK).Body().Equal(\u0026#34;/admin/settings myusername:mypassword\u0026#34;) // with invalid basic auth e.GET(\u0026#34;/admin/settings\u0026#34;).WithBasicAuth(\u0026#34;invalidusername\u0026#34;, \u0026#34;invalidpassword\u0026#34;). Expect().Status(httptest.StatusUnauthorized) } 3. 打开命令行并执行：\n$ go test -v 测试饼干 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;github.com/kataras/iris/v12/httptest\u0026#34; ) func TestCookiesBasic(t *testing.T) { app := newApp() e := httptest.New(t, app, httptest.URL(\u0026#34;http://example.com\u0026#34;)) cookieName, cookieValue := \u0026#34;my_cookie_name\u0026#34;, \u0026#34;my_cookie_value\u0026#34; // Test Set A Cookie. t1 := e.GET(fmt.Sprintf(\u0026#34;/cookies/%s/%s\u0026#34;, cookieName, cookieValue)). Expect().Status(httptest.StatusOK) // Validate cookie\u0026#39;s existence, it should be available now. t1.Cookie(cookieName).Value().Equal(cookieValue) t1.Body().Contains(cookieValue) path := fmt.Sprintf(\u0026#34;/cookies/%s\u0026#34;, cookieName) // Test Retrieve A Cookie. t2 := e.GET(path).Expect().Status(httptest.StatusOK) t2.Body().Equal(cookieValue) // Test Remove A Cookie. t3 := e.DELETE(path).Expect().Status(httptest.StatusOK) t3.Body().Contains(cookieName) t4 := e.GET(path).Expect().Status(httptest.StatusOK) t4.Cookies().Empty() t4.Body().Empty() } $ go test -v -run=TestCookiesBasic$ Iris Web 框架本身使用此包来测试自身。在_examples存储库目录中，您还可以找到一些有用的测试。有关更多信息，请查看并阅读 httpexpect 的文档。\n地方化 介绍 本地化功能提供了一种检索各种语言字符串的便捷方法，使您可以在应用程序中轻松支持多种语言。语言字符串存储在目录中的文件中。在此目录中，应用程序支持的每种语言都应该有一个子目录：./locales\n│ main.go └───locales ├───el-GR │ home.yml ├───en-US │ home.yml └───zh-CN home.yml 应用程序的默认语言是第一个注册语言。\napp := iris.New() // First parameter: Glob filpath patern, // Second variadic parameter: Optional language tags, // the first one is the default/fallback one. app.I18n.Load(\u0026#34;./locales/*/*\u0026#34;, \u0026#34;en-US\u0026#34;, \u0026#34;el-GR\u0026#34;, \u0026#34;zh-CN\u0026#34;) 或者，如果您通过以下方式加载所有语言：\napp.I18n.Load(\u0026#34;./locales/*/*\u0026#34;) // Then set the default language using: app.I18n.SetDefault(\u0026#34;en-US\u0026#34;) 加载嵌入式区域设置 您可能希望在应用程序可执行文件中使用新的嵌入指令嵌入区域设置。\n导入嵌入包;如果您不使用此包中的任何导出标识符，则可以使用 _ “embed” 进行空白导入。 import ( \u0026#34;embed\u0026#34; ) 嵌入指令接受相对于包含 Go 源文件的目录的路径。我们可以嵌入多个文件，甚至是带有通配符的文件夹。这使用嵌入的变量。FS 类型，它实现一个简单的虚拟文件系统。 //go:embed embedded/locales/* var embeddedFS embed.FS 我们应该使用方法而不是方法。Load``LoadFS err := app.I18n.LoadFS(embeddedFS, \u0026#34;./embedded/locales/*/*.ini\u0026#34;, \u0026#34;en-US\u0026#34;, \u0026#34;el-GR\u0026#34;) // OR to load all languages by filename: // app.I18n.LoadFS(embeddedFS, \u0026#34;./embedded/locales/*/*.ini\u0026#34;) // Then set the default language using: // app.I18n.SetDefault(\u0026#34;en-US\u0026#34;) 定义翻译 语言环境文件可以以 YAML（推荐）、JSON、TOML 或 INI 形式编写。\n每个文件都应包含密钥。键也可以有子键（我们称之为“部分”）。\n每个键的值应具有形式或包含其翻译文本（或模板）或/及其复数键值。string``map\nIris i18n模块支持开箱即用的复数，见下文。\nFMT 风格 hi: \u0026#34;Hi %s!\u0026#34; ctx.Tr(\u0026#34;Hi\u0026#34;, \u0026#34;John\u0026#34;) // Outputs: Hi John! 模板 hi: \u0026#34;Hi {{.Name}}!\u0026#34; ctx.Tr(\u0026#34;Hi\u0026#34;, iris.Map{\u0026#34;Name\u0026#34;: \u0026#34;John\u0026#34;}) // Outputs: Hi John! 多元化 Iris i18n 支持复数变量。要定义每个区域设置变量，您必须 定义键的新部分。Vars\n变量可接受的键为：\none \u0026quot;=x\u0026quot;其中 x 是一个数字 \u0026quot;\u0026lt;x\u0026quot; other format 例：\nVars: - Minutes: one: \u0026#34;minute\u0026#34; other: \u0026#34;minutes\u0026#34; - Houses: one: \u0026#34;house\u0026#34; other: \u0026#34;houses\u0026#34; 然后，每条消息都可以使用此变量，方法如下：\n# Using variables in raw string YouLate: \u0026#34;You are %[1]d ${Minutes} late.\u0026#34; # [x] is the argument position, # variables always have priority other fmt-style arguments, # that\u0026#39;s why we see [1] for houses and [2] for the string argument. HouseCount: \u0026#34;%[2]s has %[1]d ${Houses}.\u0026#34; ctx.Tr(\u0026#34;YouLate\u0026#34;, 1) // Outputs: You are 1 minute late. ctx.Tr(\u0026#34;YouLate\u0026#34;, 10) // Outputs: You are 10 minutes late. ctx.Tr(\u0026#34;HouseCount\u0026#34;, 2, \u0026#34;John\u0026#34;) // Outputs: John has 2 houses. 您可以根据给定的复数计数选择将显示的消息。\n除了变量，每条消息也可以有其复数形式！\n可接受的密钥：\nzero one two \u0026quot;=x\u0026quot; \u0026quot;\u0026lt;x\u0026quot; \u0026quot;\u0026gt;x\u0026quot; other 让我们创建一个简单的复数功能消息，它也可以使用我们在上面创建的 Minutes 变量。\nFreeDay: \u0026#34;=3\u0026#34;: \u0026#34;You have three days and %[2]d ${Minutes} off.\u0026#34; # \u0026#34;FreeDay\u0026#34; 3, 15 one: \u0026#34;You have a day off.\u0026#34; # \u0026#34;FreeDay\u0026#34;, 1 other: \u0026#34;You have %[1]d free days.\u0026#34; # \u0026#34;FreeDay\u0026#34;, 5 ctx.Tr(\u0026#34;FreeDay\u0026#34;, 3, 15) // Outputs: You have three days and 15 minutes off. ctx.Tr(\u0026#34;FreeDay\u0026#34;, 1) // Outputs: You have a day off. ctx.Tr(\u0026#34;FreeDay\u0026#34;, 5) // Outputs: You have 5 free days. 让我们继续使用更高级的示例，使用模板文本 + 函数 + 复数 + 变量。\nVars: - Houses: one: \u0026#34;house\u0026#34; other: \u0026#34;houses\u0026#34; - Gender: \u0026#34;=1\u0026#34;: \u0026#34;She\u0026#34; \u0026#34;=2\u0026#34;: \u0026#34;He\u0026#34; VarTemplatePlural: one: \u0026#34;${Gender} is awesome!\u0026#34; other: \u0026#34;other (${Gender}) has %[3]d ${Houses}.\u0026#34; \u0026#34;=5\u0026#34;: \u0026#34;{{call .InlineJoin .Names}} are awesome.\u0026#34; const ( female = iota + 1 male ) ctx.Tr(\u0026#34;VarTemplatePlural\u0026#34;, iris.Map{ \u0026#34;PluralCount\u0026#34;: 5, \u0026#34;Names\u0026#34;: []string{\u0026#34;John\u0026#34;, \u0026#34;Peter\u0026#34;}, \u0026#34;InlineJoin\u0026#34;: func(arr []string) string { return strings.Join(arr, \u0026#34;, \u0026#34;) }, }) // Outputs: John, Peter are awesome ctx.Tr(\u0026#34;VarTemplatePlural\u0026#34;, 1, female) // Outputs: She is awesome! ctx.Tr(\u0026#34;VarTemplatePlural\u0026#34;, 2, female, 5) // Outputs: other (She) has 5 houses. 部分 如果密钥不是保留密钥（例如一、二\u0026hellip;），则它充当子部分。这些部分由点字符 （） 分隔。.\nWelcome: Message: \u0026#34;Welcome {{.Name}}\u0026#34; ctx.Tr(\u0026#34;Welcome.Message\u0026#34;, iris.Map{\u0026#34;Name\u0026#34;: \u0026#34;John\u0026#34;}) // Outputs: Welcome John 确定当前区域设置 您可以使用该方法确定当前区域设置或检查区域设置是否为给定值：context.GetLocale\nfunc(ctx iris.Context) { locale := ctx.GetLocale() // [...] } 区域设置界面如下所示。\n// Locale is the interface which returns from a `Localizer.GetLocale` metod. // It serves the transltions based on \u0026#34;key\u0026#34; or format. See `GetMessage`. type Locale interface { // Index returns the current locale index from the languages list. Index() int // Tag returns the full language Tag attached tothis Locale, // it should be uniue across different Locales. Tag() *language.Tag // Language should return the exact languagecode of this `Locale` //that the user provided on `New` function. // // Same as `Tag().String()` but it\u0026#39;s static. Language() string // GetMessage should return translated text based n the given \u0026#34;key\u0026#34;. GetMessage(key string, args ...interface{}) string } 检索翻译 使用方法作为获取此请求的翻译文本的快捷方式。context.Tr\nfunc(ctx iris.Context) { text := ctx.Tr(\u0026#34;hi\u0026#34;, \u0026#34;name\u0026#34;) // [...] } 内部视图 func(ctx iris.Context) { err := ctx.View(\u0026#34;index.html\u0026#34;, iris.Map{ \u0026#34;tr\u0026#34;: ctx.Tr, }) if err!=nil { ctx.HTML(\u0026#34;\u0026lt;h3\u0026gt;%s\u0026lt;/h3\u0026gt;\u0026#34;, err.Error()) return } } 例 package main import ( \u0026#34;github.com/kataras/iris/v12\u0026#34; ) func newApp() *iris.Application { app := iris.New() // Configure i18n. // First parameter: Glob filpath patern, // Second variadic parameter: Optional language tags, the first one is the default/fallback one. app.I18n.Load(\u0026#34;./locales/*/*.ini\u0026#34;, \u0026#34;en-US\u0026#34;, \u0026#34;el-GR\u0026#34;, \u0026#34;zh-CN\u0026#34;) // app.I18n.LoadAssets for go-bindata. // Default values: // app.I18n.URLParameter = \u0026#34;lang\u0026#34; // app.I18n.Subdomain = true // // Set to false to disallow path (local) redirects, // see https://github.com/kataras/iris/issues/1369. // app.I18n.PathRedirect = true app.Get(\u0026#34;/\u0026#34;, func(ctx iris.Context) { hi := ctx.Tr(\u0026#34;hi\u0026#34;, \u0026#34;iris\u0026#34;) locale := ctx.GetLocale() ctx.Writef(\u0026#34;From the language %s translated output: %s\u0026#34;, locale.Language(), hi) }) app.Get(\u0026#34;/some-path\u0026#34;, func(ctx iris.Context) { ctx.Writef(\u0026#34;%s\u0026#34;, ctx.Tr(\u0026#34;hi\u0026#34;, \u0026#34;iris\u0026#34;)) }) app.Get(\u0026#34;/other\u0026#34;, func(ctx iris.Context) { language := ctx.GetLocale().Language() fromFirstFileValue := ctx.Tr(\u0026#34;key1\u0026#34;) fromSecondFileValue := ctx.Tr(\u0026#34;key2\u0026#34;) ctx.Writef(\u0026#34;From the language: %s, translated output:\\n%s=%s\\n%s=%s\u0026#34;, language, \u0026#34;key1\u0026#34;, fromFirstFileValue, \u0026#34;key2\u0026#34;, fromSecondFileValue) }) // using in inside your views: view := iris.HTML(\u0026#34;./views\u0026#34;, \u0026#34;.html\u0026#34;) app.RegisterView(view) app.Get(\u0026#34;/templates\u0026#34;, func(ctx iris.Context) { err := ctx.View(\u0026#34;index.html\u0026#34;, iris.Map{ \u0026#34;tr\u0026#34;: ctx.Tr, // word, arguments... {call .tr \u0026#34;hi\u0026#34; \u0026#34;iris\u0026#34;}} }) if err != nil { ctx.HTML(\u0026#34;\u0026lt;h3\u0026gt;%s\u0026lt;/h3\u0026gt;\u0026#34;, err.Error()) return } // Note that, // Iris automatically adds a \u0026#34;tr\u0026#34; global template function as well, // the only difference is the way you call it inside your templates and // that it accepts a language code as its first argument. }) // return app } func main() { app := newApp() // go to http://localhost:8080/el-gr/some-path // ^ (by path prefix) // // or http://el.mydomain.com8080/some-path // ^ (by subdomain - test locally with the hosts file) // // or http://localhost:8080/zh-CN/templates // ^ (by path prefix with uppercase) // // or http://localhost:8080/some-path?lang=el-GR // ^ (by url parameter) // // or http://localhost:8080 (default is en-US) // or http://localhost:8080/?lang=zh-CN // // go to http://localhost:8080/other?lang=el-GR // or http://localhost:8080/other (default is en-US) // or http://localhost:8080/other?lang=en-US // // or use cookies to set the language. app.Listen(\u0026#34;:8080\u0026#34;, iris.WithSitemap(\u0026#34;http://localhost:8080\u0026#34;)) } 网站地图 站点地图翻译会自动设置为每个路由，如果为 true，则按路径前缀设置，如果为 true，则按子域自动设置，如果不为空，则按 URL 查询参数自动设置。app.I18n.PathRedirect``app.I18n.Subdomain``app.I18n.URLParameter\n阅读更多： https://support.google.com/webmasters/answer/189077?hl=en\nGET http://localhost:8080/sitemap.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34; standalone=\u0026#34;yes\u0026#34;?\u0026gt; \u0026lt;urlset xmlns=\u0026#34;http://www.sitemaps.org/schemas/sitemap/0.9\u0026#34; xmlns:xhtml=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34;\u0026gt; \u0026lt;url\u0026gt; \u0026lt;loc\u0026gt;http://localhost:8080/\u0026lt;/loc\u0026gt; \u0026lt;xhtml:link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;en-US\u0026#34; href=\u0026#34;http://localhost:8080/\u0026#34;\u0026gt;\u0026lt;/xhtml:link\u0026gt; \u0026lt;xhtml:link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;el-GR\u0026#34; href=\u0026#34;http://localhost:8080/el-GR/\u0026#34;\u0026gt;\u0026lt;/xhtml:link\u0026gt; \u0026lt;xhtml:link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;zh-CN\u0026#34; href=\u0026#34;http://localhost:8080/zh-CN/\u0026#34;\u0026gt;\u0026lt;/xhtml:link\u0026gt; \u0026lt;/url\u0026gt; \u0026lt;url\u0026gt; \u0026lt;loc\u0026gt;http://localhost:8080/some-path\u0026lt;/loc\u0026gt; \u0026lt;xhtml:link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;en-US\u0026#34; href=\u0026#34;http://localhost:8080/some-path\u0026#34;\u0026gt;\u0026lt;/xhtml:link\u0026gt; \u0026lt;xhtml:link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;el-GR\u0026#34; href=\u0026#34;http://localhost:8080/el-GR/some-path\u0026#34;\u0026gt;\u0026lt;/xhtml:link\u0026gt; \u0026lt;xhtml:link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;zh-CN\u0026#34; href=\u0026#34;http://localhost:8080/zh-CN/some-path\u0026#34;\u0026gt;\u0026lt;/xhtml:link\u0026gt; \u0026lt;/url\u0026gt; \u0026lt;url\u0026gt; \u0026lt;loc\u0026gt;http://localhost:8080/other\u0026lt;/loc\u0026gt; \u0026lt;xhtml:link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;en-US\u0026#34; href=\u0026#34;http://localhost:8080/other\u0026#34;\u0026gt;\u0026lt;/xhtml:link\u0026gt; \u0026lt;xhtml:link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;el-GR\u0026#34; href=\u0026#34;http://localhost:8080/el-GR/other\u0026#34;\u0026gt;\u0026lt;/xhtml:link\u0026gt; \u0026lt;xhtml:link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;zh-CN\u0026#34; href=\u0026#34;http://localhost:8080/zh-CN/other\u0026#34;\u0026gt;\u0026lt;/xhtml:link\u0026gt; \u0026lt;/url\u0026gt; \u0026lt;url\u0026gt; \u0026lt;loc\u0026gt;http://localhost:8080/templates\u0026lt;/loc\u0026gt; \u0026lt;xhtml:link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;en-US\u0026#34; href=\u0026#34;http://localhost:8080/templates\u0026#34;\u0026gt;\u0026lt;/xhtml:link\u0026gt; \u0026lt;xhtml:link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;el-GR\u0026#34; href=\u0026#34;http://localhost:8080/el-GR/templates\u0026#34;\u0026gt;\u0026lt;/xhtml:link\u0026gt; \u0026lt;xhtml:link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;zh-CN\u0026#34; href=\u0026#34;http://localhost:8080/zh-CN/templates\u0026#34;\u0026gt;\u0026lt;/xhtml:link\u0026gt; \u0026lt;/url\u0026gt; \u0026lt;/urlset\u0026gt; ","permalink":"https://liiqii.github.io/posts/tech/go/go_iris/","summary":"转自：Iris 安装 Iris是一个跨平台的软件。 唯一的要求是 Go 编程语言，版本 1.20 及更高版本。 $ mkdir myapp $ cd myapp $ go mod init myapp $ go get github.com/kataras/iris/v12@latest 将其导入到代码中： import \u0026#34;github.com/kataras/iris/v12\u0026#34; 故障 排除 如果在安装过程中遇到网络错误，请确保设置了有效的 GOPROXY 环境变量。 go env -w GOPROXY=https://goproxy.io,direct 如果上述方法均无效，请清理 go 模块缓存： go clean --modcache 快速入门 # assume the following codes in","title":"Go 框架 Iris 文档"},{"content":"转自：GO面试题集锦快答[持续更新]\nslice 扩容机制 GO1.17版本及之前 当新切片需要的容量cap大于两倍扩容的容量，则直接按照新切片需要的容量扩容； 当原 slice 容量 \u0026lt; 1024 的时候，新 slice 容量变成原来的 2 倍； 当原 slice 容量 \u0026gt; 1024，进入一个循环，每次容量变成原来的1.25倍,直到大于期望容量。 GO1.18之后 当新切片需要的容量cap大于两倍扩容的容量，则直接按照新切片需要的容量扩容； 当原 slice 容量 \u0026lt; threshold 的时候，新 slice 容量变成原来的 2 倍； 当原 slice 容量 \u0026gt; threshold，进入一个循环，每次容量增加（旧容量+3*threshold）/4。 slice 为什么不是线程安全的 slice底层结构并没有使用加锁的方式,不支持并发读写 map 底层原理 map 是一个指针 占用8个字节(64位计算机),指向hmap结构体,hmap包含多个bmap数组(桶) type hmap struct { count int //元素个数，调用len(map)时直接返回 flags uint8 //标志map当前状态,正在删除元素、添加元素..... B uint8 //单元(buckets)的对数 B=5表示能容纳32个元素 B随着map容量增大而变大 noverflow uint16 //单元(buckets)溢出数量，如果一个单元能存8个key，此时存储了9个，溢出了，就需要再增加一个单元 hash0 uint32 //哈希种子 buckets unsafe.Pointer //指向单元(buckets)数组,大小为2^B，可以为nil oldbuckets unsafe.Pointer //扩容的时候，buckets长度会是oldbuckets的两倍 nevacute uintptr //指示扩容进度，小于此buckets迁移完成 extra *mapextra //与gc相关 可选字段 } type bmap struct { tophash [bucketCnt]uint8 } //实际上编译期间会生成一个新的数据结构 type bmap struct { topbits [8]uint8 //key hash值前8位 用于快速定位keys的位置 keys [8]keytype //键 values [8]valuetype //值 pad uintptr overflow uintptr //指向溢出桶 无符号整形 优化GC } map 扩容机制 扩容时机：向 map 插入新 key 的时候，会进行条件检测，符合下面这 2 个条件，就会触发扩容 扩容条件： 1.超过负载 map元素个数 \u0026gt; 6.5（负载因子） * 桶个数 2.溢出桶太多 当桶总数\u0026lt;2^15时，如果溢出桶总数\u0026gt;=桶总数，则认为溢出桶过多 当桶总数\u0026gt;2^15时，如果溢出桶总数\u0026gt;=2^15，则认为溢出桶过多 扩容机制： 双倍扩容：针对条件1，新建一个buckets数组，新的buckets大小是原来的2倍，然后旧buckets数据搬迁到新的buckets。 等量扩容：针对条件2，并不扩大容量，buckets数量维持不变，重新做一遍类似双倍扩容的搬迁动作，把松散的键值对重新排列一次，使得同一个 bucket 中的 key 排列地更紧密，节省空间，提高 bucket 利用率，进而保证更快的存取。 渐进式扩容： 插入修改删除key的时候，都会尝试进行搬迁桶的工作，每次都会检查oldbucket是否nil，如果不是nil则每次搬迁2个桶，蚂蚁搬家一样渐进式扩容 map 遍历为什么无序 map每次遍历,都会从一个随机值序号的桶,再从其中随机的cell开始遍历,并且扩容后,原来桶中的key会落到其他桶中,本身就会造成失序 如果想顺序遍历map,先把key放到切片排序,再按照key的顺序遍历map var sl []int for k := range m { sl = append(sl, k) } sort.Ints(sl) for _,k:= range sl { fmt.Print(m[k]) } map 为什么不是线程安全的 map设计就不是用来多个协程高并发访问的 多个协程同时对map进行并发读写,程序会panic 如果想线程安全,可以使用sync.RWLock 锁 sync.map 这个包里面的map实现了锁,是线程安全的 Map 如何查找 1.写保护机制 先查hmap的标志位flags,如果flags写标志位此时是1,说明其他协程正在写操作,直接panic 2.计算hash值 key经过哈希函数计算后,得到64bit(64位CPU) 10010111 | 101011101010110101010101101010101010 | 10010 3.找到hash对应的桶 上面64位后5(hmap的B值)位定位所存放的桶 如果当前正在扩容中,并且定位到旧桶数据还未完成迁移,则使用旧的桶 4.遍历桶查找 上面64位前8位用来在tophash数组查找快速判断key是否在当前的桶中,如果不在需要去溢出桶查找 5.返回key对应的指针 Map 冲突解决方式 GO采用链地址法解决冲突，具体就是插入key到map中时，当key定位的桶填满8个元素后，将会创建一个溢出桶，并且将溢出桶插入当前桶的所在链表尾部 Map 负载因子为什么是 6.5 负载因子 = 哈希表存储的元素个数 / 桶个数 Go 官方发现：装载因子越大，填入的元素越多，空间利用率就越高，但发生哈希冲突的几率就变大。 装载因子越小，填入的元素越少，冲突发生的几率减小，但空间浪费也会变得更多，而且还会提高扩容操作的次数 Go 官方取了一个相对适中的值，把 Go 中的 map 的负载因子硬编码为 6.5，这就是 6.5 的选择缘由。 这意味着在 Go 语言中，当 map存储的元素个数大于或等于 6.5 * 桶个数 时，就会触发扩容行为。 Map 和 Sync.Map 哪个性能好 type Map struct { mu Mutex read atomic.Value dirty map[interface()]*entry misses int } 对比原始map： 和原始map+RWLock的实现并发的方式相比，减少了加锁对性能的影响。它做了一些优化：可以无锁访问read map，而且会优先操作read map，倘若只操作read map就可以满足要求，那就不用去操作write map(dirty)，所以在某些特定场景中它发生锁竞争的频率会远远小于map+RWLock的实现方式 优点： 适合读多写少的场景 缺点： 写多的场景，会导致 read map 缓存失效，需要加锁，冲突变多，性能急剧下降 Channel 底层实现原理 通过var声明或者make函数创建的channel变量是一个存储在函数栈帧上的指针，占用8个字节，指向堆上的hchan结构体 type hchan struct { closed uint32 // channel是否关闭的标志 elemtype *_type // channel中的元素类型 // channel分为无缓冲和有缓冲两种。 // 对于有缓冲的channel存储数据，使用了 ring buffer（环形缓冲区) 来缓存写入的数据，本质是循环数组 // 为啥是循环数组？普通数组不行吗，普通数组容量固定更适合指定的空间，弹出元素时，普通数组需要全部都前移 // 当下标超过数组容量后会回到第一个位置，所以需要有两个字段记录当前读和写的下标位置 buf unsafe.Pointer // 指向底层循环数组的指针（环形缓冲区） qcount uint // 循环数组中的元素数量 dataqsiz uint // 循环数组的长度 elemsize uint16 // 元素的大小 sendx uint // 下一次写下标的位置 recvx uint // 下一次读下标的位置 // 尝试读取channel或向channel写入数据而被阻塞的goroutine recvq waitq // 读等待队列 sendq waitq // 写等待队列 lock mutex //互斥锁，保证读写channel时不存在并发竞争问题 } 等待队列： 双向链表，包含一个头结点和一个尾结点 每个节点是一个sudog结构体变量，记录哪个协程在等待，等待的是哪个channel，等待发送/接收的数据在哪里 type waitq struct { first *sudog last *sudog } type sudog struct { g *g next *sudog prev *sudog elem unsafe.Pointer c *hchan ... } 创建时: 创建时会做一些检查: - 元素大小不能超过 64K - 元素的对齐大小不能超过 maxAlign 也就是 8 字节 - 计算出来的内存是否超过限制 创建时的策略: - 如果是无缓冲的 channel，会直接给 hchan 分配内存 - 如果是有缓冲的 channel，并且元素不包含指针，那么会为 hchan 和底层数组分配一段连续的地址 - 如果是有缓冲的 channel，并且元素包含指针，那么会为 hchan 和底层数组分别分配地址 发送时: - 如果 channel 的读等待队列存在接收者goroutine - 将数据**直接发送**给第一个等待的 goroutine， **唤醒接收的 goroutine** - 如果 channel 的读等待队列不存在接收者goroutine - 如果循环数组buf未满，那么将会把数据发送到循环数组buf的队尾 - 如果循环数组buf已满，这个时候就会走阻塞发送的流程，将当前 goroutine 加入写等待队列，并**挂起等待唤醒** 接收时: - 如果 channel 的写等待队列存在发送者goroutine - 如果是无缓冲 channel，**直接**从第一个发送者goroutine那里把数据拷贝给接收变量，**唤醒发送的 goroutine** - 如果是有缓冲 channel（已满），将循环数组buf的队首元素拷贝给接收变量，将第一个发送者goroutine的数据拷贝到 buf循环数组队尾，**唤醒发送的 goroutine** - 如果 channel 的写等待队列不存在发送者goroutine - 如果循环数组buf非空，将循环数组buf的队首元素拷贝给接收变量 - 如果循环数组buf为空，这个时候就会走阻塞接收的流程，将当前 goroutine 加入读等待队列，并**挂起等待唤醒** Channel 有什么特点 channel有2种类型：无缓冲、有缓冲 channel有3种模式：写操作模式（单向通道）、读操作模式（单向通道）、读写操作模式（双向通道） 写操作模式 make(chan\u0026lt;- int) 读操作模式 make(\u0026lt;-chan int) 读写操作模式 make(chan int) channel 有 3 种状态：未初始化、正常、关闭\n操作 \\ 状态 未初始化 关闭 正常 关闭 panic panic 正常 发送 永远阻塞导致死锁 panic 阻塞或者成功发送 接收 永远阻塞导致死锁 缓冲区为空则为零值，否则可以继续读 阻塞或者成功接收 注意点： 一个 channel不能多次关闭，会导致painc 如果多个 goroutine 都监听同一个 channel，那么 channel 上的数据都可能随机被某一个 goroutine 取走进行消费 如果多个 goroutine 监听同一个 channel，如果这个 channel 被关闭，则所有 goroutine 都能收到退出信号 Channel 为什么是线程安全的 不同协程通过channel进行通信，本身的使用场景就是多线程，为了保证数据的一致性，必须实现线程安全 channel的底层实现中，hchan结构体中采用Mutex锁来保证数据读写安全。在对循环数组buf中的数据进行入队和出队操作时，必须先获取互斥锁，才能操作channel数据 Channel 发送和接收什么情况下会死锁？ func deadlock1() { //无缓冲channel只写不读 ch := make(chan int) ch \u0026lt;- 3 // 这里会发生一直阻塞的情况，执行不到下面一句 } func deadlock2() { //无缓冲channel读在写后面 ch := make(chan int) ch \u0026lt;- 3 // 这里会发生一直阻塞的情况，执行不到下面一句 num := \u0026lt;-ch fmt.Println(\u0026#34;num=\u0026#34;, num) } func deadlock3() { //无缓冲channel读在写后面 ch := make(chan int) ch \u0026lt;- 100 // 这里会发生一直阻塞的情况，执行不到下面一句 go func() { num := \u0026lt;-ch fmt.Println(\u0026#34;num=\u0026#34;, num) }() time.Sleep(time.Second) } func deadlock3() { //有缓冲channel写入超过缓冲区数量 ch := make(chan int, 3) ch \u0026lt;- 3 ch \u0026lt;- 4 ch \u0026lt;- 5 ch \u0026lt;- 6 // 这里会发生一直阻塞的情况 } func deadlock4() { //空读 ch := make(chan int) // ch := make(chan int, 1) fmt.Println(\u0026lt;-ch) // 这里会发生一直阻塞的情况 } func deadlock5() { //互相等对方造成死锁 ch1 := make(chan int) ch2 := make(chan int) go func() { for { select { case num := \u0026lt;-ch1: fmt.Println(\u0026#34;num=\u0026#34;, num) ch2 \u0026lt;- 100 } } }() for { select { case num := \u0026lt;-ch2: fmt.Println(\u0026#34;num=\u0026#34;, num) ch1 \u0026lt;- 300 } } } 互斥锁实现原理 Go sync包提供了两种锁类型：互斥锁sync.Mutex 和 读写互斥锁sync.RWMutex，都属于悲观锁。 锁的实现一般会依赖于原子操作、信号量，通过atomic 包中的一些原子操作来实现锁的锁定，通过信号量来实现线程的阻塞与唤醒 在正常模式下，锁的等待者会按照先进先出的顺序获取锁。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，在这种情况下，这个被唤醒的 Goroutine 会加入到等待队列的前面。 如果一个等待的 Goroutine 超过1ms 没有获取锁，那么它将会把锁转变为饥饿模式。 Go在1.9中引入优化，目的保证互斥锁的公平性。在饥饿模式中，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会切换回正常模式。 互斥锁允许自旋的条件？ 线程没有获取到锁时常见有2种处理方式： - 一种是没有获取到锁的线程就一直循环等待判断该资源是否已经释放锁，这种锁也叫做自旋锁，它不用将线程阻塞起来， 适用于并发低且程序执行时间短的场景，缺点是cpu占用较高 - 另外一种处理方式就是把自己阻塞起来，会释放CPU给其他线程，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒该线程，适用于高并发场景，缺点是有线程上下文切换的开销 Go语言中的Mutex实现了自旋与阻塞两种场景，当满足不了自旋条件时，就会进入阻塞 **允许自旋的条件：** 1. 锁已被占用，并且锁不处于饥饿模式。 2. 积累的自旋次数小于最大自旋次数（active_spin=4）。 3. cpu 核数大于 1。 4. 有空闲的 P。 5. 当前 goroutine 所挂载的 P 下，本地待运行队列为空。 读写锁实现原理 读写锁的底层是基于互斥锁实现的。 写锁需要阻塞写锁：一个协程拥有写锁时，其他协程写锁定需要阻塞； 写锁需要阻塞读锁：一个协程拥有写锁时，其他协程读锁定需要阻塞； 读锁需要阻塞写锁：一个协程拥有读锁时，其他协程写锁定需要阻塞； 读锁不能阻塞读锁：一个协程拥有读锁时，其他协程也可以拥有读锁。 原子操作有哪些 Go atomic包是最轻量级的锁（也称无锁结构），可以在不形成临界区和创建互斥量的情况下完成并发安全的值替换操作，不过这个包只支持int32/int64/uint32/uint64/uintptr这几种数据类型的一些基础操作（增减、交换、载入、存储等） 当我们想要对**某个变量**并发安全的修改，除了使用官方提供的 `mutex`，还可以使用 sync/atomic 包的原子操作，它能够保证对变量的读取或修改期间不被其他的协程所影响。 atomic 包提供的原子操作能够确保任一时刻只有一个goroutine对变量进行操作，善用 atomic 能够避免程序中出现大量的锁操作。 **常见操作：** - 增减Add AddInt32 AddInt64 AddUint32 AddUint64 AddUintptr - 载入Load LoadInt32 LoadInt64 LoadPointer LoadUint32 LoadUint64 LoadUintptr - 比较并交换CompareAndSwap CompareAndSwapInt32... - 交换Swap SwapInt32... - 存储Store StoreInt32... 原子操作和锁的区别 原子操作由底层硬件支持，而锁是基于原子操作+信号量完成的。若实现相同的功能，前者通常会更有效率 原子操作是单个指令的互斥操作；互斥锁/读写锁是一种数据结构，可以完成临界区（多个指令）的互斥操作，扩大原子操作的范围 原子操作是无锁操作，属于乐观锁；说起锁的时候，一般属于悲观锁 原子操作存在于各个指令/语言层级，比如“机器指令层级的原子操作”，“汇编指令层级的原子操作”，“Go语言层级的原子操作”等。 锁也存在于各个指令/语言层级中，比如“机器指令层级的锁”，“汇编指令层级的锁”，“Go语言层级的锁”等 goroutine 的底层实现原理 g本质是一个数据结构,真正让 goroutine 运行起来的是调度器 type g struct { goid int64 // 唯一的goroutine的ID sched gobuf // goroutine切换时，用于保存g的上下文 stack stack // 栈 gopc // pc of go statement that created this goroutine startpc uintptr // pc of goroutine function ... } type gobuf struct { //运行时寄存器 sp uintptr // 栈指针位置 pc uintptr // 运行到的程序位置 g guintptr // 指向 goroutine ret uintptr // 保存系统调用的返回值 ... } type stack struct { //运行时栈 lo uintptr // 栈的下界内存地址 hi uintptr // 栈的上界内存地址 } goroutine 和线程的区别 内存占用: 创建一个 goroutine 的栈内存消耗为 2 KB，实际运行过程中，如果栈空间不够用，会自动进行扩容。创建一个 thread 则需要消耗 1 MB 栈内存。 创建和销毀: Thread 创建和销毀需要陷入内核,系统调用。而 goroutine 因为是由 Go runtime 负责管理的，创建和销毁的消耗非常小，是用户级。 切换: 当 threads 切换时，需要保存各种寄存器,而 goroutines 切换只需保存三个寄存器：Program Counter, Stack Pointer and BP。一般而言，线程切换会消耗 1000-1500 ns,Goroutine 的切换约为 200 ns,因此，goroutines 切换成本比 threads 要小得多。 goroutine 泄露场景 泄露原因 Goroutine 内进行channel/mutex 等读写操作被一直阻塞。 Goroutine 内的业务逻辑进入死循环，资源一直无法释放。 Goroutine 内的业务逻辑进入长时间等待，有不断新增的 Goroutine 进入等待 泄露场景 channel 如果忘记初始化，那么无论你是读，还是写操作，都会造成阻塞。 channel 发送数量 超过 channel接收数量，就会造成阻塞 channel 接收数量 超过 channel发送数量，也会造成阻塞 http request body未关闭，goroutine不会退出 互斥锁忘记解锁 sync.WaitGroup使用不当 如何排查 单个函数：调用 `runtime.NumGoroutine` 方法来打印 执行代码前后Goroutine 的运行数量，进行前后比较，就能知道有没有泄露了。 生产/测试环境：使用`PProf`实时监测Goroutine的数量 如何查看正在运行的 goroutine 数量 package main import ( \u0026#34;net/http\u0026#34; _ \u0026#34;net/http/pprof\u0026#34; ) func main() { for i := 0; i \u0026lt; 100; i++ { go func() { select {} }() } go func() { http.ListenAndServe(\u0026#34;localhost:6060\u0026#34;, nil) }() select {} } 执行程序之后，命令运行以下命令，会自动打开浏览器显示一系列目前还看不懂的图，提示Could not execute dot; may need to install graphviz.则需要安装graphviz，需要python环境 go tool pprof -http=:1248 http://127.0.0.1:6060/debug/pprof/goroutine 如何控制并发的 goroutine 数量？ 在开发过程中，如果不对goroutine加以控制而进行滥用的话，可能会导致服务整体崩溃。比如耗尽系统资源导致程序崩溃，或者CPU使用率过高导致系统忙不过来。 解决方案： 有缓冲channel:利用缓冲满时发送阻塞的特性 无缓冲channel:任务发送和执行分离，指定消费者并发协程数 GO 线程模型如何实现 M个线程对应N个内核线程 优点： - 能够利用多核 - 上下文切换成本低 - 如果进程中的一个线程被阻塞，不会阻塞其他线程，是能够切换同一进程内的其他线程继续执行 GMP 和 GM 模型 G：Goroutine M: 线程 P: Processor 本地队列 GM模型： 2012年前的调度器模型，使用了4年果断被抛弃，缺点如下： 1. 创建、销毁、调度G都需要每个M获取锁，这就形成了激烈的锁竞争。 2. M转移G会造成延迟和额外的系统负载。比如当G中包含创建新协程的时候，M创建了G’，为了继续执行G，需要把G’交给M’执行，也造成了很差的局部性，因为G’和G是相关的，最好放在M上执行，而不是其他M\u0026#39;。 3. 系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。 GMP模型： P的数量： 由启动时环境变量`$GOMAXPROCS`或者是由`runtime`的方法`GOMAXPROCS()`决定 M的数量: go语言本身的限制：go程序启动时，会设置M的最大数量，默认10000.但是内核很难支持这么多的线程数 runtime/debug中的SetMaxThreads函数，设置M的最大数量 一个M阻塞了，会创建新的M。 P何时创建：在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P。 M何时创建：没有足够的M来关联P并运行其中的可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。 全场景解析： 1.P拥有G1，M1获取P后开始运行G1，G1创建了G2，为了局部性G2优先加入到P1的本地队列。 2.G1运行完成后，M上运行的goroutine切换为G0，G0负责调度时协程的切换。从P的本地队列取G2，从G0切换到G2，并开始运行G2。实现了线程M1的复用。 3.假设每个P的本地队列只能存4个G。G2要创建了6个G，前4个G（G3, G4, G5, G6）已经加入p1的本地队列，p1本地队列满了。 4.G2在创建G7的时候，发现P1的本地队列已满，需要执行负载均衡(把P1中本地队列中前一半的G，还有新创建G转移到全局队列)，这些G被转移到全局队列时，会被打乱顺序 5.G2创建G8时，P1的本地队列未满，所以G8会被加入到P1的本地队列。 6.在创建G时，运行的G会尝试唤醒其他空闲的P和M组合去执行。假定G2唤醒了M2，M2绑定了P2，并运行G0，但P2本地队列没有G，M2此时为自旋线程 7.M2尝试从全局队列取一批G放到P2的本地队列，至少从全局队列取1个g，但每次不要从全局队列移动太多的g到p本地队列，给其他p留点。 8.假设G2一直在M1上运行，经过2轮后，M2已经把G7、G4从全局队列获取到了P2的本地队列并完成运行，全局队列和P2的本地队列都空了,那m就要执行work stealing(偷取)：从其他有G的P哪里偷取一半G过来，放到自己的P本地队列。P2从P1的本地队列尾部取一半的G 9.G1本地队列G5、G6已经被其他M偷走并运行完成，当前M1和M2分别在运行G2和G8，M3和M4没有goroutine可以运行，M3和M4处于自旋状态，它们不断寻找goroutine。系统中最多有GOMAXPROCS个自旋的线程，多余的没事做线程会让他们休眠。 10.假定当前除了M3和M4为自旋线程，还有M5和M6为空闲的线程，G8创建了G9，G8进行了阻塞的系统调用，M2和P2立即解绑，P2会执行以下判断：如果P2本地队列有G、全局队列有G或有空闲的M，P2都会立马唤醒1个M和它绑定，否则P2则会加入到空闲P列表，等待M来获取可用的p。 11.G8创建了G9，假如G8进行了非阻塞系统调用。M2和P2会解绑，但M2会记住P2，然后G8和M2进入系统调用状态。当G8和M2退出系统调用时，会尝试获取P2，如果无法获取，则获取空闲的P，如果依然没有，G8会被记为可运行状态，并加入到全局队列,M2因为没有P的绑定而变成休眠状态 work stealing 机制？ 当线程M⽆可运⾏的G时，尝试从其他M绑定的P偷取G，减少空转，提高了线程利用率（避免闲着不干活）。 当从本线程绑定 P 本地 队列、全局G队列、netpoller都找不到可执行的 g，会从别的 P 里窃取G并放到当前P上面。 从netpoller 中拿到的G是_Gwaiting状态（ 存放的是因为网络IO被阻塞的G），从其它地方拿到的G是_Grunnable状态 从全局队列取的G数量：N = min(len(GRQ)/GOMAXPROCS + 1, len(GRQ/2)) （根据GOMAXPROCS负载均衡） 从其它P本地队列窃取的G数量：N = len(LRQ)/2（平分） hand off 机制？ 也称为P分离机制，当本线程 M 因为 G 进行的系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的 M 执行，也提高了线程利用率（避免站着茅坑不拉shi）。 如何查看运行时调度信息？ 有 2 种方式可以查看一个程序的调度GMP信息，分别是go tool trace和GODEBUG 内存分配机制 额，这个不太了解！ 好的你回去等通知吧！ 内存逃逸机制 编译器会根据变量是否被外部引用来决定是否逃逸： 如果函数外部没有引用，则优先放到栈中； 如果函数外部存在引用，则必定放到堆中; 如果栈上放不下，则必定放到堆上; 案例： 指针逃逸：函数返回值为局部变量的指针，函数虽然退出了，但是因为指针的存在，指向的内存不能随着函数结束而回收，因此只能分配在堆上。 栈空间不足：当栈空间足够时，不会发生逃逸，但是当变量过大时，已经完全超过栈空间的大小时，将会发生逃逸到堆上分配内存。局部变量s占用内存过大，编译器会将其分配到堆上 变量大小不确定：编译期间无法确定slice的长度，这种情况为了保证内存的安全，编译器也会触发逃逸，在堆上进行分配内存 动态类型：动态类型就是编译期间不确定参数的类型、参数的长度也不确定的情况下就会发生逃逸 闭包引用对象：闭包函数中局部变量i在后续函数是继续使用的，编译器将其分配到堆上 总结： 1. 栈上分配内存比在堆中分配内存效率更高 2. 栈上分配的内存不需要 GC 处理，而堆需要 3. 逃逸分析目的是决定内分配地址是栈还是堆 4. 逃逸分析在编译阶段完成 因为无论变量的大小，只要是指针变量都会在堆上分配，所以对于小变量我们还是使用传值效率（而不是传指针）更高一点。 GO 内存对齐机制 什么是内存对齐 为了能让CPU可以更快的存取到各个字段，Go编译器会帮你把struct结构体做数据的对齐。所谓的数据对齐，是指内存地址是所存储数据大小（按字节为单位）的整数倍，以便CPU可以一次将该数据从内存中读取出来。编译器通过在结构体的各个字段之间填充一些空白已达到对齐的目的。存在内存空间的浪费，实际上是空间换时间 对齐原则： 1. 结构体变量中成员的偏移量必须是成员大小的整数倍 2. 整个结构体的地址必须是最大字节的整数倍 GC 实现原理 在应用程序中会使用到两种内存，分别为堆（Heap）和栈（Stack），GC负责回收堆内存，而不负责回收栈中的内存 常用GC算法 1.引用计数：python,swift,php 2.分代收集：Java 3.标记清除：GO 三色标记法+混合屏障 停顿时间在0.5ms左右 GC 如何调优 1.控制内存分配的速度，限制 Goroutine 的数量，提高赋值器 mutator 的 CPU 利用率（降低GC的CPU利用率） 2.少量使用+连接string 3.slice提前分配足够的内存来降低扩容带来的拷贝 4.避免map key对象过多，导致扫描时间增加 5.变量复用，减少对象分配，例如使用 sync.Pool 来复用需要频繁创建临时对象、使用全局变量等 6.增大 GOGC 的值，降低 GC 的运行频率 (不太用这个) 如何查看 GC 信息 1. GODEBUG=\u0026#39;gctrace=1\u0026#39; go run main.go 2. go tool trace trace.out 3. debug.ReadGCStats 4. runtime.ReadMemStats Go 有哪些并发同步原语？ 额，这个不太了解！ 好的你回去等通知吧！ Go 如何排查数据竞争问题？ go run -race main.go Go 限制协程数、按顺序打印 cat、dog、fish 各 100 次 好无聊的面试题，正常人谁这么写代码\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) var wg sync.WaitGroup func dog(dogChan chan bool, catChan chan bool) { i := 0 for { select { case \u0026lt;-dogChan: fmt.Println(\u0026#34;dog\u0026#34;, i) i++ catChan \u0026lt;- true break default: break } } } func cat(catChan chan bool, fishChan chan bool) { for { select { case \u0026lt;-catChan: fmt.Println(\u0026#34;cat\u0026#34;) fishChan \u0026lt;- true break default: break } } } func fish(fishChan chan bool, dogChan chan bool) { i := 0 for { select { case \u0026lt;-fishChan: fmt.Println(\u0026#34;fish\u0026#34;) i++ // 计数，打印完之后就溜溜结束了。 if i \u0026gt; 9 { wg.Done() return } dogChan \u0026lt;- true break default: break } } } func main() { dogChan, catChan, fishChan := make(chan bool), make(chan bool), make(chan bool) wg.Add(1) go dog(dogChan, catChan) go cat(catChan, fishChan) go fish(fishChan, dogChan) dogChan \u0026lt;- true // 记得这里进行启动条件，不然就没法启动了。 wg.Wait() } 代码题 func main() { a := [3]int{1, 2, 3} for k, v := range a { if k == 0 { a[0], a[1] = 100, 200 } a[k] = 100 + v } fmt.Print(a) //数组 101 102 103 } func main() { a := []int{1, 2, 3} for k, v := range a { if k == 0 { a[0], a[1] = 100, 200 } a[k] = 100 + v } fmt.Print(a) //切片 101 300 103 } package main import \u0026#34;fmt\u0026#34; func main() { var a uint = 0 var b uint = 1 c := a - b fmt.Print(c) //18446744073709551615 64位CPU 2^64-1 32位CPU 2^32-1 } ","permalink":"https://liiqii.github.io/posts/tech/go/go_interview_questions_quick_answer/","summary":"转自：GO面试题集锦快答[持续更新] slice 扩容机制 GO1.17版本及之前 当新切片需要的容量cap大于两倍扩容的容量，则直接按照新切片需要的容量扩容； 当原 slice 容量 \u0026lt; 1024 的时候，新 slice 容量变成原来的 2 倍； 当原 slice 容量 \u0026gt; 1024，进入一个循环，每次容量变成原来的1.25倍,直到大于期望容量。 GO1","title":"Go 面试题集锦快答"},{"content":"go build 这个命令主要用于编译代码。在包的编译过程中，若有必要，会同时编译与之相关联的包。\n如果是普通包，就像我们在1.2节中编写的mymath包那样，当你执行go build之后，它不会产生任何文件。如果你需要在$GOPATH/pkg下生成相应的文件，那就得执行go install。\n如果是main包，当你执行go build之后，它就会在当前目录下生成一个可执行文件。如果你需要在$GOPATH/bin下生成相应的文件，需要执行go install，或者使用go build -o 路径/a.exe。\n如果某个项目文件夹下有多个文件，而你只想编译某个文件，就可在go build之后加上文件名，例如go build a.go；go build命令默认会编译当前目录下的所有go文件。\n你也可以指定编译输出的文件名。例如1.2节中的mathapp应用，我们可以指定go build -o astaxie.exe，默认情况是你的package名(非main包)，或者是第一个源文件的文件名(main包)。\n（注：实际上，package名在Go语言规范中指代码中“package”后使用的名称，此名称可以与文件夹名不同。默认生成的可执行文件名是文件夹名。）\ngo build会忽略目录下以“_”或“.”开头的go文件。\n如果你的源代码针对不同的操作系统需要不同的处理，那么你可以根据不同的操作系统后缀来命名文件。例如有一个读取数组的程序，它对于不同的操作系统可能有如下几个源文件：\narray_linux.go array_darwin.go array_windows.go array_freebsd.go\ngo build的时候会选择性地编译以系统名结尾的文件（Linux、Darwin、Windows、Freebsd）。例如Linux系统下面编译只会选择array_linux.go文件，其它系统命名后缀文件全部忽略。\n参数的介绍\n-o 指定输出的文件名，可以带上路径，例如 go build -o a/b/c -i 安装相应的包，编译+go install -a 更新全部已经是最新的包的，但是对标准包不适用 -n 把需要执行的编译命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的 -p n 指定可以并行可运行的编译数目，默认是CPU数目 -race 开启编译的时候自动检测数据竞争的情况，目前只支持64位的机器 -v 打印出来我们正在编译的包名 -work 打印出来编译时候的临时文件夹名称，并且如果已经存在的话就不要删除 -x 打印出来执行的命令，其实就是和-n的结果类似，只是这个会执行 -ccflags 'arg list' 传递参数给5c, 6c, 8c 调用 -compiler name 指定相应的编译器，gccgo还是gc -gccgoflags 'arg list' 传递参数给gccgo编译连接调用 -gcflags 'arg list' 传递参数给5g, 6g, 8g 调用 -installsuffix suffix 为了和默认的安装包区别开来，采用这个前缀来重新安装那些依赖的包，-race的时候默认已经是-installsuffix race,大家可以通过-n命令来验证 -ldflags 'flag list' 传递参数给5l, 6l, 8l 调用 -tags 'tag list' 设置在编译的时候可以适配的那些tag，详细的tag限制参考里面的 Build Constraints go clean 这个命令是用来移除当前源码包和关联源码包里面编译生成的文件。这些文件包括\n_obj/ 旧的object目录，由Makefiles遗留\r_test/ 旧的test目录，由Makefiles遗留\r_testmain.go 旧的gotest文件，由Makefiles遗留\rtest.out 旧的test记录，由Makefiles遗留\rbuild.out 旧的test记录，由Makefiles遗留\r*.[568ao] object文件，由Makefiles遗留\rDIR(.exe) 由go build产生\rDIR.test(.exe) 由go test -c产生\rMAINFILE(.exe) 由go build MAINFILE.go产生\r*.so 由 SWIG 产生\r我一般都是利用这个命令清除编译文件，然后GitHub递交源码，在本机测试的时候这些编译文件都是和系统相关的，但是对于源码管理来说没必要。\n$ go clean -i -n\rcd /Users/astaxie/develop/gopath/src/mathapp\rrm -f mathapp mathapp.exe mathapp.test mathapp.test.exe app app.exe\rrm -f /Users/astaxie/develop/gopath/bin/mathapp\r参数介绍\n-i 清除关联的安装的包和可运行文件，也就是通过go install安装的文件 -n 把需要执行的清除命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的 -r 循环的清除在import中引入的包 -x 打印出来执行的详细命令，其实就是-n打印的执行版本 go fmt 有过C/C++经验的读者会知道,一些人经常为代码采取K\u0026amp;R风格还是ANSI风格而争论不休。在go中，代码则有标准的风格。由于之前已经有的一些习惯或其它的原因我们常将代码写成ANSI风格或者其它更合适自己的格式，这将为人们在阅读别人的代码时添加不必要的负担，所以go强制了代码格式（比如左大括号必须放在行尾），不按照此格式的代码将不能编译通过，为了减少浪费在排版上的时间，go工具集中提供了一个go fmt命令 它可以帮你格式化你写好的代码文件，使你写代码的时候不需要关心格式，你只需要在写完之后执行go fmt \u0026lt;文件名\u0026gt;.go，你的代码就被修改成了标准格式，但是我平常很少用到这个命令，因为开发工具里面一般都带了保存时候自动格式化功能，这个功能其实在底层就是调用了go fmt。接下来的一节我将讲述两个工具，这两个工具都自带了保存文件时自动化go fmt功能。\n使用go fmt命令，其实是调用了gofmt，而且需要参数-w，否则格式化结果不会写入文件。gofmt -w -l src，可以格式化整个项目。\n所以go fmt是gofmt的上层一个包装的命令，我们想要更多的个性化的格式化可以参考 gofmt\ngofmt的参数介绍\n-l 显示那些需要格式化的文件 -w 把改写后的内容直接写入到文件中，而不是作为结果打印到标准输出。 -r 添加形如“a[b:len(a)] -\u0026gt; a[b:]”的重写规则，方便我们做批量替换 -s 简化文件中的代码 -d 显示格式化前后的diff而不是写入文件，默认是false -e 打印所有的语法错误到标准输出。如果不使用此标记，则只会打印不同行的前10个错误。 -cpuprofile 支持调试模式，写入相应的cpufile到指定的文件 go get 这个命令是用来动态获取远程代码包的，目前支持的有BitBucket、GitHub、Google Code和Launchpad。这个命令在内部实际上分成了两步操作：第一步是下载源码包，第二步是执行go install。下载源码包的go工具会自动根据不同的域名调用不同的源码工具，对应关系如下：\nBitBucket (Mercurial Git)\rGitHub (Git)\rGoogle Code Project Hosting (Git, Mercurial, Subversion)\rLaunchpad (Bazaar)\r所以为了go get 能正常工作，你必须确保安装了合适的源码管理工具，并同时把这些命令加入你的PATH中。其实go get支持自定义域名的功能，具体参见go help remote。\n参数介绍：\n-d 只下载不安装 -f 只有在你包含了-u参数的时候才有效，不让-u去验证import中的每一个都已经获取了，这对于本地fork的包特别有用 -fix 在获取源码之后先运行fix，然后再去做其他的事情 -t 同时也下载需要为运行测试所需要的包 -u 强制使用网络去更新包和它的依赖包 -v 显示执行的命令 go install 这个命令在内部实际上分成了两步操作：第一步是生成结果文件(可执行文件或者.a包)，第二步会把编译好的结果移到$GOPATH/pkg或者$GOPATH/bin。\n参数支持go build的编译参数。大家只要记住一个参数-v就好了，这个随时随地的可以查看底层的执行信息。\ngo test 执行这个命令，会自动读取源码目录下面名为*_test.go的文件，生成并运行测试用的可执行文件。输出的信息类似\nok archive/tar 0.011s\rFAIL archive/zip 0.022s\rok compress/gzip 0.033s\r...\r默认的情况下，不需要任何的参数，它会自动把你源码包下面所有test文件测试完毕，当然你也可以带上参数，详情请参考go help testflag\n这里我介绍几个我们常用的参数：\n-bench regexp 执行相应的benchmarks，例如 -bench=. -cover 开启测试覆盖率 -run regexp 只运行regexp匹配的函数，例如 -run=Array 那么就执行包含有Array开头的函数 -v 显示测试的详细命令 go tool go tool下面下载聚集了很多命令，这里我们只介绍两个，fix和vet\ngo tool fix . 用来修复以前老版本的代码到新版本，例如go1之前老版本的代码转化到go1,例如API的变化 go tool vet directory|files 用来分析当前目录的代码是否都是正确的代码,例如是不是调用fmt.Printf里面的参数不正确，例如函数里面提前return了然后出现了无用代码之类的。 go generate 这个命令是从Go1.4开始才设计的，用于在编译前自动化生成某类代码。go generate和go build是完全不一样的命令，通过分析源码中特殊的注释，然后执行相应的命令。这些命令都是很明确的，没有任何的依赖在里面。而且大家在用这个之前心里面一定要有一个理念，这个go generate是给你用的，不是给使用你这个包的人用的，是方便你来生成一些代码的。\n这里我们来举一个简单的例子，例如我们经常会使用yacc来生成代码，那么我们常用这样的命令：\ngo tool yacc -o gopher.go -p parser gopher.y\r-o 指定了输出的文件名， -p指定了package的名称，这是一个单独的命令，如果我们想让go generate来触发这个命令，那么就可以在当前目录的任意一个xxx.go文件里面的任意位置增加一行如下的注释：\n//go:generate go tool yacc -o gopher.go -p parser gopher.y\r这里我们注意了，//go:generate是没有任何空格的，这其实就是一个固定的格式，在扫描源码文件的时候就是根据这个来判断的。\n所以我们可以通过如下的命令来生成，编译，测试。如果gopher.y文件有修改，那么就重新执行go generate重新生成文件就好。\n$ go generate\r$ go build\r$ go test\rgodoc 在Go1.2版本之前还支持go doc命令，但是之后全部移到了godoc这个命令下，需要这样安装go get golang.org/x/tools/cmd/godoc\n很多人说go不需要任何的第三方文档，例如chm手册之类的（其实我已经做了一个了，chm手册），因为它内部就有一个很强大的文档工具。\n如何查看相应package的文档呢？ 例如builtin包，那么执行godoc builtin 如果是http包，那么执行godoc net/http 查看某一个包里面的函数，那么执行godoc fmt Printf 也可以查看相应的代码，执行godoc -src fmt Printf\n通过命令在命令行执行 godoc -http=:端口号 比如godoc -http=:8080。然后在浏览器中打开127.0.0.1:8080，你将会看到一个golang.org的本地copy版本，通过它你可以查询pkg文档等其它内容。如果你设置了GOPATH，在pkg分类下，不但会列出标准包的文档，还会列出你本地GOPATH中所有项目的相关文档，这对于经常被墙的用户来说是一个不错的选择。\n其它命令 go还提供了其它很多的工具，例如下面的这些工具\ngo version 查看go当前的版本\rgo env 查看当前go的环境变量\rgo list 列出当前全部安装的package\rgo run 编译并运行Go程序\r以上这些工具还有很多参数没有一一介绍，用户可以使用go help 命令获取更详细的帮助信息。\n","permalink":"https://liiqii.github.io/posts/tech/go/go_command/","summary":"go build 这个命令主要用于编译代码。在包的编译过程中，若有必要，会同时编译与之相关联的包。 如果是普通包，就像我们在1.2节中编写的mymath包那样，当你执行go build之后，它不会产生任何文件。如果你需要在$GOPATH/pkg下生成相应的文件，那就得执行go install。 如果是","title":"Go 命令"},{"content":"1.冒泡排序 从头开始两两互比然后进行交换。将最大值/最小值 冒到最后一位。依次循环\nfunc bubbleSort(nums []int){ for i:=0;i\u0026lt;len(nums)-1;i++{ // 循环次数 for j:=0;j\u0026lt;len(nums)-1-i;j++{ // 数组内相邻元素比较 if nums[j]\u0026gt;nums[j+1]{ // 交换条件 nums[j],nums[j+1]=nums[j+1],nums[j] // 元素交换 } } } } 2.选择排序 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置; 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾; （一次在元素中选择符合需求的元素，然后交换。每个元素只移动一次）\nfunc selectSorted(nums []int) { for i := 0; i \u0026lt; len(nums)-1; i++ { // 从第一个元素开始 min := i // 默认当前元素为最小元素。保存对应下标 for j := i + 1; j \u0026lt; len(nums); j++ { if nums[min] \u0026gt; nums[j] { // 找到最小的元素 min = j // 保存最小的值min(下标) } } nums[i], nums[min] = nums[min], nums[i] //交换元素 } } 3.插入排序 可以假设前面的已经有序，随机在后面抽取一个元素，插入到前面，并保持有序； 已排好序的依次后移！！！ （扑克牌：每拿起一张，插入到合适的位置。之前的已经有序）\nfunc insertSorted(nums []int) { for i := 1; i \u0026lt; len(nums); i++ { preIndex := i - 1 // 记录当前值对应前一个元素的下标 nowNum := nums[i] // 记录当前值 for nums[preIndex] \u0026gt; nowNum { // 循环到前面的值不小于当前值为止 nums[preIndex+1] = nums[preIndex] // 将小于当前值的数后移 preIndex-- } nums[preIndex+1] = nowNum // 找到了不小于当前置的位置并赋值 } } 4.希尔排序 本质是 分组+插入排序 也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是 非稳定 排序算法。 实践中：数据的交换次数远远小于插入排序的交换次数\nfunc shellSorted(nums []int) { lens := len(nums) tag := 1 // 选取合适的分组树(即：每组的数据个数) for tag \u0026lt; lens/3 { tag = 3*tag + 1 // 比较合适的分组数 } for tag \u0026gt; 0 { for i := tag; i \u0026lt; lens; i++ { // 依旧采用插入算法逻辑，只是跨度变大，以分组为间隔 j := i - tag temp := nums[i] for j \u0026gt;= 0 \u0026amp;\u0026amp; nums[j] \u0026gt; temp { nums[j+tag] = nums[j] j -= tag } nums[j+tag] = temp } tag /= 3 // tag逐渐缩小，最后为 1 } } 5.归并排序 乱序数组，单个元素为一组，两两对比排序；然后已排序数据2个为一组，两两对比排序，以此类推 总结：先分后合(合的时候排好序)\nfunc mergeSorted(nums []int) []int { length := len(nums) if length \u0026lt; 2 { return nums } left := nums[:length/2] right := nums[length/2:] return merge(mergeSorted(left), mergeSorted(right)) } //传入的两个数组进行合并排序 func merge(left []int, right []int) []int { var res []int // 两数组对比，小的先放入结果表 for len(left) \u0026gt; 0 \u0026amp;\u0026amp; len(right) \u0026gt; 0 { if left[0] \u0026lt;= right[0] { res = append(res, left[0]) left = left[1:] } else { res = append(res, right[0]) right = right[1:] } } // left或者right其中一个未添加完毕 if len(left) \u0026gt; 0 { res = append(res, left...) } if len(right) \u0026gt; 0 { res = append(res, right...) } return res } 6.快速排序 在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较 随机取一个树(一般是第一个数)，一次比较，比他小的放左边，大的放右边，依次类推 个人感觉：和归并反着来！ 每一次分开，左右都对应已比较完成！ 1、从数列中挑出一个元素，称为 “基准”（pivot）; 2、重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 3、递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序； 优化： 1、机选三个数，取中间的数为 基准 2、当数组比较小的时候采用插入算法，更快\nfunc quickSorted(nums []int) []int { return quick(nums, 0, len(nums)-1) } func quick(arr []int, left, right int) []int { if left \u0026lt; right { //分次执行 partitionVal := partition(arr, left, right) quick(arr, left, partitionVal-1) // 先递归把左边的排完 quick(arr, partitionVal+1, right) // 再依次由深到浅排序右边 } return arr } func partition(arr []int, left, right int) int { pivot := left index := left + 1 for i := index; i \u0026lt;= right; i++ { if arr[i] \u0026lt; arr[pivot] { swap(arr, i, index) // 调换基数的位置 index++ } } swap(arr, pivot, index-1) //最后一个空位补上 return index - 1 } func swap(arr []int, left, right int) { arr[left], arr[right] = arr[right], arr[left] } 7.堆排序 堆的特点: 完全二叉树、（大顶堆) 所有父节点大于子节点 1、构建一个堆(所有值小于父节点) 2、把堆首和队尾互换 3、堆的大小减一，并重构堆，目的是把最大值放入堆头 4、重复2/3\n// 堆排序的实现 // 1、建堆 // 2、堆尾和堆头互换，取出堆头，堆容量缩小一个单位 // 3、重读1/2 // 传入一个数组 func heapSorted(arr []int) []int { arrlen := len(arr) buildHeap(arr, arrlen) fmt.Println(arr) // 堆已建造完成，堆头与堆尾交换，堆长减一 for arrlen \u0026gt; 0 { swap(arr, 0, arrlen-1) arrlen -= 1 heapify(arr, 0, arrlen) } return arr } // 将数组建造成堆格式 func buildHeap(arr []int, arrlen int) { for i := arrlen / 2; i \u0026gt;= 0; i-- { heapify(arr, i, arrlen) } } // 实际down与swap过程 func heapify(arr []int, i, arrlen int) { left := 2*i + 1 right := 2*i + 2 parent := i // 比较时，找出left与right对应的最大值与之兑换 if left \u0026lt; arrlen \u0026amp;\u0026amp; arr[left] \u0026gt; arr[parent] { parent = left } if right \u0026lt; arrlen \u0026amp;\u0026amp; arr[right] \u0026gt; arr[parent] { parent = right } if parent != i { swap(arr, i, parent) // 用来排除孩子的孩子(第一次建堆时作用可能不大，但是当后面互换后 ，堆顶元素一路向下) heapify(arr, parent, arrlen) } } // 用于两个元素交换 func swap(arr []int, i, j int) { arr[i], arr[j] = arr[j], arr[i] } 8.计数排序 1、根据待排序集合中最大元素和最小元素的差值范围，申请额外空间； 2、遍历待排序集合，将每一个元素出现的次数记录到元素值对应的额外空间内； 3、对额外空间内数据进行计算，得出每一个元素的正确位置； 4、将待排序集合每一个元素移动到计算得出的正确位置上。 即： 将相同的数，统计出现次数，然后从小到大，把该数取出对应的次数\n// 计数排序(一般用书较集中数据) // 先确定取值范围 // 创建范围内大小的值，统计 // 注：需要额外空间 func counrSorted(arr []int) []int { // 先获取取值范围大小 // 考虑可能存在负数（两次遍历） min, max := 0, 0 for i := 0; i \u0026lt; len(arr); i++ { if arr[i] \u0026gt; max { max = arr[i] } if arr[i] \u0026lt; min { min = arr[i] } } // 创建计数器 blen := max - min + 1 bucket := make([]int, blen) fmt.Println(blen) // 统计 for i := 0; i \u0026lt; len(arr); i++ { bucket[arr[i]-min] += 1 } // 原数组中移动 index := 0 for i := 0; i \u0026lt; len(bucket); i++ { for bucket[i] \u0026gt; 0 { arr[index] = i - min index++ bucket[i]-- } } return arr } 9.桶排序 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。 桶排序 (Bucket sort)的工作的原理： 假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排） 计数排序时对单个数据，桶排序是对一组数据。分配再排序\nfunc bucketSorted(arr []int){ vari; varminValue = arr[0]; varmaxValue = arr[0]; for(i = 1; i \u0026lt; arr.length; i++) { if(arr[i] \u0026lt; minValue) { minValue = arr[i]; // 输入数据的最小值 }elseif(arr[i] \u0026gt; maxValue) { maxValue = arr[i]; // 输入数据的最大值 } } // 桶的初始化 varDEFAULT_BUCKET_SIZE = 5; // 设置桶的默认数量为5 bucketSize = bucketSize || DEFAULT_BUCKET_SIZE; varbucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; varbuckets =newArray(bucketCount); for(i = 0; i \u0026lt; buckets.length; i++) { buckets[i] = []; } // 利用映射函数将数据分配到各个桶中 for(i = 0; i \u0026lt; arr.length; i++) { buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]); } arr.length = 0; for(i = 0; i \u0026lt; buckets.length; i++) { insertionSort(buckets[i]); // 对每个桶进行排序，这里使用了插入排序 for(varj = 0; j \u0026lt; buckets[i].length; j++) { arr.push(buckets[i][j]); } } return arr; } 10.基数排序 基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数 对数字或者字符串进行拆分，单个对比的排序。以此类推\n// 基数排序 func radixSorted(arr []int) []int { // 统计最大子串长度 max := -1 length := len(arr) // 获取最大数 for i := 0; i \u0026lt; length; i++ { if max \u0026lt; arr[i] { max = arr[i] } } // 获取最大位数 maxlen := 0 for max \u0026gt; 0 { maxlen++ max /= 10 } // 开始 bucket := [10][20]int{{0}} count := [10]int{0} divisor := 1 for i := 1; i \u0026lt;= maxlen; i++ { // 先放入桶中，然后排好序，依次类推 for j := 0; j \u0026lt; length; j++ { tmp := arr[j] index := (tmp / divisor) % 10 bucket[index][count[index]] = tmp count[index]++ } // 原数组重新排序 k := 0 for m := 0; m \u0026lt; len(bucket); m++ { if count[m] == 0 { continue } for n := 0; n \u0026lt; count[n]; n++ { arr[k] = bucket[m][n] k++ } // 桶清零 bucket[m] = [20]int{0} } divisor *= 10 } return arr } ","permalink":"https://liiqii.github.io/posts/tech/go/go_sort_algo/","summary":"1.冒泡排序 从头开始两两互比然后进行交换。将最大值/最小值 冒到最后一位。依次循环 func bubbleSort(nums []int){ for i:=0;i\u0026lt;len(nums)-1;i++{ // 循环次数 for j:=0;j\u0026lt;len(nums)-1-i;j++{ // 数组内相邻元素比较 if nums[j]\u0026gt;nums[j+1]{ // 交换条件 nums[j],nums[j+1]=nums[j+1],nums[j] // 元素交换 } } } } 2.选择排序 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置; 再从剩余未排序元素中继续寻找最小（大）元素，然后放","title":"Go 排序算法实现"},{"content":"概要 UNIX 的一个基础设计就是”万物皆文件”(everything is a file). 我们不必知道一个文件到底映射成什么,操作系统的设备驱动抽象成文件.操作系统为设备提供了文件格式的接口.\nGo语言中的reader和writer接口也类似.我们只需简单的读写字节,不必知道reader的数据来自哪里,也不必知道writer将数据发送到哪里. 您可以在/dev下查看可用的设备,有些可能需要较高的权限才能访问.\n1.创建空文件 package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { emptyFile, err := os.Create(\u0026#34;empty.txt\u0026#34;) if err != nil { log.Fatal(err) } log.Println(emptyFile) emptyFile.Close() } 创建空文件 package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { _, err := os.Stat(\u0026#34;test\u0026#34;) if os.IsNotExist(err) { errDir := os.MkdirAll(\u0026#34;test\u0026#34;, 0755) if errDir != nil { log.Fatal(err) } } } 重命名文件 package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { oldName := \u0026#34;test.txt\u0026#34; newName := \u0026#34;testing.txt\u0026#34; err := os.Rename(oldName, newName) if err != nil { log.Fatal(err) } } 移动文件 os.Rename() 可以用来重命名和移动文件\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { oldLocation := \u0026#34;/var/www/html/test.txt\u0026#34; newLocation := \u0026#34;/var/www/html/src/test.txt\u0026#34; err := os.Rename(oldLocation, newLocation) if err != nil { log.Fatal(err) } } 复制文件 io.Coppy是复制文件的关键\npackage main import ( \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { sourceFile, err := os.Open(\u0026#34;/var/www/html/src/test.txt\u0026#34;) if err != nil { log.Fatal(err) } defer sourceFile.Close() // Create new file newFile, err := os.Create(\u0026#34;/var/www/html/test.txt\u0026#34;) if err != nil { log.Fatal(err) } defer newFile.Close() bytesCopied, err := io.Copy(newFile, sourceFile) if err != nil { log.Fatal(err) } log.Printf(\u0026#34;Copied %d bytes.\u0026#34;, bytesCopied) } 获取文件的metadata信息: os.Stat() package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { fileStat, err := os.Stat(\u0026#34;test.txt\u0026#34;) if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;File Name:\u0026#34;, fileStat.Name()) // Base name of the file fmt.Println(\u0026#34;Size:\u0026#34;, fileStat.Size()) // Length in bytes for regular files fmt.Println(\u0026#34;Permissions:\u0026#34;, fileStat.Mode()) // File mode bits fmt.Println(\u0026#34;Last Modified:\u0026#34;, fileStat.ModTime()) // Last modification time fmt.Println(\u0026#34;Is Directory: \u0026#34;, fileStat.IsDir()) // Abbreviation for Mode().IsDir() } 删除文件: os.Remove() package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { err := os.Remove(\u0026#34;/var/www/html/test.txt\u0026#34;) if err != nil { log.Fatal(err) } } 读取文件字符: bufio.NewScanner() package main import ( \u0026#34;bufio\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; ) func main() { filename := \u0026#34;test.txt\u0026#34; filebuffer, err := ioutil.ReadFile(filename) if err != nil { fmt.Println(err) os.Exit(1) } inputdata := string(filebuffer) data := bufio.NewScanner(strings.NewReader(inputdata)) data.Split(bufio.ScanRunes) for data.Scan() { fmt.Print(data.Text()) } } 清除文件 os.Truncate() 说明\n裁剪一个文件到100个字节. 如果文件本来就少于100个字节,则文件中原始内容得以保留,剩余的字节以null字节填充. 如果文件本来超过100个字节,则超过的字节会被抛弃. 这样我们总是得到精确的100个字节的文件. 传入0则会清空文件. package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { err := os.Truncate(\u0026#34;test.txt\u0026#34;, 100) if err != nil { log.Fatal(err) } } 向文件添加内容 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { message := \u0026#34;Add this content at end\u0026#34; filename := \u0026#34;test.txt\u0026#34; f, err := os.OpenFile(filename, os.O_RDWR|os.O_APPEND|os.O_CREATE, 0660) if err != nil { fmt.Println(err) os.Exit(-1) } defer f.Close() fmt.Fprintf(f, \u0026#34;%s\\n\u0026#34;, message) } 修改文件权限,时间戳 package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;time\u0026#34; ) func main() { // Test File existence. _, err := os.Stat(\u0026#34;test.txt\u0026#34;) if err != nil { if os.IsNotExist(err) { log.Fatal(\u0026#34;File does not exist.\u0026#34;) } } log.Println(\u0026#34;File exist.\u0026#34;) // Change permissions Linux. err = os.Chmod(\u0026#34;test.txt\u0026#34;, 0777) if err != nil { log.Println(err) } // Change file ownership. err = os.Chown(\u0026#34;test.txt\u0026#34;, os.Getuid(), os.Getgid()) if err != nil { log.Println(err) } // Change file timestamps. addOneDayFromNow := time.Now().Add(24 * time.Hour) lastAccessTime := addOneDayFromNow lastModifyTime := addOneDayFromNow err = os.Chtimes(\u0026#34;test.txt\u0026#34;, lastAccessTime, lastModifyTime) if err != nil { log.Println(err) } } 压缩文件到ZIP格式 package main import ( \u0026#34;archive/zip\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func appendFiles(filename string, zipw *zip.Writer) error { file, err := os.Open(filename) if err != nil { return fmt.Errorf(\u0026#34;Failed to open %s: %s\u0026#34;, filename, err) } defer file.Close() wr, err := zipw.Create(filename) if err != nil { msg := \u0026#34;Failed to create entry for %s in zip file: %s\u0026#34; return fmt.Errorf(msg, filename, err) } if _, err := io.Copy(wr, file); err != nil { return fmt.Errorf(\u0026#34;Failed to write %s to zip: %s\u0026#34;, filename, err) } return nil } func main() { flags := os.O_WRONLY | os.O_CREATE | os.O_TRUNC file, err := os.OpenFile(\u0026#34;test.zip\u0026#34;, flags, 0644) if err != nil { log.Fatalf(\u0026#34;Failed to open zip for writing: %s\u0026#34;, err) } defer file.Close() var files = []string{\u0026#34;test1.txt\u0026#34;, \u0026#34;test2.txt\u0026#34;, \u0026#34;test3.txt\u0026#34;} zipw := zip.NewWriter(file) defer zipw.Close() for _, filename := range files { if err := appendFiles(filename, zipw); err != nil { log.Fatalf(\u0026#34;Failed to add file %s to zip: %s\u0026#34;, filename, err) } } } 读取ZIP文件里面的文件 package main import ( \u0026#34;archive/zip\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func listFiles(file *zip.File) error { fileread, err := file.Open() if err != nil { msg := \u0026#34;Failed to open zip %s for reading: %s\u0026#34; return fmt.Errorf(msg, file.Name, err) } defer fileread.Close() fmt.Fprintf(os.Stdout, \u0026#34;%s:\u0026#34;, file.Name) if err != nil { msg := \u0026#34;Failed to read zip %s for reading: %s\u0026#34; return fmt.Errorf(msg, file.Name, err) } fmt.Println() return nil } func main() { read, err := zip.OpenReader(\u0026#34;test.zip\u0026#34;) if err != nil { msg := \u0026#34;Failed to open: %s\u0026#34; log.Fatalf(msg, err) } defer read.Close() for _, file := range read.File { if err := listFiles(file); err != nil { log.Fatalf(\u0026#34;Failed to read %s from zip: %s\u0026#34;, file.Name, err) } } } 解压ZIP文件 package main import ( \u0026#34;archive/zip\u0026#34; \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;path/filepath\u0026#34; ) func main() { zipReader, _ := zip.OpenReader(\u0026#34;test.zip\u0026#34;) for _, file := range zipReader.Reader.File { zippedFile, err := file.Open() if err != nil { log.Fatal(err) } defer zippedFile.Close() targetDir := \u0026#34;./\u0026#34; extractedFilePath := filepath.Join( targetDir, file.Name, ) if file.FileInfo().IsDir() { log.Println(\u0026#34;Directory Created:\u0026#34;, extractedFilePath) os.MkdirAll(extractedFilePath, file.Mode()) } else { log.Println(\u0026#34;File extracted:\u0026#34;, file.Name) outputFile, err := os.OpenFile( extractedFilePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, file.Mode(), ) if err != nil { log.Fatal(err) } defer outputFile.Close() _, err = io.Copy(outputFile, zippedFile) if err != nil { log.Fatal(err) } } } } 目录操作 文件操作的大多数函数都是在 os 包里面，下面列举了几个目录操作的：\nfunc Mkdir(name string, perm FileMode) error\n创建名称为 name 的目录，权限设置是 perm，例如 0777\nfunc MkdirAll(path string, perm FileMode) error\n根据 path 创建多级子目录，例如 astaxie/test1/test2。\nfunc Remove(name string) error\n删除名称为 name 的目录，当目录下有文件或者其他目录时会出错\nfunc RemoveAll(path string) error\n根据 path 删除多级子目录，如果 path 是单个名称，那么该目录下的子目录全部删除。\n下面是演示代码：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { os.Mkdir(\u0026#34;astaxie\u0026#34;, 0777) os.MkdirAll(\u0026#34;astaxie/test1/test2\u0026#34;, 0777) err := os.Remove(\u0026#34;astaxie\u0026#34;) if err != nil { fmt.Println(err) } os.RemoveAll(\u0026#34;astaxie\u0026#34;) } 文件操作 建立与打开文件 新建文件可以通过如下两个方法\nfunc Create(name string) (file \\*File, err Error)\n根据提供的文件名创建新的文件，返回一个文件对象，默认权限是 0666 的文件，返回的文件对象是可读写的。\nfunc NewFile(fd uintptr, name string) \\*File\n根据文件描述符创建相应的文件，返回一个文件对象\n通过如下两个方法来打开文件：\nfunc Open(name string) (file \\*File, err Error)\n该方法打开一个名称为 name 的文件，但是是只读方式，内部实现其实调用了 OpenFile。\nfunc OpenFile(name string, flag int, perm uint32) (file \\*File, err Error)\n打开名称为 name 的文件，flag 是打开的方式，只读、读写等，perm 是权限\n写文件 写文件函数：\nfunc (file \\*File) Write(b \\[\\]byte) (n int, err Error)\n写入 byte 类型的信息到文件\nfunc (file \\*File) WriteAt(b \\[\\]byte, off int64) (n int, err Error)\n在指定位置开始写入 byte 类型的信息\nfunc (file \\*File) WriteString(s string) (ret int, err Error)\n写入 string 信息到文件\n写文件的示例代码\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { userFile := \u0026#34;astaxie.txt\u0026#34; fout, err := os.Create(userFile) if err != nil { fmt.Println(userFile, err) return } defer fout.Close() for i := 0; i \u0026lt; 10; i++ { fout.WriteString(\u0026#34;Just a test!\\r\\n\u0026#34;) fout.Write([]byte(\u0026#34;Just a test!\\r\\n\u0026#34;)) } } 读文件 读文件函数：\nfunc (file \\*File) Read(b \\[\\]byte) (n int, err Error)\n读取数据到 b 中\nfunc (file \\*File) ReadAt(b \\[\\]byte, off int64) (n int, err Error)\n从 off 开始读取数据到 b 中\n读文件的示例代码:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { userFile := \u0026#34;asatxie.txt\u0026#34; fl, err := os.Open(userFile) if err != nil { fmt.Println(userFile, err) return } defer fl.Close() buf := make([]byte, 1024) for { n, _ := fl.Read(buf) if 0 == n { break } os.Stdout.Write(buf[:n]) } } 删除文件 Go 语言里面删除文件和删除文件夹是同一个函数\nfunc Remove(name string) Error\n调用该函数就可以删除文件名为 name 的文件\n","permalink":"https://liiqii.github.io/posts/tech/go/go_file/","summary":"概要 UNIX 的一个基础设计就是”万物皆文件”(everything is a file). 我们不必知道一个文件到底映射成什么,操作系统的设备驱动抽象成文件.操作系统为设备提供了文件格式的接口. Go语言中的reader和writer接口也类似.我们只需简单的读写字节,不必知道reader的数据来自哪里,也","title":"Go 文件和目录"},{"content":"1. 正则表达式语法 正则表达式是一种用于匹配和操作文本的强大工具，它使用特殊的字符和语法来定义模式。在 Golang 的 regexp 包中，使用的正则表达式语法是基于标准的 POSIX 正则表达式语法的一个子集。\n以下是一些常用的正则表达式元字符：\n. ：匹配任意单个字符，除了换行符。 * ：匹配前面的元素零次或多次。 + ：匹配前面的元素一次或多次。 ? ：匹配前面的元素零次或一次。 ^ ：匹配字符串的开头。 $ ：匹配字符串的结尾。 [] ：字符类，匹配方括号中的任意字符。 [^] ：否定字符类，匹配除方括号中字符以外的任意字符。 | ：逻辑或，匹配两个模式之一。 () ：捕获组，用于分组和提取匹配的子字符串。 示例代码：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;Hello, World!\u0026#34; re := regexp.MustCompile(`H.llo`) fmt.Println(re.MatchString(str)) // true } 在上面的示例中，我们创建了一个正则表达式对象 re，它使用了.元字符来匹配 H 后面的任意字符，然后是 llo。我们使用 MatchString 方法来检查字符串 str 是否匹配该正则表达式，它将返回 true。\n2. 创建正则表达式对象 在 Golang 中，要使用正则表达式进行匹配，首先需要创建一个正则表达式对象。可以使用 regexp.Compile 函数或正则表达式字面量来创建对象。\n示例代码：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;Hello, World!\u0026#34; re := regexp.MustCompile(`[aeiou]`) fmt.Println(re.MatchString(str)) // true } 当我们运行上述代码时，它将打印出 true，因为正则表达式 [aeiou] 匹配字符串中的任何一个元音字母。\n在上面的示例中，我们使用 regexp.MustCompile 函数创建了一个正则表达式对象 re，该函数接受一个字符串参数，表示正则表达式的模式。这个函数会编译正则表达式并返回一个可用于匹配的正则表达式对象。\n另外，你还可以使用正则表达式字面量来创建正则表达式对象，如下所示：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;Hello, World!\u0026#34; re := `[aeiou]` match, _ := regexp.MatchString(re, str) fmt.Println(match) // true } 在这个示例中，我们直接将正则表达式模式作为字符串赋值给变量 re，然后使用 regexp.MatchString 函数检查字符串 str 是否与正则表达式匹配。这个函数返回一个布尔值表示匹配结果。\n无论是使用 regexp.MustCompile 函数还是正则表达式字面量，都会创建一个正则表达式对象，该对象可以在后续的匹配操作中使用。\n3. 字符串匹配 使用 Golang 的 regexp 包，你可以对字符串进行正则表达式匹配操作。下面是一些常用的方法：\nMatchString(pattern, s string) bool：检查字符串 s 是否与正则表达式模式 pattern 匹配，返回一个布尔值表示匹配结果。 Match(pattern string, b []byte) (matched bool, err error)：检查字节切片 b 是否与正则表达式模式 pattern 匹配，返回一个布尔值表示匹配结果。 示例代码：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;Hello, World!\u0026#34; re := regexp.MustCompile(`^Hello`) fmt.Println(re.MatchString(str)) // true } 在上面的示例中，我们使用 MatchString 方法检查字符串 str 是否以 Hello 开头。由于 str 的开头确实是 Hello，所以匹配结果为 true。\n另外，你也可以使用 Match 方法来检查字节切片是否与正则表达式匹配。例如：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := []byte(\u0026#34;Hello, World!\u0026#34;) re := regexp.MustCompile(`^Hello`) matched, _ := re.Match(str) fmt.Println(matched) // true } 在这个示例中，我们将字符串 str 转换为字节切片，并使用 Match 方法来检查它是否以 Hello 开头。同样，由于匹配成功，所以输出为 true。\n通过使用这些方法，你可以轻松地检查字符串是否符合特定的正则表达式模式。\n4. 字符串替换 在 Golang 的 regexp 包中，你可以使用正则表达式来进行字符串替换操作。以下是常用的方法：\nReplaceAllString(src, repl, pattern string) string：将字符串 src 中所有匹配正则表达式模式 pattern 的部分替换为 repl，并返回替换后的新字符串。 ReplaceAllStringFunc(src string, repl func(string) string, pattern string) string：根据匹配的正则表达式模式 pattern，使用 repl 函数对字符串 src 进行替换，并返回替换后的新字符串。repl 函数接收匹配的字符串作为参数，并返回替换后的字符串。 示例代码：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;Hello, Golang!\u0026#34; re := regexp.MustCompile(`Golang`) newStr := re.ReplaceAllString(str, \u0026#34;World\u0026#34;) fmt.Println(newStr) // Hello, World! } 在上面的示例中，我们使用 ReplaceAllString 方法将字符串 str 中的 Golang 替换为 World。替换后的新字符串存储在变量 newStr 中，并打印输出结果为 Hello, World!。\n如果你想根据匹配的字符串来动态替换内容，可以使用 ReplaceAllStringFunc 方法。例如：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; \u0026#34;strings\u0026#34; ) func main() { str := \u0026#34;Hello, Golang!\u0026#34; re := regexp.MustCompile(`\\w+`) newStr := re.ReplaceAllStringFunc(str, strings.ToUpper) fmt.Println(newStr) // HELLO, GOLANG! } 在这个示例中，我们使用 ReplaceAllStringFunc 方法将字符串 str 中的每个单词转换为大写。我们提供了 strings.ToUpper 函数作为替换函数，该函数将匹配的字符串转换为大写形式。结果输出为 HELLO, GOLANG!。\n通过这些方法，你可以对字符串进行灵活的替换操作，根据正则表达式模式来实现各种替换需求。\n5. 捕获组 在正则表达式中，捕获组是用括号括起来的子表达式，它们允许你在匹配中提取特定的子字符串。Golang 的 regexp 包提供了多个方法来处理捕获组。\nFindStringSubmatch(s string) []string：返回一个字符串切片，其中包含与正则表达式模式匹配的子字符串及其对应的捕获组。 FindAllStringSubmatch(s string, n int) string：返回一个字符串切片的切片，其中包含与正则表达式模式匹配的所有子字符串及其对应的捕获组。可指定 n 来限制匹配的数量。 示例代码：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;John Doe, jane@example.com\u0026#34; re := regexp.MustCompile(`(\\w+)\\s(\\w+),\\s(\\w+@\\w+.\\w+)`) match := re.FindStringSubmatch(str) fmt.Println(match) // [John Doe, John Doe, jane@example.com] fmt.Println(\u0026#34;Name:\u0026#34;, match[1], match[2]) // Name: John Doe fmt.Println(\u0026#34;Email:\u0026#34;, match[3]) // Email: jane@example.com } 在上面的示例中，我们使用正则表达式 (\\w+)\\s(\\w+),\\s(\\w+@\\w+.\\w+) 匹配形如 \u0026ldquo;John Doe, jane@example.com\u0026rdquo; 的字符串。该正则表达式包含了三个捕获组，分别用于提取名字、姓氏和电子邮件地址。我们使用 FindStringSubmatch 方法来获取匹配的结果，并通过索引访问捕获组中的子字符串。\n当我们打印 match 时，可以看到它是一个字符串切片，其中第一个元素是整个匹配的字符串，后续元素是捕获组中的子字符串。\n7. 标志（Flags） Golang 的 regexp 包还提供了一些标志（flags）选项，用于修改正则表达式的行为。这些标志可以通过在正则表达式模式中添加标志参数来设置。\n以下是一些常用的标志：\ni：忽略大小写，使匹配对大小写不敏感。 m：多行模式，允许 ^ 和 $ 匹配文本的每一行的开头和结尾。 s：单行模式，使点号 . 可以匹配换行符。 U：非贪婪模式，使匹配尽可能少地进行。 示例代码：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;Hello\\nworld\u0026#34; re := regexp.MustCompile((?m)^(\\w+)) matches := re.FindAllStringSubmatch(str, -1) for _, match := range matches { fmt.Println(\u0026#34;Matched:\u0026#34;, match[0]) fmt.Println(\u0026#34;Capture Group 1:\u0026#34;, match[1]) } } 在上面的示例中，我们使用正则表达式 (?m)^(\\w+) 匹配多行字符串中的每一行的第一个单词。标志 (?m) 启用多行模式，^ 匹配每行的开头，(\\w+) 是一个捕获组，用于匹配一个或多个字母数字字符。我们使用 FindAllStringSubmatch 方法来获取所有匹配的结果，并迭代输出每个匹配的字符串和捕获组。\n当我们运行该代码时，输出将是：\nMatched: Hello Capture Group 1: Hello Matched: world Capture Group 1: world 通过设置适当的标志，你可以调整正则表达式的行为，以满足特定的匹配需求。\n8. 常见正则表达式技巧 当使用正则表达式时，有一些常见的技巧可以帮助你更有效地处理模式匹配。以下是一些常见的正则表达式技巧。\n8.1 使用限定符 限定符用于指定匹配元素的数量。以下是一些常见的限定符：\n*：匹配前一个元素零次或多次。 +：匹配前一个元素一次或多次。 ?：匹配前一个元素零次或一次。 {n}：匹配前一个元素恰好 n 次。 {n,}：匹配前一个元素至少 n 次。 {n,m}：匹配前一个元素至少 n 次，但不超过 m 次。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;aaaabbbbcccc\u0026#34; re := regexp.MustCompile(`a{2,}b{2,}c{2,}`) match := re.MatchString(str) fmt.Println(match) // true } 在上面的示例中，我们使用正则表达式 a{2,}b{2,}c{2,} 匹配连续出现两次或更多次的字母 \u0026ldquo;a\u0026rdquo;、\u0026ldquo;b\u0026rdquo; 和 \u0026ldquo;c\u0026rdquo;。通过使用限定符，我们可以定义所需的匹配次数。\n8.2 使用字符类 字符类用于匹配一组特定的字符。以下是一些常见的字符类：\n[abc]：匹配字符 \u0026ldquo;a\u0026rdquo;、\u0026ldquo;b\u0026rdquo; 或 \u0026ldquo;c\u0026rdquo;。 [0-9]：匹配任意一个数字。 [^0-9]：匹配除数字以外的任意字符。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;a1b2c3\u0026#34; re := regexp.MustCompile(`[0-9]`) matches := re.FindAllString(str, -1) fmt.Println(matches) // [1 2 3] } 在上面的示例中，我们使用正则表达式 [0-9] 匹配字符串中的数字字符。通过使用字符类，我们可以定义需要匹配的字符范围。\n8.3 使用元字符 元字符具有特殊的含义。以下是一些常见的元字符：\n.：匹配除换行符以外的任意字符。 \\w：匹配字母、数字或下划线字符。 \\d：匹配数字字符。 \\s：匹配空白字符。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;Hello, World!\u0026#34; re := regexp.MustCompile(`\\w+`) matches := re.FindAllString(str, -1) fmt.Println(matches) // [Hello World] } 8.4 使用捕获组 捕获组允许你提取匹配的子字符串。通过使用括号将子表达式括起来，你可以将其作为捕获组。以下是一个示例：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;Hello, Golang!\u0026#34; re := regexp.MustCompile(`(\\w+), (\\w+)!`) matches := re.FindStringSubmatch(str) fmt.Println(matches[0]) // Hello, Golang! fmt.Println(matches[1]) // Hello fmt.Println(matches[2]) // Golang } 在上面的示例中，我们使用正则表达式 (\\w+), (\\w+)! 匹配以逗号分隔的两个单词，并将它们作为捕获组。通过使用 FindStringSubmatch 方法，我们可以提取整个匹配的子字符串以及每个捕获组的内容。\n8.5 使用反向引用 反向引用允许你在正则表达式中引用先前匹配的捕获组。通过使用 \\n，其中 n 是捕获组的索引，你可以引用先前的捕获组。以下是一个示例：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;hello hello\u0026#34; re := regexp.MustCompile(`(\\w+) \\1`) match := re.MatchString(str) fmt.Println(match) // true } 在上面的示例中，我们使用正则表达式 (\\w+) \\1 匹配重复的单词。\\1 表示引用第一个捕获组的内容。通过使用反向引用，我们可以匹配重复出现的模式。\n8.6 使用锚点 锚点用于指定匹配发生的位置。以下是一些常见的锚点：\n^：匹配字符串的开头。 $：匹配字符串的结尾。 \\b：匹配单词的边界。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;Hello, Golang!\u0026#34; re := regexp.MustCompile(`^Hello`) match := re.MatchString(str) fmt.Println(match) // true re = regexp.MustCompile(`Golang!$`) match = re.MatchString(str) fmt.Println(match) // true re = regexp.MustCompile(`\\bGolang\\b`) match = re.MatchString(str) fmt.Println(match) // true } 在上面的示例中，我们使用不同的锚点来匹配字符串的开头、结尾和单词边界。通过使用锚点，我们可以限定匹配发生的位置。\n8.7 使用修饰符 修饰符是用于修改正则表达式的行为的特殊标记。它们可以影响匹配的方式和规则。以下是一些常见的修饰符。\n8.7.1 i 修饰符（不区分大小写） 使用 i 修饰符可以使匹配过程对大小写不敏感。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;Hello, World!\u0026#34; re := regexp.MustCompile(`hello`) match := re.MatchString(str) fmt.Println(match) // false re = regexp.MustCompile(`(?i)hello`) match = re.MatchString(str) fmt.Println(match) // true } 在上面的示例中，正则表达式 (?i)hello 使用了 i 修饰符，使匹配过程不区分大小写。\n8.7.2 m 修饰符（多行模式） 使用 m 修饰符可以使 ^ 和 $ 锚点匹配每一行的开头和结尾，而不仅仅是整个字符串的开头和结尾。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := `Line 1 Line 2 Line 3` re := regexp.MustCompile(`^Line \\d+$`) match := re.MatchString(str) fmt.Println(match) // false re = regexp.MustCompile(`(?m)^Line \\d+$`) match = re.MatchString(str) fmt.Println(match) // true } 在上面的示例中，正则表达式 (?m)^Line \\d+使用了m修饰符，使和使用了 m 修饰符，使 ^ 和使用了m修饰符，使和 锚点匹配每一行的开头和结尾。\n8.7.3 s 修饰符（单行模式） 使用 s 修饰符可以使 . 元字符匹配包括换行符在内的任意字符。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;Hello\\nWorld!\u0026#34; re := regexp.MustCompile(`Hello.World!`) match := re.MatchString(str) fmt.Println(match) // false re = regexp.MustCompile(`(?s)Hello.World!`) match = re.MatchString(str) fmt.Println(match) // true } 在上面的示例中，正则表达式 (?s)Hello.World! 使用了 s 修饰符，使 . 元字符可以匹配包括换行符在内的任意字符。\n修饰符可以在正则表达式中使用括号和 ? 符号的形式，如 (?i)、(?m) 和 (?s)。它们可以单独使用，也可以组合使用，以适应特定的匹配需求。\n8.7.4 x 修饰符（忽略空白字符） 使用 x 修饰符可以在正则表达式中忽略空白字符，包括空格、制表符和换行符。这样可以使正则表达式更易读和维护。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;Hello World!\u0026#34; re := regexp.MustCompile(`Hello World!`) match := re.MatchString(str) fmt.Println(match) // false re = regexp.MustCompile(`(?x)Hello World!`) match = re.MatchString(str) fmt.Println(match) // true } 在上面的示例中，正则表达式 (?x)Hello World! 使用了 x 修饰符，忽略了正则表达式中的空白字符。这样可以使正则表达式更易读，减少了空格的影响。\n8.7.5 U 修饰符（非贪婪模式） 使用 U 修饰符可以将匹配模式设置为非贪婪模式，即尽可能少地匹配字符。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { str := \u0026#34;Hello World!\u0026#34; re := regexp.MustCompile(`H.*o`) match := re.FindString(str) fmt.Println(match) // Hello World! re = regexp.MustCompile(`H.*?o`) match = re.FindString(str) fmt.Println(match) // Hello } 在上面的示例中，正则表达式 H.o 使用了贪婪模式，匹配了从 \u0026ldquo;H\u0026rdquo; 到最后一个 \u0026ldquo;o\u0026rdquo; 的最长字符串。而正则表达式 H. ?o 使用了 U 修饰符，将匹配模式设置为非贪婪模式，只匹配了从 \u0026ldquo;H\u0026rdquo; 到第一个 \u0026ldquo;o\u0026rdquo; 的最短字符串。\n","permalink":"https://liiqii.github.io/posts/tech/go/go_regexp/","summary":"1. 正则表达式语法 正则表达式是一种用于匹配和操作文本的强大工具，它使用特殊的字符和语法来定义模式。在 Golang 的 regexp 包中，使用的正则表达式语法是基于标准的 POSIX 正则表达式语法的一个子集。 以下是一些常用的正则表达式元字符： . ：匹配任意单个字符，除了换行符。 * ：匹配前面的元素零次或多次。 + ：匹配前面","title":"Go 正则表达式"},{"content":"转自：Go常见面试题【由浅入深】2022版\n基础语法 01 = 和 := 的区别？ =是赋值变量，:=是定义变量。\n02 指针的作用 一个指针可以指向任意变量的地址，它所指向的地址在32位或64位机器上分别固定占4或8个字节。指针的作用有：\n获取变量的值 import fmt ​ func main(){ a := 1 p := \u0026amp;a//取址\u0026amp; fmt.Printf(\u0026#34;%d\\n\u0026#34;, *p);//取值* } 改变变量的值 // 交换函数 func swap(a, b *int) { *a, *b = *b, *a } 用指针替代值传入函数，比如类的接收器就是这样的。 type A struct{} ​ func (a *A) fun(){} 03 Go 允许多个返回值吗？ 可以。通常函数除了一般返回值还会返回一个error。\n04 Go 有异常类型吗？ 有。Go用error类型代替try\u0026hellip;catch语句，这样可以节省资源。同时增加代码可读性：\n_, err := funcDemo() if err != nil { fmt.Println(err) return } 也可以用errors.New()来定义自己的异常。errors.Error()会返回异常的字符串表示。只要实现error接口就可以定义自己的异常，\ntype errorString struct { s string } ​ func (e *errorString) Error() string { return e.s } ​ // 多一个函数当作构造函数 func New(text string) error { return \u0026amp;errorString{text} } 05 什么是协程（Goroutine） 协程是用户态轻量级线程，它是线程调度的基本单位。通常在函数前加上go关键字就能实现并发。一个Goroutine会以一个很小的栈启动2KB或4KB，当遇到栈空间不足时，栈会自动伸缩， 因此可以轻易实现成千上万个goroutine同时启动。\n06 ❤ 如何高效地拼接字符串 拼接字符串的方式有：+ , fmt.Sprintf , strings.Builder, bytes.Buffer, strings.Join\n1 \u0026ldquo;+\u0026rdquo;\n使用+操作符进行拼接时，会对字符串进行遍历，计算并开辟一个新的空间来存储原来的两个字符串。\n2 fmt.Sprintf\n由于采用了接口参数，必须要用反射获取值，因此有性能损耗。\n3 strings.Builder：\n用WriteString()进行拼接，内部实现是指针+切片，同时String()返回拼接后的字符串，它是直接把[]byte转换为string，从而避免变量拷贝。\n4 bytes.Buffer\nbytes.Buffer是一个一个缓冲byte类型的缓冲器，这个缓冲器里存放着都是byte，\nbytes.buffer底层也是一个[]byte切片。\n5 strings.join\nstrings.join也是基于strings.builder来实现的,并且可以自定义分隔符，在join方法内调用了b.Grow(n)方法，这个是进行初步的容量分配，而前面计算的n的长度就是我们要拼接的slice的长度，因为我们传入切片长度固定，所以提前进行容量分配可以减少内存分配，很高效。\n性能比较：\nstrings.Join ≈ strings.Builder \u0026gt; bytes.Buffer \u0026gt; \u0026ldquo;+\u0026rdquo; \u0026gt; fmt.Sprintf\n5种拼接方法的实例代码\nfunc main(){ a := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;} //方式1：+ ret := a[0] + a[1] + a[2] //方式2：fmt.Sprintf ret := fmt.Sprintf(\u0026#34;%s%s%s\u0026#34;, a[0],a[1],a[2]) //方式3：strings.Builder var sb strings.Builder sb.WriteString(a[0]) sb.WriteString(a[1]) sb.WriteString(a[2]) ret := sb.String() //方式4：bytes.Buffer buf := new(bytes.Buffer) buf.Write(a[0]) buf.Write(a[1]) buf.Write(a[2]) ret := buf.String() //方式5：strings.Join ret := strings.Join(a,\u0026#34;\u0026#34;) } 参考资料：字符串拼接性能及原理 | Go 语言高性能编程 | 极客兔兔\n07 什么是 rune 类型 ASCII 码只需要 7 bit 就可以完整地表示，但只能表示英文字母在内的128个字符，为了表示世界上大部分的文字系统，发明了 Unicode， 它是ASCII的超集，包含世界上书写系统中存在的所有字符，并为每个代码分配一个标准编号（称为Unicode CodePoint），在 Go 语言中称之为 rune，是 int32 类型的别名。\nGo 语言中，字符串的底层表示是 byte (8 bit) 序列，而非 rune (32 bit) 序列。\nsample := \u0026#34;我爱GO\u0026#34; runeSamp := []rune(sample) runeSamp[0] = \u0026#39;你\u0026#39; fmt.Println(string(runeSamp)) // \u0026#34;你爱GO\u0026#34; fmt.Println(len(runeSamp)) // 4 08 如何判断 map 中是否包含某个 key ？ var sample map[int]int if _, ok := sample[10]; ok { } else { } 09 Go 支持默认参数或可选参数吗？ 不支持。但是可以利用结构体参数，或者\u0026hellip;传入参数切片数组。\n// 这个函数可以传入任意数量的整型参数 func sum(nums ...int) { total := 0 for _, num := range nums { total += num } fmt.Println(total) } 10 defer 的执行顺序 defer执行顺序和调用顺序相反，类似于栈后进先出(LIFO)。\ndefer在return之后执行，但在函数退出之前，defer可以修改返回值。下面是一个例子：\nfunc test() int { i := 0 defer func() { fmt.Println(\u0026#34;defer1\u0026#34;) }() defer func() { i += 1 fmt.Println(\u0026#34;defer2\u0026#34;) }() return i } func main() { fmt.Println(\u0026#34;return\u0026#34;, test()) } // defer2 // defer1 // return 0 上面这个例子中，test返回值并没有修改，这是由于Go的返回机制决定的，执行Return语句后，Go会创建一个临时变量保存返回值。如果是有名返回（也就是指明返回值func test() (i int)）\nfunc test() (i int) { i = 0 defer func() { i += 1 fmt.Println(\u0026#34;defer2\u0026#34;) }() return i } func main() { fmt.Println(\u0026#34;return\u0026#34;, test()) } // defer2 // return 1 这个例子中，返回值被修改了。对于有名返回值的函数，执行 return 语句时，并不会再创建临时变量保存，因此，defer 语句修改了 i，即对返回值产生了影响。\n11 如何交换 2 个变量的值？ 对于变量而言a,b = b,a； 对于指针而言*a,*b = *b, *a\n12 Go 语言 tag 的用处？ tag可以为结构体成员提供属性。常见的：\njson序列化或反序列化时字段的名称 db: sqlx模块中对应的数据库字段名 form: gin框架中对应的前端的数据字段名 binding: 搭配 form 使用, 默认如果没查找到结构体中的某个字段则不报错值为空, binding为 required 代表没找到返回错误给前端 13 如何获取一个结构体的所有tag？ 利用反射：\nimport reflect type Author struct { Name int `json:Name` Publications []string `json:Publication,omitempty` } func main() { t := reflect.TypeOf(Author{}) for i := 0; i \u0026lt; t.NumField(); i++ { name := t.Field(i).Name s, _ := t.FieldByName(name) fmt.Println(name, s.Tag) } } 上述例子中，reflect.TypeOf方法获取对象的类型，之后NumField()获取结构体成员的数量。 通过Field(i)获取第i个成员的名字。 再通过其Tag 方法获得标签。\n14 如何判断 2 个字符串切片（slice) 是相等的？ reflect.DeepEqual() ， 但反射非常影响性能。\n15 结构体打印时，%v 和 %+v 的区别 %v输出结构体各成员的值；\n%+v输出结构体各成员的名称和值；\n%#v输出结构体名称和结构体各成员的名称和值\n16 Go 语言中如何表示枚举值(enums)？ 在常量中用iota可以表示枚举。iota从0开始。\nconst ( B = 1 \u0026lt;\u0026lt; (10 * iota) KiB MiB GiB TiB PiB EiB ) 17 空 struct{} 的用途 用map模拟一个set，那么就要把值置为struct{}，struct{}本身不占任何空间，可以避免任何多余的内存分配。 type Set map[string]struct{} func main() { set := make(Set) for _, item := range []string{\u0026#34;A\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;} { set[item] = struct{}{} } fmt.Println(len(set)) // 3 if _, ok := set[\u0026#34;A\u0026#34;]; ok { fmt.Println(\u0026#34;A exists\u0026#34;) // A exists } } 有时候给通道发送一个空结构体,channel\u0026lt;-struct{}{}，也是节省了空间。 func main() { ch := make(chan struct{}, 1) go func() { \u0026lt;-ch // do something }() ch \u0026lt;- struct{}{} // ... } 仅有方法的结构体 type Lamp struct{} 18 go里面的int和int32是同一个概念吗？ 不是一个概念！千万不能混淆。go语言中的int的大小是和操作系统位数相关的，如果是32位操作系统，int类型的大小就是4字节。如果是64位操作系统，int类型的大小就是8个字节。除此之外uint也与操作系统有关。\nint8占1个字节，int16占2个字节，int32占4个字节，int64占8个字节。\n实现原理 01 init() 函数是什么时候执行的？ 简答： 在main函数之前执行。\n详细：init()函数是go初始化的一部分，由runtime初始化每个导入的包，初始化不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化。\n每个包首先初始化包作用域的常量和变量（常量优先于变量），然后执行包的init()函数。同一个包，甚至是同一个源文件可以有多个init()函数。init()函数没有入参和返回值，不能被其他函数调用，同一个包内多个init()函数的执行顺序不作保证。\n执行顺序：import –\u0026gt; const –\u0026gt; var –\u0026gt;init()–\u0026gt;main()\n一个文件可以有多个init()函数！\n02 ❤如何知道一个对象是分配在栈上还是堆上？ Go和C++不同，Go局部变量会进行逃逸分析。如果变量离开作用域后没有被引用，则优先分配到栈上，否则分配到堆上。那么如何判断是否发生了逃逸呢？\ngo build -gcflags '-m -m -l' xxx.go.\n关于逃逸的可能情况：变量大小不确定，变量类型不确定，变量分配的内存超过用户栈最大值，暴露给了外部指针。\n03 2 个 interface 可以比较吗 ？ Go 语言中，interface 的内部实现包含了 2 个字段，类型 T 和 值 V，interface 可以使用 == 或 != 比较。2 个 interface 相等有以下 2 种情况\n两个 interface 均等于 nil（此时 V 和 T 都处于 unset 状态） 类型 T 相同，且对应的值 V 相等。 看下面的例子：\ntype Stu struct { Name string } type StuInt interface{} func main() { var stu1, stu2 StuInt = \u0026amp;Stu{\u0026#34;Tom\u0026#34;}, \u0026amp;Stu{\u0026#34;Tom\u0026#34;} var stu3, stu4 StuInt = Stu{\u0026#34;Tom\u0026#34;}, Stu{\u0026#34;Tom\u0026#34;} fmt.Println(stu1 == stu2) // false fmt.Println(stu3 == stu4) // true } stu1 和 stu2 对应的类型是 *Stu，值是 Stu 结构体的地址，两个地址不同，因此结果为 false。\nstu3 和 stu4 对应的类型是 Stu，值是 Stu 结构体，且各字段相等，因此结果为 true。\n04 2 个 nil 可能不相等吗？ 可能不等。interface在运行时绑定值，只有值为nil接口值才为nil，但是与指针的nil不相等。举个例子：\nvar p *int = nil var i interface{} = nil if(p == i){ fmt.Println(\u0026#34;Equal\u0026#34;) } 两者并不相同。总结：两个nil只有在类型相同时才相等。\n05 ❤简述 Go 语言GC(垃圾回收)的工作原理 垃圾回收机制是Go一大特(nan)色(dian)。Go1.3采用标记清除法， Go1.5采用三色标记法，Go1.8采用三色标记法+混合写屏障。\n标记清除法\n分为两个阶段：标记和清除\n标记阶段：从根对象出发寻找并标记所有存活的对象。\n清除阶段：遍历堆中的对象，回收未标记的对象，并加入空闲链表。\n缺点是需要暂停程序STW。\n三色标记法：\n将对象标记为白色，灰色或黑色。\n白色：不确定对象（默认色）；黑色：存活对象。灰色：存活对象，子对象待处理。\n标记开始时，先将所有对象加入白色集合（需要STW）。首先将根对象标记为灰色，然后将一个对象从灰色集合取出，遍历其子对象，放入灰色集合。同时将取出的对象放入黑色集合，直到灰色集合为空。最后的白色集合对象就是需要清理的对象。\n这种方法有一个缺陷，如果对象的引用被用户修改了，那么之前的标记就无效了。因此Go采用了写屏障技术，当对象新增或者更新会将其着色为灰色。\n一次完整的GC分为四个阶段：\n准备标记（需要STW），开启写屏障。 开始标记 标记结束（STW），关闭写屏障 清理（并发） 基于插入写屏障和删除写屏障在结束时需要STW来重新扫描栈，带来性能瓶颈。混合写屏障分为以下四步：\nGC开始时，将栈上的全部对象标记为黑色（不需要二次扫描，无需STW）； GC期间，任何栈上创建的新对象均为黑色 被删除引用的对象标记为灰色 被添加引用的对象标记为灰色 总而言之就是确保黑色对象不能引用白色对象，这个改进直接使得GC时间从 2s降低到2us。\n06 函数返回局部变量的指针是否安全？ 这一点和C++不同，在Go里面返回局部变量的指针是安全的。因为Go会进行逃逸分析，如果发现局部变量的作用域超过该函数则会把指针分配到堆区，避免内存泄漏。\n07 非接口的任意类型 T() 都能够调用 *T 的方法吗？反过来呢？ 一个T类型的值可以调用*T类型声明的方法，当且仅当T是可寻址的。\n反之：*T 可以调用T()的方法，因为指针可以解引用。\n08 go slice是怎么扩容的？ Go \u0026lt;= 1.17\n如果当前容量小于1024，则判断所需容量是否大于原来容量2倍，如果大于，当前容量加上所需容量；否则当前容量乘2。\n如果当前容量大于1024，则每次按照1.25倍速度递增容量，也就是每次加上cap/4。\nGo1.18之后，引入了新的扩容规则：浅谈 Go 1.18.1的切片扩容机制\n并发编程 01 ❤无缓冲的 channel 和有缓冲的 channel 的区别？ （这个问题笔者也纠结了很久，直到看到一篇文章，阻塞与否是分别针对发送接收方而言的，才茅塞顿开）\n对于无缓冲区channel：\n发送的数据如果没有被接收方接收，那么**发送方阻塞；**如果一直接收不到发送方的数据，接收方阻塞；\n有缓冲的channel：\n发送方在缓冲区满的时候阻塞，接收方不阻塞；接收方在缓冲区为空的时候阻塞，发送方不阻塞。\n可以类比生产者与消费者问题。\n![](data:image/svg+xml;utf8,)\n02 为什么有协程泄露(Goroutine Leak)？ 协程泄漏是指协程创建之后没有得到释放。主要原因有：\n缺少接收器，导致发送阻塞 缺少发送器，导致接收阻塞 死锁。多个协程由于竞争资源导致死锁。 创建协程的没有回收。 03 Go 可以限制运行时操作系统线程的数量吗？ 常见的goroutine操作函数有哪些？ 可以，使用runtime.GOMAXPROCS(num int)可以设置线程数目。该值默认为CPU逻辑核数，如果设的太大，会引起频繁的线程切换，降低性能。\nruntime.Gosched()，用于让出CPU时间片，让出当前goroutine的执行权限，调度器安排其它等待的任务运行，并在下次某个时候从该位置恢复执行。\nruntime.Goexit()，调用此函数会立即使当前的goroutine的运行终止（终止协程），而其它的goroutine并不会受此影响。runtime.Goexit在终止当前goroutine前会先执行此goroutine的还未执行的defer语句。请注意千万别在主函数调用runtime.Goexit，因为会引发panic。\n04 如何控制协程数目。 The GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. There is no limit to the number of threads that can be blocked in system calls on behalf of Go code; those do not count against the GOMAXPROCS limit.\n从官方文档的解释可以看到，GOMAXPROCS 限制的是同时执行用户态 Go 代码的操作系统线程的数量，但是对于被系统调用阻塞的线程数量是没有限制的。GOMAXPROCS 的默认值等于 CPU 的逻辑核数，同一时间，一个核只能绑定一个线程，然后运行被调度的协程。因此对于 CPU 密集型的任务，若该值过大，例如设置为 CPU 逻辑核数的 2 倍，会增加线程切换的开销，降低性能。对于 I/O 密集型应用，适当地调大该值，可以提高 I/O 吞吐率。\n另外对于协程，可以用带缓冲区的channel来控制，下面的例子是协程数为1024的例子\nvar wg sync.WaitGroup ch := make(chan struct{}, 1024) for i:=0; i\u0026lt;20000; i++{ wg.Add(1) ch\u0026lt;-struct{}{} go func(){ defer wg.Done() \u0026lt;-ch } } wg.Wait() 此外还可以用协程池：其原理无外乎是将上述代码中通道和协程函数解耦，并封装成单独的结构体。常见第三方协程池库，比如tunny等。\n面试题评价：★★★☆☆。偏容易和基础。分为基础语法、实现原理、并发编程三个大部分，需要读者有扎实的基础。\n-\n面试题2 来源：Durant Thorvalds\n❤new和make的区别？ new只用于分配内存，返回一个指向地址的指针。它为每个新类型分配一片内存，初始化为0且返回类型*T的内存地址，它相当于\u0026amp;T{} make只可用于slice,map,channel的初始化,返回的是引用。 请你讲一下Go面向对象是如何实现的？ Go实现面向对象的两个关键是struct和interface。\n封装：对于同一个包，对象对包内的文件可见；对不同的包，需要将对象以大写开头才是可见的。\n继承：继承是编译时特征，在struct内加入所需要继承的类即可：\ntype A struct{} type B struct{ A } 多态：多态是运行时特征，Go多态通过interface来实现。类型和接口是松耦合的，某个类型的实例可以赋给它所实现的任意接口类型的变量。\nGo支持多重继承，就是在类型中嵌入所有必要的父类型。\nuint型变量值分别为 1，2，它们相减的结果是多少？ var a uint = 1 var b uint = 2 fmt.Println(a - b) 答案，结果会溢出，如果是32位系统，结果是2^32-1，如果是64位系统，结果2^64-1.\n讲一下go有没有函数在main之前执行？怎么用？ go的init函数在main函数之前执行，它有如下特点：\nfunc init() { ... } init函数非常特殊：\n初始化不能采用初始化表达式初始化的变量； 程序运行前执行注册 实现sync.Once功能 不能被其它函数调用 init函数没有入口参数和返回值： 每个包可以有多个init函数，每个源文件也可以有多个init函数。 同一个包的init执行顺序，golang没有明确定义，编程时要注意程序不要依赖这个执行顺序。 不同包的init函数按照包导入的依赖关系决定执行顺序。 下面这句代码是什么作用，为什么要定义一个空值？ type GobCodec struct{ conn io.ReadWriteCloser buf *bufio.Writer dec *gob.Decoder enc *gob.Encoder } type Codec interface { io.Closer ReadHeader(*Header) error ReadBody(interface{}) error Write(*Header, interface{}) error } var _ Codec = (*GobCodec)(nil) 答：将nil转换为*GobCodec类型，然后再转换为Codec接口，如果转换失败，说明*GobCodec没有实现Codec接口的所有方法。\n❤golang的内存管理的原理清楚吗？简述go内存管理机制。 golang内存管理基本是参考tcmalloc来进行的。go内存管理本质上是一个内存池，只不过内部做了很多优化：自动伸缩内存池大小，合理的切割内存块。\n一些基本概念：\n页Page：一块8K大小的内存空间。Go向操作系统申请和释放内存都是以页为单位的。\nspan : 内存块，一个或多个连续的 page 组成一个 span 。如果把 page 比喻成工人， span 可看成是小队，工人被分成若干个队伍，不同的队伍干不同的活。\nsizeclass : 空间规格，每个 span 都带有一个 sizeclass ，标记着该 span 中的 page 应该如何使用。使用上面的比喻，就是 sizeclass 标志着 span 是一个什么样的队伍。\nobject : 对象，用来存储一个变量数据内存空间，一个 span 在初始化时，会被切割成一堆等大的 object 。假设 object 的大小是 16B ， span 大小是 8K ，那么就会把 span 中的 page 就会被初始化 8K / 16B = 512 个 object 。所谓内存分配，就是分配一个 object 出去。\nmheap 一开始go从操作系统索取一大块内存作为内存池，并放在一个叫mheap的内存池进行管理，mheap将一整块内存切割为不同的区域，并将一部分内存切割为合适的大小。\n![](data:image/svg+xml;utf8,)\nmheap.spans ：用来存储 page 和 span 信息，比如一个 span 的起始地址是多少，有几个 page，已使用了多大等等。\nmheap.bitmap 存储着各个 span 中对象的标记信息，比如对象是否可回收等等。\nmheap.arena_start : 将要分配给应用程序使用的空间。\nmcentral 用途相同的span会以链表的形式组织在一起存放在mcentral中。这里用途用sizeclass来表示，就是该span存储哪种大小的对象。\n找到合适的 span 后，会从中取一个 object 返回给上层使用。\nmcache 为了提高内存并发申请效率，加入缓存层mcache。每一个mcache和处理器P对应。Go申请内存首先从P的mcache中分配，如果没有可用的span再从mcentral中获取。\n参考资料：Go 语言内存管理（二）：Go 内存管理\n❤mutex有几种模式？ mutex有两种模式：normal 和 starvation\n正常模式\n所有goroutine按照FIFO的顺序进行锁获取，被唤醒的goroutine和新请求锁的goroutine同时进行锁获取，通常新请求锁的goroutine更容易获取锁(持续占有cpu)，被唤醒的goroutine则不容易获取到锁。公平性：否。\n饥饿模式\n所有尝试获取锁的goroutine进行等待排队，新请求锁的goroutine不会进行锁获取(禁用自旋)，而是加入队列尾部等待获取锁。公平性：是。\n参考链接：Go Mutex 饥饿模式，GO 互斥锁（Mutex）原理\n-\n面试题3 来源**：**如果你是一个Golang面试官，你会问哪些问题？\n❤go如何进行调度的。GMP中状态流转。 Go里面GMP分别代表：G：goroutine，M：线程（真正在CPU上跑的），P：调度器。\n![](data:image/svg+xml;utf8,)\nGMP模型\n调度器是M和G之间桥梁。\ngo进行调度过程：\n某个线程尝试创建一个新的G，那么这个G就会被安排到这个线程的G本地队列LRQ中，如果LRQ满了，就会分配到全局队列GRQ中；\n尝试获取当前线程的M，如果无法获取，就会从空闲的M列表中找一个，如果空闲列表也没有，那么就创建一个M，然后绑定G与P运行。\n进入调度循环：\n找到一个合适的G\n执行G，完成以后退出\nGo什么时候发生阻塞？阻塞时，调度器会怎么做。 用于原子、互斥量或通道操作导致goroutine阻塞，调度器将把当前阻塞的goroutine从本地运行队列LRQ换出，并重新调度其它goroutine； 由于网络请求和IO导致的阻塞，Go提供了网络轮询器（Netpoller）来处理，后台用epoll等技术实现IO多路复用。 其它回答：\nchannel阻塞：当goroutine读写channel发生阻塞时，会调用gopark函数，该G脱离当前的M和P，调度器将新的G放入当前M。 系统调用：当某个G由于系统调用陷入内核态，该P就会脱离当前M，此时P会更新自己的状态为Psyscall，M与G相互绑定，进行系统调用。结束以后，若该P状态还是Psyscall，则直接关联该M和G，否则使用闲置的处理器处理该G。 系统监控：当某个G在P上运行的时间超过10ms时候，或者P处于Psyscall状态过长等情况就会调用retake函数，触发新的调度。 主动让出：由于是协作式调度，该G会主动让出当前的P（通过GoSched），更新状态为Grunnable，该P会调度队列中的G运行。 更多关于netpoller的内容可以参看：https://strikefreedom.top/go-netpoll-io-multiplexing-reactor\n❤Go中GMP有哪些状态？ ![](data:image/svg+xml;utf8,)\nG的状态：\n_Gidle：刚刚被分配并且还没有被初始化，值为0，为创建goroutine后的默认值\n_Grunnable： 没有执行代码，没有栈的所有权，存储在运行队列中，可能在某个P的本地队列或全局队列中(如上图)。\n_Grunning： 正在执行代码的goroutine，拥有栈的所有权(如上图)。\n_Gsyscall：正在执行系统调用，拥有栈的所有权，与P脱离，但是与某个M绑定，会在调用结束后被分配到运行队列(如上图)。\n_Gwaiting：被阻塞的goroutine，阻塞在某个channel的发送或者接收队列(如上图)。\n_Gdead： 当前goroutine未被使用，没有执行代码，可能有分配的栈，分布在空闲列表gFree，可能是一个刚刚初始化的goroutine，也可能是执行了goexit退出的goroutine(如上图)。\n_Gcopystac：栈正在被拷贝，没有执行代码，不在运行队列上，执行权在\n_Gscan ： GC 正在扫描栈空间，没有执行代码，可以与其他状态同时存在。\nP的状态：\n_Pidle ：处理器没有运行用户代码或者调度器，被空闲队列或者改变其状态的结构持有，运行队列为空\n_Prunning ：被线程 M 持有，并且正在执行用户代码或者调度器(如上图)\n_Psyscall：没有执行用户代码，当前线程陷入系统调用(如上图)\n_Pgcstop ：被线程 M 持有，当前处理器由于垃圾回收被停止\n_Pdead ：当前处理器已经不被使用\nM的状态：\n自旋线程：处于运行状态但是没有可执行goroutine的线程，数量最多为GOMAXPROC，若是数量大于GOMAXPROC就会进入休眠。\n非自旋线程：处于运行状态有可执行goroutine的线程。\nGMP能不能去掉P层？会怎么样？ P层的作用\n每个 P 有自己的本地队列，大幅度的减轻了对全局队列的直接依赖，所带来的效果就是锁竞争的减少。而 GM 模型的性能开销大头就是锁竞争。 每个 P 相对的平衡上，在 GMP 模型中也实现了 Work Stealing 算法，如果 P 的本地队列为空，则会从全局队列或其他 P 的本地队列中窃取可运行的 G 来运行，减少空转，提高了资源利用率。 参考资料：https://juejin.cn/post/6968311281220583454\n如果有一个G一直占用资源怎么办？什么是work stealing算法？ 如果有个goroutine一直占用资源，那么GMP模型会从正常模式转变为饥饿模式（类似于mutex），允许其它goroutine使用work stealing抢占（禁用自旋锁）。\nwork stealing算法指，一个线程如果处于空闲状态，则帮其它正在忙的线程分担压力，从全局队列取一个G任务来执行，可以极大提高执行效率。\ngoroutine什么情况会发生内存泄漏？如何避免。 在Go中内存泄露分为暂时性内存泄露和永久性内存泄露。\n暂时性内存泄露\n获取长字符串中的一段导致长字符串未释放 获取长slice中的一段导致长slice未释放 在长slice新建slice导致泄漏 string相比切片少了一个容量的cap字段，可以把string当成一个只读的切片类型。获取长string或者切片中的一段内容，由于新生成的对象和老的string或者切片共用一个内存空间，会导致老的string和切片资源暂时得不到释放，造成短暂的内存泄漏\n永久性内存泄露\ngoroutine永久阻塞而导致泄漏 time.Ticker未关闭导致泄漏 不正确使用Finalizer（Go版本的析构函数）导致泄漏 Go GC有几个阶段 目前的go GC采用三色标记法和混合写屏障技术。\nGo GC有四个阶段:\nSTW，开启混合写屏障，扫描栈对象； 将所有对象加入白色集合，从根对象开始，将其放入灰色集合。每次从灰色集合取出一个对象标记为黑色，然后遍历其子对象，标记为灰色，放入灰色集合； 如此循环直到灰色集合为空。剩余的白色对象就是需要清理的对象。 STW，关闭混合写屏障； 在后台进行GC（并发）。 go竞态条件了解吗？ 所谓竞态竞争，就是当两个或以上的goroutine访问相同资源时候，对资源进行读/写。\n比如var a int = 0，有两个协程分别对a+=1，我们发现最后a不一定为2.这就是竞态竞争。\n通常我们可以用go run -race xx.go来进行检测。\n解决方法是，对临界区资源上锁，或者使用原子操作(atomics)，原子操作的开销小于上锁。\n如果若干个goroutine，有一个panic会怎么做？ 有一个panic，那么剩余goroutine也会退出，程序退出。如果不想程序退出，那么必须通过调用 recover() 方法来捕获 panic 并恢复将要崩掉的程序。\n参考理解：goroutine配上panic会怎样。\ndefer可以捕获goroutine的子goroutine吗？ 不可以。它们处于不同的调度器P中。对于子goroutine，必须通过 recover() 机制来进行恢复，然后结合日志进行打印（或者通过channel传递error），下面是一个例子：\n// 心跳函数 func Ping(ctx context.Context) error { ... code ... go func() { defer func() { if r := recover(); r != nil { log.Errorc(ctx, \u0026#34;ping panic: %v, stack: %v\u0026#34;, r, string(debug.Stack())) } }() ... code ... }() ... code ... return nil } ❤gRPC是什么？ 基于go的远程过程调用。RPC 框架的目标就是让远程服务调用更加简单、透明，RPC 框架负责屏蔽底层的传输方式（TCP 或者 UDP）、序列化方式（XML/Json/ 二进制）和通信细节。服务调用者可以像调用本地接口一样调用远程的服务提供者，而不需要关心底层通信细节和调用过程。\n![](data:image/svg+xml;utf8,)\ngRPC框架图\n面试题4 需要面试者有一定的大型项目经验经验，了解使用微服务，etcd，gin，gorm，gRPC等典型框架等模型或框架。\n微服务了解吗？ 微服务是一种开发软件的架构和组织方法，其中软件由通过明确定义的 API 进行通信的小型独立服务组成。微服务架构使应用程序更易于扩展和更快地开发，从而加速创新并缩短新功能的上市时间。\n![](data:image/svg+xml;utf8,)\n微服务示意图\n微服务有着自主，专用，灵活性等优点。\n参考资料：什么是微服务？| AWS\n服务发现是怎么做的？ 主要有两种服务发现机制：客户端发现和服务端发现。\n客户端发现模式：当我们使用客户端发现的时候，客户端负责决定可用服务实例的网络地址并且在集群中对请求负载均衡, 客户端访问服务登记表，也就是一个可用服务的数据库，然后客户端使用一种负载均衡算法选择一个可用的服务实例然后发起请求。该模式如下图所示：\n![](data:image/svg+xml;utf8,)\n客户端发现模式\n服务端发现模式：客户端通过负载均衡器向某个服务提出请求，负载均衡器查询服务注册表，并将请求转发到可用的服务实例。如同客户端发现，服务实例在服务注册表中注册或注销。\n![](data:image/svg+xml;utf8,)\n服务端发现模式\n参考资料：「Chris Richardson 微服务系列」服务发现的可行方案以及实践案例\nETCD用过吗？ etcd是一个高度一致的分布式键值存储，它提供了一种可靠的方式来存储需要由分布式系统或机器集群访问的数据。它可以优雅地处理网络分区期间的领导者选举，即使在领导者节点中也可以容忍机器故障。\netcd 是用Go语言编写的，它具有出色的跨平台支持，小的二进制文件和强大的社区。etcd机器之间的通信通过Raft共识算法处理。\n关于文档可以参考：v3.5 docs\nGIN怎么做参数校验？ go采用validator作参数校验。\n它具有以下独特功能：\n使用验证tag或自定义validator进行跨字段Field和跨结构体验证。 允许切片、数组和哈希表，多维字段的任何或所有级别进行校验。 能够对哈希表key和value进行验证 通过在验证之前确定它的基础类型来处理类型接口。 别名验证标签，允许将多个验证映射到单个标签，以便更轻松地定义结构体上的验证 gin web 框架的默认验证器； 参考资料：validator package - pkg.go.dev\n中间件用过吗？ Middleware是Web的重要组成部分，中间件（通常）是一小段代码，它们接受一个请求，对其进行处理，每个中间件只处理一件事情，完成后将其传递给另一个中间件或最终处理程序，这样就做到了程序的解耦。\nGo解析Tag是怎么实现的？ Go解析tag采用的是反射。\n具体来说使用reflect.ValueOf方法获取其反射值，然后获取其Type属性，之后再通过Field(i)获取第i+1个field，再.Tag获得Tag。\n反射实现的原理在: `src/reflect/type.go`中\n你项目有优雅的启停吗？ 所谓「优雅」启停就是在启动退出服务时要满足以下几个条件：\n不可以关闭现有连接（进程） 新的进程启动并「接管」旧进程 连接要随时响应用户请求，不可以出现拒绝请求的情况 停止的时候，必须处理完既有连接，并且停止接收新的连接。 为此我们必须引用信号来完成这些目的：\n启动：\n监听SIGHUP（在用户终端连接(正常或非正常)结束时发出）； 收到信号后将服务监听的文件描述符传递给新的子进程，此时新老进程同时接收请求； 退出：\n监听SIGINT和SIGSTP和SIGQUIT等。 父进程停止接收新请求，等待旧请求完成（或超时）； 父进程退出。 实现：go1.8采用Http.Server内置的Shutdown方法支持优雅关机。 然后fvbock/endless可以实现优雅重启。\n参考资料：gin框架实践连载八 | 如何优雅重启和停止 - 掘金，优雅地关闭或重启 go web 项目\n持久化怎么做的？ 所谓持久化就是将要保存的字符串写到硬盘等设备。\n最简单的方式就是采用ioutil的WriteFile()方法将字符串写到磁盘上，这种方法面临格式化方面的问题。 更好的做法是将数据按照固定协议进行组织再进行读写，比如JSON，XML，Gob，csv等。 如果要考虑高并发和高可用，必须把数据放入到数据库中，比如MySQL，PostgreDB，MongoDB等。 参考链接：Golang 持久化\n-\n面试题5 作者：Dylan2333 链接：\n该试题需要面试者有非常丰富的项目阅历和底层原理经验，熟练使用微服务，etcd，gin，gorm，gRPC等典型框架等模型或框架。\nchannel 死锁的场景 当一个channel中没有数据，而直接读取时，会发生死锁： q := make(chan int,2) \u0026lt;-q 解决方案是采用select语句，再default放默认处理方式：\nq := make(chan int,2) select{ case val:=\u0026lt;-q: default: ... } 当channel数据满了，再尝试写数据会造成死锁： q := make(chan int,2) q\u0026lt;-1 q\u0026lt;-2 q\u0026lt;-3 解决方法，采用select\nfunc main() { q := make(chan int, 2) q \u0026lt;- 1 q \u0026lt;- 2 select { case q \u0026lt;- 3: fmt.Println(\u0026#34;ok\u0026#34;) default: fmt.Println(\u0026#34;wrong\u0026#34;) } } 向一个关闭的channel写数据。 注意：一个已经关闭的channel，只能读数据，不能写数据。\n参考资料：Golang关于channel死锁情况的汇总以及解决方案\n对已经关闭的chan进行读写会怎么样？ 读已经关闭的chan能一直读到东西，但是读到的内容根据通道内关闭前是否有元素而不同。\n如果chan关闭前，buffer内有元素还未读,会正确读到chan内的值，且返回的第二个bool值（是否读成功）为true。\n如果chan关闭前，buffer内有元素已经被读完，chan内无值，接下来所有接收的值都会非阻塞直接成功，返回 channel 元素的零值，但是第二个bool值一直为false。\n写已经关闭的chan会panic。\n说说 atomic底层怎么实现的. atomic源码位于`sync\\atomic`。通过阅读源码可知，atomic采用CAS（CompareAndSwap）的方式实现的。所谓CAS就是使用了CPU中的原子性操作。在操作共享变量的时候，CAS不需要对其进行加锁，而是通过类似于乐观锁的方式进行检测，总是假设被操作的值未曾改变（即与旧值相等），并一旦确认这个假设的真实性就立即进行值替换。本质上是不断占用CPU资源来避免加锁的开销。\n参考资料：Go语言的原子操作atomic - 编程猎人\nchannel底层实现？是否线程安全。 channel底层实现在src/runtime/chan.go中\nchannel内部是一个循环链表。内部包含buf, sendx, recvx, lock ,recvq, sendq几个部分；\nbuf是有缓冲的channel所特有的结构，用来存储缓存数据。是个循环链表；\nsendx和recvx用于记录buf这个循环链表中的发送或者接收的index； lock是个互斥锁； recvq和sendq分别是接收(\u0026lt;-channel)或者发送(channel \u0026lt;- xxx)的goroutine抽象出来的结构体(sudog)的队列。是个双向链表。 channel是线程安全的。\n参考资料：Kitou：Golang 深度剖析 \u0026ndash; channel的底层实现\nmap的底层实现。 源码位于src\\runtime\\map.go 中。\ngo的map和C++map不一样，底层实现是哈希表，包括两个部分：hmap和bucket。\n里面最重要的是buckets（桶），buckets是一个指针，最终它指向的是一个结构体：\n// A bucket for a Go map. type bmap struct { tophash [bucketCnt]uint8 } 每个bucket固定包含8个key和value(可以查看源码bucketCnt=8).实现上面是一个固定的大小连续内存块，分成四部分：每个条目的状态，8个key值，8个value值，指向下个bucket的指针。\n创建哈希表使用的是makemap函数.map 的一个关键点在于，哈希函数的选择。在程序启动时，会检测 cpu 是否支持 aes，如果支持，则使用 aes hash，否则使用 memhash。这是在函数 alginit() 中完成，位于路径：src/runtime/alg.go 下。\nmap查找就是将key哈希后得到64位（64位机）用最后B个比特位计算在哪个桶。在 bucket 中，从前往后找到第一个空位。这样，在查找某个 key 时，先找到对应的桶，再去遍历 bucket 中的 key。\n关于map的查找和扩容可以参考map的用法到map底层实现分析。\nselect的实现原理？ select源码位于src\\runtime\\select.go，最重要的scase 数据结构为：\ntype scase struct { c *hchan // chan elem unsafe.Pointer // data element } scase.c为当前case语句所操作的channel指针，这也说明了一个case语句只能操作一个channel。\nscase.elem表示缓冲区地址：\ncaseRecv ： scase.elem表示读出channel的数据存放地址； caseSend ： scase.elem表示将要写入channel的数据存放地址； select的主要实现位于：select.go函数：其主要功能如下：\n1. 锁定scase语句中所有的channel\n2. 按照随机顺序检测scase中的channel是否ready\n2.1 如果case可读，则读取channel中数据，解锁所有的channel，然后返回(case index, true)\n2.2 如果case可写，则将数据写入channel，解锁所有的channel，然后返回(case index, false)\n2.3 所有case都未ready，则解锁所有的channel，然后返回（default index, false）\n3. 所有case都未ready，且没有default语句\n3.1 将当前协程加入到所有channel的等待队列\n3.2 当将协程转入阻塞，等待被唤醒\n4. 唤醒后返回channel对应的case index\n4.1 如果是读操作，解锁所有的channel，然后返回(case index, true)\n4.2 如果是写操作，解锁所有的channel，然后返回(case index, false)\n参考资料：Go select的使用和实现原理.\ngo的interface怎么实现的？ go interface源码在runtime\\iface.go中。\ngo的接口由两种类型实现iface和eface。iface是包含方法的接口，而eface不包含方法。\niface 对应的数据结构是（位于src\\runtime\\runtime2.go）：\ntype iface struct { tab *itab data unsafe.Pointer } 可以简单理解为，tab表示接口的具体结构类型，而data是接口的值。\nitab： type itab struct { inter *interfacetype //此属性用于定位到具体interface _type *_type //此属性用于定位到具体interface hash uint32 // copy of _type.hash. Used for type switches. _ [4]byte fun [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter. } 属性interfacetype类似于_type，其作用就是interface的公共描述，类似的还有maptype、arraytype、chantype…其都是各个结构的公共描述，可以理解为一种外在的表现信息。interfaetype和type唯一确定了接口类型，而hash用于查询和类型判断。fun表示方法集。\neface 与iface基本一致，但是用_type直接表示类型，这样的话就无法使用方法。\ntype eface struct { _type *_type data unsafe.Pointer } 这里篇幅有限，深入讨论可以看：深入研究 Go interface 底层实现\ngo的reflect 底层实现 go reflect源码位于src\\reflect\\下面，作为一个库独立存在。反射是基于接口实现的。\nGo反射有三大法则：\n反射从接口映射到反射对象； ![](data:image/svg+xml;utf8,)\n法则1\n反射从反射对象映射到接口值； ![](data:image/svg+xml;utf8,)\n法则2\n只有值可以修改(settable)，才可以修改反射对象。 Go反射基于上述三点实现。我们先从最核心的两个源文件入手type.go和value.go.\ntype用于获取当前值的类型。value用于获取当前的值。\n参考资料：The Laws of Reflection， 图解go反射实现原理\ngo GC的原理知道吗？ 如果需要从源码角度解释GC，推荐阅读（非常详细，图文并茂）：\nhttps://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/\ngo里用过哪些设计模式 ? go的调试/分析工具用过哪些。 go的自带工具链相当丰富，\ngo cover : 测试代码覆盖率； godoc: 用于生成go文档； pprof：用于性能调优，针对cpu，内存和并发； race：用于竞争检测； 进程被kill，如何保证所有goroutine顺利退出 goroutine监听SIGKILL信号，一旦接收到SIGKILL，则立刻退出。可采用select方法。\nvar wg = \u0026amp;sync.WaitGroup{} func main() { wg.Add(1) go func() { c1 := make(chan os.Signal, 1) signal.Notify(c1, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT) fmt.Printf(\u0026#34;goroutine 1 receive a signal : %v\\n\\n\u0026#34;, \u0026lt;-c1) wg.Done() }() wg.Wait() fmt.Printf(\u0026#34;all groutine done!\\n\u0026#34;) } 说说context包的作用？你用过哪些，原理知道吗？ context可以用来在goroutine之间传递上下文信息，相同的context可以传递给运行在不同goroutine中的函数，上下文对于多个goroutine同时使用是安全的，context包定义了上下文类型，可以使用background、TODO创建一个上下文，在函数调用链之间传播context，也可以使用WithDeadline、WithTimeout、WithCancel 或 WithValue 创建的修改副本替换它，听起来有点绕，其实总结起就是一句话：context的作用就是在不同的goroutine之间同步请求特定的数据、取消信号以及处理请求的截止日期。\n关于context原理，可以参看：小白也能看懂的context包详解：从入门到精通\ngrpc为啥好，基本原理是什么，和http比呢 官方介绍：gRPC 是一个现代开源的高性能远程过程调用 (RPC) 框架，可以在任何环境中运行。它可以通过对负载平衡、跟踪、健康检查和身份验证的可插拔支持有效地连接数据中心内和跨数据中心的服务。它也适用于分布式计算的最后一英里，将设备、移动应用程序和浏览器连接到后端服务。\n区别：\n- rpc是远程过程调用，就是本地去调用一个远程的函数，而http是通过 url和符合restful风格的数据包去发送和获取数据；\n- rpc的一般使用的编解码协议更加高效，比如grpc使用protobuf编解码。而http的一般使用json进行编解码，数据相比rpc更加直观，但是数据包也更大，效率低下；\n- rpc一般用在服务内部的相互调用，而http则用于和用户交互；\n相似点：\n都有类似的机制，例如grpc的metadata机制和http的头机制作用相似，而且web框架，和rpc框架中都有拦截器的概念。grpc使用的是http2.0协议。\n官网：gRPC\netcd怎么搭建的，具体怎么用的 熔断怎么做的 服务降级怎么搞 1亿条数据动态增长，取top10，怎么实现 进程挂了怎么办 nginx配置过吗，有哪些注意的点 设计一个阻塞队列 mq消费阻塞怎么办 性能没达到预期，有什么解决方案 -\n编程系列 实现使用字符串函数名，调用函数。 思路：采用反射的Call方法实现。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type Animal struct{ } func (a *Animal) Eat(){ fmt.Println(\u0026#34;Eat\u0026#34;) } func main(){ a := Animal{} reflect.ValueOf(\u0026amp;a).MethodByName(\u0026#34;Eat\u0026#34;).Call([]reflect.Value{}) } （Goroutine）有三个函数，分别打印\u0026quot;cat\u0026quot;, \u0026ldquo;fish\u0026rdquo;,\u0026ldquo;dog\u0026quot;要求每一个函数都用一个goroutine，按照顺序打印100次。 此题目考察channel，用三个无缓冲channel，如果一个channel收到信号则通知下一个。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) var dog = make(chan struct{}) var cat = make(chan struct{}) var fish = make(chan struct{}) func Dog() { \u0026lt;-fish fmt.Println(\u0026#34;dog\u0026#34;) dog \u0026lt;- struct{}{} } func Cat() { \u0026lt;-dog fmt.Println(\u0026#34;cat\u0026#34;) cat \u0026lt;- struct{}{} } func Fish() { \u0026lt;-cat fmt.Println(\u0026#34;fish\u0026#34;) fish \u0026lt;- struct{}{} } func main() { for i := 0; i \u0026lt; 100; i++ { go Dog() go Cat() go Fish() } fish \u0026lt;- struct{}{} time.Sleep(10 * time.Second) } 两个协程交替打印10个字母和数字 思路：采用channel来协调goroutine之间顺序。\n主线程一般要waitGroup等待协程退出，这里简化了一下直接sleep。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) var word = make(chan struct{}, 1) var num = make(chan struct{}, 1) func printNums() { for i := 0; i \u0026lt; 10; i++ { \u0026lt;-word fmt.Println(1) num \u0026lt;- struct{}{} } } func printWords() { for i := 0; i \u0026lt; 10; i++ { \u0026lt;-num fmt.Println(\u0026#34;a\u0026#34;) word \u0026lt;- struct{}{} } } func main() { num \u0026lt;- struct{}{} go printNums() go printWords() time.Sleep(time.Second * 1) } 代码：\n@中二的灰太狼\n启动 2个groutine 2秒后取消， 第一个协程1秒执行完，第二个协程3秒执行完。 思路：采用ctx, _ := context.WithTimeout(context.Background(), time.Second*2)实现2s取消。协程执行完后通过channel通知，是否超时。\npackage main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func f1(in chan struct{}) { time.Sleep(1 * time.Second) in \u0026lt;- struct{}{} } func f2(in chan struct{}) { time.Sleep(3 * time.Second) in \u0026lt;- struct{}{} } func main() { ch1 := make(chan struct{}) ch2 := make(chan struct{}) ctx, _ := context.WithTimeout(context.Background(), 2*time.Second) go func() { go f1(ch1) select { case \u0026lt;-ctx.Done(): fmt.Println(\u0026#34;f1 timeout\u0026#34;) break case \u0026lt;-ch1: fmt.Println(\u0026#34;f1 done\u0026#34;) } }() go func() { go f2(ch2) select { case \u0026lt;-ctx.Done(): fmt.Println(\u0026#34;f2 timeout\u0026#34;) break case \u0026lt;-ch2: fmt.Println(\u0026#34;f2 done\u0026#34;) } }() time.Sleep(time.Second * 5) } 代码：\n@中二的灰太狼\n当select监控多个chan同时到达就绪态时，如何先执行某个任务？ 可以在子case再加一个for select语句。\nfunc priority_select(ch1, ch2 \u0026lt;-chan string) { for { select { case val := \u0026lt;-ch1: fmt.Println(val) case val2 := \u0026lt;-ch2: priority: for { select { case val1 := \u0026lt;-ch1: fmt.Println(val1) default: break priority } } fmt.Println(val2) } } } 总结 Go面试复习应该有所侧重，关注切片，通道，异常处理，Goroutine，GMP模型，字符串高效拼接，指针，反射，接口，sync。对于比较难懂的部分，GMP模型和GC和内存管理，应该主动去看源码，然后慢慢理解。业务代码写多了，自然就有理解了。\n","permalink":"https://liiqii.github.io/posts/tech/go/go_interview_questions/","summary":"转自：Go常见面试题【由浅入深】2022版 基础语法 01 = 和 := 的区别？ =是赋值变量，:=是定义变量。 02 指针的作用 一个指针可以指向任意变量的地址，它所指向的地址在32位或64位机器上分别固定占4或8个字节。指针的作用有： 获取变量的值 import fmt ​ func main(){ a := 1 p := \u0026amp;a//取址\u0026amp; fmt.Printf(\u0026#34;%d\\n\u0026#34;, *","title":"Go常见面试题"},{"content":"crontab定时任务格式 # .---------------- minute (0 - 59) # | .------------- hour (0 - 23) # | | .---------- day of month (1 - 31) # | | | .------- month (1 - 12) OR jan,feb,mar,apr ... # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat # | | | | | # * * * * * command to be executed 其中前面的6个星号表示的含义如下：\nminute：表示分钟，可以是从0到59之间的任何整数。 hour：表示小时，可以是从0到23之间的任何整数。 day：表示日期，可以是从1到31之间的任何整数。 month：表示月份，可以是从1到12之间的任何整数。 week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。 command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。 每一个星号部分可用下面的特殊符号：\n星号（*）：通配符匹配，代表所有可能的值。 逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”。 中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”。 正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。 crontab -l 查看定时任务 crontab -e 编辑定时任务 crontab定时任务实例 时间频次示例 下面列举常用的时间频次示例。\n00 05 * * * : 每天凌晨5点执行\n20 12 1,10,20 * * : 每个月的1号，10号，20号的12:30执行\n10 1 * * 6,0 : 表示每周六、周日的1:10分执行\n0,30 18-23 * * * : 每天18:00至23:00之间每隔30分钟执行\n0 23-7/1 * * * : 晚上11点到早上7点之间，每隔一小时执行\n0 6-12/3 * 10 * : 每年10月的每天早上6点到12点每隔3个小时执行一次\n30 17 * * 1-5 : 周一到周五下午5点30分执行一次\n0 */2 * * * ：每两个小时执行一次\n比如我们需要每天23点58分的时候执行一个更新数据的shell脚本，可以用crontab -e命令在后添加一行：\n58 23 * * * sh /home/work/update.sh 输入输出重定向 在上面更新数据定时任务的实例中，如果执行update.sh的时候有错误信息输出，会输出到哪儿呢？\n在没有配置输出重定向的时候，定时任务会见错误输出到下面的文件：/var/log/mail/{$user}，这是很不好的，我们往往需要把不同的脚本输出到不同的日志文件，方便查看脚本的执行情况，这个时候需要使用输出重定向。\n58 23 * * * sh /home/work/update.sh \u0026gt;\u0026gt; /home/work/log/update.log 2\u0026gt;\u0026amp;1 Linux中使用0-3作为文件描述符来表示标准流。\n名称 类型 文件描述符 操作 stdin 标准输入 standard input \u0026lt;,\u0026lt;\u0026lt; stdout 标准输出 standard output 1 \u0026gt;,\u0026gt;\u0026gt; stderr 标准错误输出 standard error output 2 2\u0026gt;,2\u0026gt;\u0026gt; 在上面的定时任务脚本中，update.sh后面的\u0026gt;\u0026gt;表示将输出追加到update.log文件中，2\u0026gt;\u0026amp;1表示标准错误输出重定向等同于标准输出。\n推荐阅读：Linux 知识大全。\n忽略输入nohup 有时候我们还会看到在定时任务脚本前面有一个nohup的命令，该命令用于指定后面的脚本忽略输入。\n58 23 * * * nohup sh /home/work/update.sh \u0026gt;\u0026gt; /home/work/log/update.log 2\u0026gt;\u0026amp;1 后台执行\u0026amp; 无论是在控制台直接执行，还是在定时任务脚本中，我们在某一条命令的后面加上\u0026amp;符号，表示当前命令在后台运行，不占用控制台。\n58 23 * * * nohup sh /home/work/update.sh \u0026gt;\u0026gt; /home/work/log/update.log 2\u0026gt;\u0026amp;1 \u0026amp; 这里需要注意，如果执行的命令有等待输入的交互，把这个命令使用\u0026amp;放在后台运行时，它会一直等待输入，但是有没有输入，就卡住不动了。\n时间处理 再回顾上面的更新任务，它是将每一天的运行结果都重定向到update.log文件，如果输出比较多，我们就需要每一天输出的不同的文件，可以通过在输出目录中指定日期用来分割。如下：\n58 23 * * * nohup sh /home/work/update.sh \u0026gt;\u0026gt; /home/work/log/`update_\u0026#34;date +\\%Y\\%m\\%d\u0026#34;.log` 2\u0026gt;\u0026amp;1 \u0026amp;# 或者下面的形式58 23 * * * nohup sh /home/work/update.sh \u0026gt;\u0026gt; \u0026#34;/home/work/log/update_\u0026#34;date +\\%Y\\%m\\%d\u0026#34;.log\u0026#34; 2\u0026gt;\u0026amp;1 \u0026amp; 这里使用date函数，需要注意的是，crontab里面的脚本命令和直接在命令行运行的脚本可能是不一样的，尤其是date函数中的%需要转义。\n可以直接在命令行运行下面命令：\nsh /home/work/update.sh \u0026gt;\u0026gt; /home/work/log/update_`date +\u0026#34;%Y%m%d\u0026#34;.log` 2\u0026gt;\u0026amp;1 \u0026amp; 达到和定时任务里面相同的效果，都是输出到update_20201120.log的文件。\n但是如果直接在crontab中这样配置，则无法识别，不会执行该定时任务。下面的crontab任务是不会执行的，date函数将会报错。\n58 23 * * * nohup sh /home/work/update.sh \u0026gt;\u0026gt; /home/work/log/`update_\u0026#34;date +%Y%m%d\u0026#34;.log` 2\u0026gt;\u0026amp;1 \u0026amp; ","permalink":"https://liiqii.github.io/posts/tech/linux/linux_crontab/","summary":"crontab定时任务格式 # .---------------- minute (0 - 59) # | .------------- hour (0 - 23) # | | .---------- day of month (1 - 31) # | | | .------- month (1 - 12) OR jan,feb,mar,apr ... # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat # | | | | | # * * * * * command to be executed 其中前面的6个星号表示的含义如下： minute：表示分钟，可以是从0到59之间的任何整数。 hour：表示小时，可以是从","title":"Linux 定时任务"},{"content":"安装 https://golang.google.cn/dl/ #下载 wget https://golang.google.cn/dl/go1.19.9.linux-amd64.tar.gz #解压 tar -C /usr/local -xzf go1.19.9.linux-amd64.tar.gz #建立软连接 ln -s /usr/local/go/bin/* /usr/bin/ #设置环境变量 vim /etc/profile #在文件末尾插入下面2行，保存退出 export GOPATH=\u0026#34;$HOME/go\u0026#34; export PATH=\u0026#34;$PATH:/usr/local/go/bin:$GOPATH/bin\u0026#34; #使配置文件生效 source /etc/profile 测试是否安装成功 go version 查看环境变量 go env ","permalink":"https://liiqii.github.io/posts/tech/go/linux_install_go/","summary":"安装 https://golang.google.cn/dl/ #下载 wget https://golang.google.cn/dl/go1.19.9.linux-amd64.tar.gz #解压 tar -C /usr/local -xzf go1.19.9.linux-amd64.tar.gz #建立软连接 ln -s /usr/local/go/bin/* /usr/bin/ #设置环境变量 vim /etc/profile #在文件末尾插入下面2行，保存退出 export GOPATH=\u0026#34;$HOME/go\u0026#34; export PATH=\u0026#34;$PATH:/usr/local/go/bin:$GOPATH/bin\u0026#34; #使配置文件生效 source /etc/profile 测试是否安装成功 go version 查看环境变量 go env","title":"Linux安装指定版本golang"},{"content":"首先可以查看下Linux系统下的PHP版本，命令：php -v\n最常见的PHP卸载命令为：yum remove php，但是这种方法并删除PHP是不干净的，会有残留，那么如何完全的卸载PHP呢？Linux百科网告诉你：\n完全卸载删除PHP 查看全部的PHP软件包，命令：rpm -qa|grep php\n实例如下：\n[root@linuxbaike ~]# rpm -qa|grep php php-cli-5.4.16-46.el7.x86_64 php-common-5.4.16-46.el7.x86_64 php-5.4.16-46.el7.x86_64\n找到PHP的软件包后，我们使用命令：rpm -e 软件包名的方式一个个删除即可完全删除。\n注意：由于某些PHP软件包被其他PHP软件包所依赖，删除顺序不同，回到值无法删除，例如上面的实例中 php-cli-5.4.16-46.el7.x86_64 被其他的PHP软件包所需要，如果先执行命令：rpm -e php-cli-5.4.16-46.el7.x86_64会删除不了，所以执行删除顺序为：\nrpm -e php-5.4.16-46.el7.x86_64\nrpm -e php-cli-5.4.16-46.el7.x86_64\nrmp -e php-common-5.4.16-46.el7.x86_64\n删除完毕后，可以使用命令php -v检查下是否还会返回版本信息，如果没有提示，说明已经删除了。\n综上，先使用命令rpm -qa|grep php检查全部的PHP软件包，然后再使用命令rpm -e 软件包名删除PHP软件包。\n","permalink":"https://liiqii.github.io/posts/tech/linux/linux_delete_php/","summary":"首先可以查看下Linux系统下的PHP版本，命令：php -v 最常见的PHP卸载命令为：yum remove php，但是这种方法并删除PHP是不干净的，会有残留，那么如何完全的卸载PHP呢？Linux百科网告诉你： 完全卸载删除PHP 查看全部的PHP软件包，命令：rpm -qa|grep php 实例如下： [root@linuxbaike ~]# rpm -qa|grep php php-cli-5.4.16-46.el7.x86_64 php-common-5.4.16-46.el7.x86_64","title":"Linux系统完全卸载删除PHP的方法"},{"content":"我的vim配置 ~/.vimrc有时并不存在，此时用户可以建立一个.vimrc，放入主目录以实现自己的vim配置。\n\u0026#34; 解决插入模式下delete/backspce键失效问题： set backspace=indent,eol,start \u0026#34; 打开语法高亮 syntax on \u0026#34; 使用配色方案 colorscheme desert \u0026#34; 打开文件类型检测功能 filetype on \u0026#34; 不同文件类型采用不同缩进 filetype indent on \u0026#34; 允许使用插件 filetype plugin on filetype plugin indent on \u0026#34; 关闭vi模式 \u0026#34; set nocp \u0026#34; 与windows共享剪贴板 set clipboard+=unnamed \u0026#34; 取消VI兼容，VI键盘模式不易用 \u0026#34; set nocompatible \u0026#34; 显示行号, 或set number set nu \u0026#34; 历史命令保存行数 set history=100 \u0026#34; 当文件被外部改变时自动读取 set autoread \u0026#34; 取消自动备份及产生swp文件 set nobackup set nowb set noswapfile \u0026#34; 允许使用鼠标点击定位 set mouse=a \u0026#34; 允许区域选择 set selection=exclusive set selectmode=mouse,key \u0026#34; 高亮光标所在行 set cursorline \u0026#34; 取消光标闪烁 set novisualbell \u0026#34; 总是显示状态行 set laststatus=2 \u0026#34; 状态栏显示当前执行的命令 set showcmd \u0026#34; 标尺功能，显示当前光标所在行列号 set ruler \u0026#34; 设置命令行高度为3 set cmdheight=3 \u0026#34; 粘贴时保持格式 set paste \u0026#34; 高亮显示匹配的括号 set showmatch \u0026#34; 在搜索的时候忽略大小写 set ignorecase \u0026#34; 高亮被搜索的句子 set hlsearch \u0026#34; 在搜索时，输入的词句的逐字符高亮（类似firefox的搜索） set incsearch \u0026#34; 继承前一行的缩进方式，特别适用于多行注释 set autoindent \u0026#34; 为C程序提供自动缩进 set smartindent \u0026#34; 使用C样式的缩进 set cindent \u0026#34; 制表符为4 set tabstop=4 \u0026#34; 统一缩进为4 set softtabstop=4 set shiftwidth=4 \u0026#34; 允许使用退格键，或set backspace=2 set backspace=eol,start,indent set whichwrap+=\u0026lt;,\u0026gt;,h,l \u0026#34; 取消换行 set nowrap \u0026#34; 启动的时候不显示那个援助索马里儿童的提示 set shortmess=atI \u0026#34; 在被分割的窗口间显示空白，便于阅读 set fillchars=vert:\\ ,stl:\\ ,stlnc:\\ \u0026#34; 光标移动到buffer的顶部和底部时保持3行距离, 或set so=3 set scrolloff=3 \u0026#34; 设定默认解码 set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936 set termencoding=utf-8 set encoding=utf-8 \u0026#34; 自动补全 filetype plugin indent on set completeopt=longest,menu \u0026#34; 自动补全命令时候使用菜单式匹配列表 set wildmenu autocmd FileType ruby,eruby set omnifunc=rubycomplete#Complete autocmd FileType python set omnifunc=pythoncomplete#Complete autocmd FileType javascript set omnifunc=javascriptcomplete#CompleteJS autocmd FileType html set omnifunc=htmlcomplete#CompleteTags autocmd FileType css set omnifunc=csscomplete#CompleteCSS autocmd FileType xml set omnifunc=xmlcomplete#CompleteTags autocmd FileType java set omnifunc=javacomplete#Complet ","permalink":"https://liiqii.github.io/posts/tech/linux/vim/","summary":"我的vim配置 ~/.vimrc有时并不存在，此时用户可以建立一个.vimrc，放入主目录以实现自己的vim配置。 \u0026#34; 解决插入模式下delete/backspce键失效问题： set backspace=indent,eol,start \u0026#34; 打开语法高亮 syntax on \u0026#34; 使用配色方案 colorscheme desert \u0026#34; 打开文件类型检测功能 filetype on \u0026#34; 不同文件类型采用不同缩进 filetype indent on \u0026#34; 允许使用插","title":"Vim 配置"},{"content":"随便来点什么测试一下\n","permalink":"https://liiqii.github.io/posts/blog/blog/","summary":"随便来点什么测试一下","title":"建站"},{"content":"随便来点什么测试一下\n","permalink":"https://liiqii.github.io/posts/life/life/","summary":"随便来点什么测试一下","title":"生活"},{"content":"随便来点什么测试一下\n","permalink":"https://liiqii.github.io/posts/read/read/","summary":"随便来点什么测试一下","title":"阅读"},{"content":"\r👉友链格式\r名称： XXXXXX 网址： https://liiqii.github.io/ 图标： https://liiqii.github.io/img/Q.gif 描述： XXXXXX 👉友链申请要求\r秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n","permalink":"https://liiqii.github.io/links/","summary":"👉友链格式 名称： XXXXXX 网址： https://liiqii.github.io/ 图标： https://liiqii.github.io/img/Q.gif 描述： XXXXXX 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内","title":"🤝友链"},{"content":"关于我\n英文名: Klaus 职业: 程序员 爱好: 游戏 ","permalink":"https://liiqii.github.io/about/","summary":"关于我 英文名: Klaus 职业: 程序员 爱好: 游戏","title":"🙋🏻‍♂️关于"}]