<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Go 23种设计模式 | liiqii</title>
<meta name="keywords" content="">
<meta name="description" content="Go 23种设计模式">
<meta name="author" content="liiqii">
<link rel="canonical" href="https://liiqii.github.io/posts/tech/go/go_design_mode/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.js" onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://liiqii.github.io/img/icon.jpg">
<link rel="icon" type="image/png" sizes="16x16" href="https://liiqii.github.io/img/icon.jpg">
<link rel="icon" type="image/png" sizes="32x32" href="https://liiqii.github.io/img/icon.jpg">
<link rel="apple-touch-icon" href="https://liiqii.github.io/img/icon.jpg">
<link rel="mask-icon" href="https://liiqii.github.io/img/icon.jpg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js"></script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = ""; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<meta property="og:title" content="Go 23种设计模式" />
<meta property="og:description" content="Go 23种设计模式" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://liiqii.github.io/posts/tech/go/go_design_mode/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-10T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-10-10T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go 23种设计模式"/>
<meta name="twitter:description" content="Go 23种设计模式"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [

        {
          "@type": "ListItem",
          "position":  1 ,
          "name": "📚文章",
          "item": "https://liiqii.github.io/posts/"
        },

        {
          "@type": "ListItem",
          "position":  2 ,
          "name": "👨🏻‍💻 技术",
          "item": "https://liiqii.github.io/posts/tech/"
        }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Go 23种设计模式",
      "item": "https://liiqii.github.io/posts/tech/go/go_design_mode/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go 23种设计模式",
  "name": "Go 23种设计模式",
  "description": "Go 23种设计模式",
  "keywords": [
    ""
  ],
  "articleBody": "创建型模式 创建型模式是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象，增加已有代码的灵活性和可复用性。\n工厂方法模式 Factory Method 问题 假设我们的业务需要一个支付渠道，我们开发了一个Pay方法，其可以用于支付。请看以下示例：\ntype Pay interface { Pay() string } type PayReq struct { OrderId string // 订单号 } func (p *PayReq) Pay() string { // todo fmt.Println(p.OrderId) return \"支付成功\" } 如上，我们定义了接口Pay，并实现了其方法Pay()。\n如果业务需求变更，需要我们提供多种支付方式，一种叫APay，一种叫BPay，这二种支付方式所需的参数不同，APay只需要订单号OrderId，BPay则需要订单号OrderId和Uid。此时如何修改？\n很容易想到的是在原有的代码基础上修改，比如：\ntype Pay interface { APay() string BPay() string } type PayReq struct { OrderId string // 订单号 Uid int64 } func (p *PayReq) APay() string { // todo fmt.Println(p.OrderId) return \"APay支付成功\" } func (p *PayReq) BPay() string { // todo fmt.Println(p.OrderId) fmt.Println(p.Uid) return \"BPay支付成功\" } 我们为Pay接口实现了APay() 和BPay() 方法。虽然暂时实现了业务需求，但却使得结构体PayReq变得冗余了，APay() 并不需要Uid参数。如果之后再增加CPay、DPay、EPay，可想而知，代码会变得越来越难以维护。\n随着后续业务迭代，将不得不编写出复杂的代码。\n解决 让我们想象一个工厂类，这个工厂类需要生产电线和开关等器具，我们可以为工厂类提供一个生产方法，当电线机器调用生产方法时，就产出电线，当开关机器调用生产方法时，就产出开关。\n套用到我们的支付业务来，就是我们不再为接口提供APay方法、BPay方法，而只提供一个Pay方法，并将A支付方式和B支付方式的区别下放到子类。\n请看示例：\npackage factorymethod import \"fmt\" type Pay interface { Pay(string) int } type PayReq struct { OrderId string } type APayReq struct { PayReq } func (p *APayReq) Pay() string { // todo fmt.Println(p.OrderId) return \"APay支付成功\" } type BPayReq struct { PayReq Uid int64 } func (p *BPayReq) Pay() string { // todo fmt.Println(p.OrderId) fmt.Println(p.Uid) return \"BPay支付成功\" } 我们用APay和BPay两个结构体重写了Pay() 方法，如果需要添加一种新的支付方式， 只需要重写新的Pay() 方法即可。\n工厂方法的优点就在于避免了创建者和具体产品之间的紧密耦合，从而使得代码更容易维护。\n测试代码：\npackage factorymethod import ( \"testing\" ) func TestPay(t *testing.T) { aPay := APayReq{} if aPay.Pay() != \"APay支付成功\" { t.Fatal(\"aPay error\") } bPay := BPayReq{} if bPay.Pay() != \"BPay支付成功\" { t.Fatal(\"bPay error\") } } 抽象工厂模式 Abstract Factory 问题 抽象工厂模式基于工厂方法模式。两者的区别在于：工厂方法模式是创建出一种产品，而抽象工厂模式是创建出一类产品。这二种都属于工厂模式，在设计上是相似的。\n假设，有一个存储工厂，提供redis和mysql两种存储数据的方式。如果使用工厂方法模式，我们就需要一个存储工厂，并提供SaveRedis方法和SaveMysql方法。\n如果此时业务还需要分成存储散文和古诗两种载体，这两种载体都可以进行redis和mysql存储。就可以使用抽象工厂模式，我们需要一个存储工厂作为父工厂，散文工厂和古诗工厂作为子工厂，并提供SaveRedis方法和SaveMysql方法。\n解决 以上文的存储工厂业务为例，用抽象工厂模式的思路来设计代码，就像下面这样：\npackage abstractfactory import \"fmt\" // SaveArticle 抽象模式工厂接口 type SaveArticle interface { CreateProse() Prose CreateAncientPoetry() AncientPoetry } type SaveRedis struct{} func (*SaveRedis) CreateProse() Prose { return \u0026RedisProse{} } func (*SaveRedis) CreateAncientPoetry() AncientPoetry { return \u0026RedisProse{} } type SaveMysql struct{} func (*SaveMysql) CreateProse() Prose { return \u0026MysqlProse{} } func (*SaveMysql) CreateAncientPoetry() AncientPoetry { return \u0026MysqlProse{} } // Prose 散文 type Prose interface { SaveProse() } // AncientPoetry 古诗 type AncientPoetry interface { SaveAncientPoetry() } type RedisProse struct{} func (*RedisProse) SaveProse() { fmt.Println(\"Redis Save Prose\") } func (*RedisProse) SaveAncientPoetry() { fmt.Println(\"Redis Save Ancient Poetry\") } type MysqlProse struct{} func (*MysqlProse) SaveProse() { fmt.Println(\"Mysql Save Prose\") } func (*MysqlProse) SaveAncientPoetry() { fmt.Println(\"Mysql Save Ancient Poetry\") } 我们定义了存储工厂，也就是SaveArticle接口，并实现了CreateProse方法和CreateAncientPoetry方法，这2个方法分别用于创建散文工厂和古诗工厂。\n然后我们又分别为散文工厂和古诗工厂实现了SaveProse方法和SaveAncientPoetry方法，并用Redis结构体和Mysql结构体分别重写了2种存储方法。\n测试代码：\npackage abstractfactory func Save(saveArticle SaveArticle) { saveArticle.CreateProse().SaveProse() saveArticle.CreateAncientPoetry().SaveAncientPoetry() } func ExampleSaveRedis() { var factory SaveArticle factory = \u0026SaveRedis{} Save(factory) // Output: // Redis Save Prose // Redis Save Ancient Poetry } func ExampleSaveMysql() { var factory SaveArticle factory = \u0026SaveMysql{} Save(factory) // Output: // Mysql Save Prose // Mysql Save Ancient Poetry } 建造者模式 Builder 问题 假设业务需要按步骤创建一系列复杂的对象，实现这些步骤的代码加在一起非常繁复，我们可以将这些代码放进一个包含了众多参数的构造函数中，但这个构造函数看起来将会非常杂乱无章，且难以维护。\n假设业务需要建造一个房子对象，需要先打地基、建墙、建屋顶、建花园、放置家具……。我们需要非常多的步骤，并且这些步骤之间是有联系的，即使将各个步骤从一个大的构造函数抽出到其他小函数中，整个程序的层次结构看起来依然很复杂。\n如何解决呢？像这种复杂的有许多步骤的构造函数，就可以用建造者模式来设计。\n建造者模式的用处就在于能够分步骤创建复杂对象。\n解决 在建造者模式中，我们需要清晰的定义每个步骤的代码，然后在一个构造函数中操作这些步骤，我们需要一个主管类，用这个主管类来管理各步骤。这样我们就只需要将所需参数传给一个构造函数，构造函数再将参数传递给对应的主管类，最后由主管类完成后续所有建造任务。\n请看以下代码：\npackage builder import \"fmt\" // 建造者接口 type Builder interface { Part1() Part2() Part3() } // 管理类 type Director struct { builder Builder } // 构造函数 func NewDirector(builder Builder) *Director { return \u0026Director{ builder: builder, } } // 建造 func (d *Director) Construct() { d.builder.Part1() d.builder.Part2() d.builder.Part3() } type Builder struct {} func (b *Builder) Part1() { fmt.Println(\"part1\") } func (b *Builder) Part2() { fmt.Println(\"part2\") } func (b *Builder) Part3() { fmt.Println(\"part3\") } 如上，我们实现part1、part2、part3这3个步骤，只需要执行构造函数，对应的管理类就可以运行建造方法Construct，完成3个步骤的执行。\n测试代码：\npackage builder func ExampleBuilder() { builder := \u0026Builder{} director := NewDirector(builder) director.Construct() // Output: // part1 // part2 // part3 } 原型模式 Prototype 问题 如果你希望生成一个对象，其与另一个对象完全相同，该如何实现呢？\n如果遍历对象的所有成员，将其依次复制到新对象中，会稍显麻烦，而且有些对象可能会有私有成员变量遗漏。\n原型模式将这个克隆的过程委派给了被克隆的实际对象，被克隆的对象就叫做“原型”。\n解决 如果需要克隆一个新的对象，这个对象完全独立于它的原型，那么就可以使用原型模式。\n原型模式的实现非常简单，请看以下代码：\npackage prototype import \"testing\" var manager *PrototypeManager type Type1 struct { name string } func (t *Type1) Clone() *Type1 { tc := *t return \u0026tc } func TestClone(t *testing.T) { t1 := \u0026Type1{ name: \"type1\", } t2 := t1.Clone() if t1 == t2 { t.Fatal(\"error! get clone not working\") } } 我们依靠一个Clone方法实现了原型Type1的克隆。\n原型模式的用处就在于我们可以克隆对象，而无需与原型对象的依赖相耦合。\n单例模式 Singleton 问题 存储着重要对象的全局变量，往往意味着“不安全”，因为你无法保证这个全局变量的值不会在项目的某个引用处被覆盖掉。\n对数据的修改经常导致出乎意料的的结果和难以发现的bug。我在一处更新数据，却没有意识到软件中的另一处期望着完全不同的数据，于是一个功能就失效了，而且找出故障的原因也会非常困难。\n一个较好的解决方案是：将这样的“可变数据”封装起来，写一个查询方法专门用来获取这些值。\n单例模式则更进一步：除了要为“可变数据”提供一个全局访问方法，它还要保证获取到的只有同一个实例。也就是说，如果你打算用一个构造函数创建一个对象，单例模式将保证你得到的不是一个新的对象，而是之前创建过的对象，并且每次它所返回的都只有这同一个对象，也就是单例。这可以保护该对象实例不被篡改。\n解决 单例模式需要一个全局构造函数，这个构造函数会返回一个私有的对象，无论何时调用，它总是返回相同的对象。\n请看以下代码：\npackage singleton import ( \"sync\" ) // 单例实例 type singleton struct { Value int } type Singleton interface { getValue() int } func (s singleton) getValue() int { return s.Value } var ( instance *singleton once sync.Once ) // 构造方法，用于获取单例模式对象 func GetInstance(v int) Singleton { once.Do(func() { instance = \u0026singleton{Value: v} }) return instance } 单例实例singleton被保存为一个私有的变量，以保证不被其他包的函数引用。\n用构造方法GetInstance可以获得单例实例，函数中使用了sync包的once方法，以保证实例只会在首次调用时被初始化一次，之后再调用构造方法都只会返回同一个实例。\n测试代码：\nfunc TestSingleton(t *testing.T) { ins1 := GetInstance2(1) ins2 := GetInstance2(2) if ins1 != ins2 { t.Fatal(\"instance is not equal\") } } 如果你需要更加严格地控制全局变量，这确实很有必要，那么就使用单例模式吧。\n结构型模式 结构型模式将一些对象和类组装成更大的结构体，并同时保持结构的灵活和高效。\n适配器模式 Adapter 问题 适配器模式说白了就是兼容。\n假设一开始我们提供了A对象，后期随着业务迭代，又需要从A对象的基础之上衍生出不同的需求。如果有很多函数已经在线上调用了A对象，此时再对A对象进行修改就比较麻烦，因为需要考虑兼容问题。还有更糟糕的情况， 你可能没有程序库的源代码， 从而无法对其进行修改。\n此时就可以用一个适配器，它就像一个接口转换器，调用方只需要调用这个适配器接口，而不需要关注其背后的实现，由适配器接口封装复杂的过程。\n解决 假设有2个接口，一个将厘米转为米，一个将米转为厘米。我们提供一个适配器接口，使调用方不需要再操心调用哪个接口，直接由适配器做好兼容。\n请看以下代码：\npackage adapter // 提供一个获取米的接口和一个获取厘米的接口 type Cm interface { getLength(float64) float64 } type M interface { getLength(float64) float64 } func NewM() M { return \u0026getLengthM{} } type getLengthM struct{} func (*getLengthM) getLength(cm float64) float64 { return cm / 10 } func NewCm() Cm { return \u0026getLengthCm{} } type getLengthCm struct{} func (a *getLengthCm) getLength(m float64) float64 { return m * 10 } // 适配器 type LengthAdapter interface { getLength(string, float64) float64 } func NewLengthAdapter() LengthAdapter { return \u0026getLengthAdapter{} } type getLengthAdapter struct{} func (*getLengthAdapter) getLength(isType string, into float64) float64 { if isType == \"m\" { return NewM().getLength(into) } return NewCm().getLength(into) } 上面实现了Cm和M两个接口，并由适配器LengthAdapter做兼容。\n测试代码：\npackage adapter import \"testing\" func TestAdapter(t *testing.T) { into := 10.5 getLengthAdapter := NewLengthAdapter().getLength(\"m\", into) getLengthM := NewM().getLength(into) if getLengthAdapter != getLengthM { t.Fatalf(\"getLengthAdapter: %f, getLengthM: %f\", getLengthAdapter, getLengthM) } } 桥接模式Bridge 问题 假设一开始业务需要两种发送信息的渠道，sms和email，我们可以分别实现sms和email两个接口。\n之后随着业务迭代，又产生了新的需求，需要提供两种系统发送方式，systemA和systemB，并且这两种系统发送方式都应该支持sms和email渠道。\n此时至少需要提供4种方法：systemA to sms，systemA to email，systemB to sms，systemB to email。\n如果再分别增加一种渠道和一种系统发送方式，就需要提供9种方法。这将导致代码的复杂程度指数增长。\n解决 其实之前我们是在用继承的想法来看问题，桥接模式则希望将继承关系转变为关联关系，使两个类独立存在。\n详细说一下：\n桥接模式需要将抽象和实现区分开； 桥接模式需要将“渠道”和“系统发送方式”这两种类别区分开； 最后在“系统发送方式”的类里调用“渠道”的抽象接口，使他们从继承关系转变为关联关系。 用一句话总结桥接模式的理念，就是：“将抽象与实现解耦，将不同类别的继承关系改为关联关系。 ”\n请看以下代码：\npackage bridge import \"fmt\" // 两种发送消息的方法 type SendMessage interface { send(text, to string) } type sms struct{} func NewSms() SendMessage { return \u0026sms{} } func (*sms) send(text, to string) { fmt.Println(fmt.Sprintf(\"send %s to %s sms\", text, to)) } type email struct{} func NewEmail() SendMessage { return \u0026email{} } func (*email) send(text, to string) { fmt.Println(fmt.Sprintf(\"send %s to %s email\", text, to)) } // 两种发送系统 type systemA struct { method SendMessage } func NewSystemA(method SendMessage) *systemA { return \u0026systemA{ method: method, } } func (m *systemA) SendMessage(text, to string) { m.method.send(fmt.Sprintf(\"[System A] %s\", text), to) } type systemB struct { method SendMessage } func NewSystemB(method SendMessage) *systemB { return \u0026systemB{ method: method, } } func (m *systemB) SendMessage(text, to string) { m.method.send(fmt.Sprintf(\"[System B] %s\", text), to) } 可以看到我们先定义了sms和email二种实现，以及接口SendMessage。接着我们实现了systemA和systemB，并调用了抽象接口SendMessage。\n测试代码：\npackage bridge func ExampleSystemA() { NewSystemA(NewSms()).SendMessage(\"hi\", \"baby\") NewSystemA(NewEmail()).SendMessage(\"hi\", \"baby\") // Output: // send [System A] hi to baby sms // send [System A] hi to baby email } func ExampleSystemB() { NewSystemB(NewSms()).SendMessage(\"hi\", \"baby\") NewSystemB(NewEmail()).SendMessage(\"hi\", \"baby\") // Output: // send [System B] hi to baby sms // send [System B] hi to baby email } 如果你想要拆分或重组一个具有多重功能的复杂类，可以使用桥接模式。\n对象树模式Object Tree 问题 在项目中，如果我们需要用到树状结构，就可以使用对象树模式。换言之，如果项目的核心模型不能以树状结构表示，则没必要使用对象树模式。\n对象树模式的用处就在于可以利用多态和递归机制更方便地使用复杂树结构。\n解决 请看以下代码：\npackage objecttree import \"fmt\" type Component interface { Parent() Component SetParent(Component) Name() string SetName(string) AddChild(Component) Search(string) } const ( LeafNode = iota CompositeNode ) func NewComponent(kind int, name string) Component { var c Component switch kind { case LeafNode: c = NewLeaf() case CompositeNode: c = NewComposite() } c.SetName(name) return c } type component struct { parent Component name string } func (c *component) Parent() Component { return c.parent } func (c *component) SetParent(parent Component) { c.parent = parent } func (c *component) Name() string { return c.name } func (c *component) SetName(name string) { c.name = name } func (c *component) AddChild(Component) {} type Leaf struct { component } func NewLeaf() *Leaf { return \u0026Leaf{} } func (c *Leaf) Search(pre string) { fmt.Printf(\"leaf %s-%s\\n\", pre, c.Name()) } type Composite struct { component childs []Component } func NewComposite() *Composite { return \u0026Composite{ childs: make([]Component, 0), } } func (c *Composite) AddChild(child Component) { child.SetParent(c) c.childs = append(c.childs, child) } func (c *Composite) Search(pre string) { fmt.Printf(\"%s+%s\\n\", pre, c.Name()) pre += \" \" for _, comp := range c.childs { comp.Search(pre) } } 在Search方法中使用递归打印出了整棵树结构。\n测试代码：\npackage objecttree func ExampleComposite() { root := NewComponent(CompositeNode, \"root\") c1 := NewComponent(CompositeNode, \"c1\") c2 := NewComponent(CompositeNode, \"c2\") c3 := NewComponent(CompositeNode, \"c3\") l1 := NewComponent(LeafNode, \"l1\") l2 := NewComponent(LeafNode, \"l2\") l3 := NewComponent(LeafNode, \"l3\") root.AddChild(c1) root.AddChild(c2) c1.AddChild(c3) c1.AddChild(l1) c2.AddChild(l2) c2.AddChild(l3) root.Search(\"\") // Output: // +root // +c1 // +c3 //leaf -l1 // +c2 //leaf -l2 //leaf -l3 } 装饰模式Decorator 问题 有时候我们需要在一个类的基础上扩展另一个类，例如，一个披萨类，你可以在披萨类的基础上增加番茄披萨类和芝士披萨类。此时就可以使用装饰模式，简单来说，装饰模式就是将对象封装到另一个对象中，用以为原对象绑定新的行为。\n如果你希望在无需修改代码的情况下使用对象，并且希望为对象新增额外的行为，就可以考虑使用装饰模式。\n解决 用上文的披萨类做例子。请看以下代码：\npackage decorator type pizza interface { getPrice() int } type base struct {} func (p *base) getPrice() int { return 15 } type tomatoTopping struct { pizza pizza } func (c *tomatoTopping) getPrice() int { pizzaPrice := c.pizza.getPrice() return pizzaPrice + 10 } type cheeseTopping struct { pizza pizza } func (c *cheeseTopping) getPrice() int { pizzaPrice := c.pizza.getPrice() return pizzaPrice + 20 } 首先我们定义了pizza接口，创建了base类，实现了方法getPrice。然后再用装饰模式的理念，实现了tomatoTopping和cheeseTopping类，他们都封装了pizza接口的getPrice方法。\n测试代码：\npackage decorator import \"fmt\" func ExampleDecorator() { pizza := \u0026base{} //Add cheese topping pizzaWithCheese := \u0026cheeseTopping{ pizza: pizza, } //Add tomato topping pizzaWithCheeseAndTomato := \u0026tomatoTopping{ pizza: pizzaWithCheese, } fmt.Printf(\"price is %d\\n\", pizzaWithCheeseAndTomato.getPrice()) // Output: // price is 45 } 外观模式Facade 问题 如果你需要初始化大量复杂的库或框架，就需要管理其依赖关系并且按正确的顺序执行。此时就可以用一个外观类来统一处理这些依赖关系，以对其进行整合。\n解决 外观模式和建造者模式很相似。两者的区别在于，外观模式是一种结构型模式，她的目的是将对象组合起来，而不是像建造者模式那样创建出不同的产品。\n请看以下代码：\npackage facade import \"fmt\" // 初始化APIA和APIB type APIA interface { TestA() string } func NewAPIA() APIA { return \u0026apiRunA{} } type apiRunA struct{} func (*apiRunA) TestA() string { return \"A api running\" } type APIB interface { TestB() string } func NewAPIB() APIB { return \u0026apiRunB{} } type apiRunB struct{} func (*apiRunB) TestB() string { return \"B api running\" } // 外观类 type API interface { Test() string } func NewAPI() API { return \u0026apiRun{ a: NewAPIA(), b: NewAPIB(), } } type apiRun struct { a APIA b APIB } func (a *apiRun) Test() string { aRet := a.a.TestA() bRet := a.b.TestB() return fmt.Sprintf(\"%s\\n%s\", aRet, bRet) } 假设要初始化APIA和APIB，我们就可以通过一个外观类API进行处理，在外观类接口Test方法中分别执行类TestA方法和TestB方法。\n测试代码：\npackage facade import \"testing\" var expect = \"A api running\\nB api running\" // TestFacadeAPI ... func TestFacadeAPI(t *testing.T) { api := NewAPI() ret := api.Test() if ret != expect { t.Fatalf(\"expect %s, return %s\", expect, ret) } } 享元模式 Flyweight 问题 在一些情况下，程序没有足够的内存容量支持存储大量对象，或者大量的对象存储着重复的状态，此时就会造成内存资源的浪费。\n享元模式提出了这样的解决方案：如果多个对象中相同的状态可以共用，就能在在有限的内存容量中载入更多对象。\n解决 如上所说，享元模式希望抽取出能在多个对象间共享的重复状态。\n我们可以使用map结构来实现这一设想，假设需要存储一些代表颜色的对象，使用享元模式可以这样做，请看以下代码：\npackage flyweight import \"fmt\" // 享元工厂 type ColorFlyweightFactory struct { maps map[string]*ColorFlyweight } var colorFactory *ColorFlyweightFactory func GetColorFlyweightFactory() *ColorFlyweightFactory { if colorFactory == nil { colorFactory = \u0026ColorFlyweightFactory{ maps: make(map[string]*ColorFlyweight), } } return colorFactory } func (f *ColorFlyweightFactory) Get(filename string) *ColorFlyweight { color := f.maps[filename] if color == nil { color = NewColorFlyweight(filename) f.maps[filename] = color } return color } type ColorFlyweight struct { data string } // 存储color对象 func NewColorFlyweight(filename string) *ColorFlyweight { // Load color file data := fmt.Sprintf(\"color data %s\", filename) return \u0026ColorFlyweight{ data: data, } } type ColorViewer struct { *ColorFlyweight } func NewColorViewer(name string) *ColorViewer { color := GetColorFlyweightFactory().Get(name) return \u0026ColorViewer{ ColorFlyweight: color, } } 我们定义了一个享元工厂，使用map存储相同对象（key）的状态（value）。这个享元工厂可以使我们更方便和安全的访问各种享元，保证其状态不被修改。\n我们定义了NewColorViewer方法，它会调用享元工厂的Get方法存储对象，而在享元工厂的实现中可以看到，相同状态的对象只会占用一次。\n测试代码：\npackage flyweight import \"testing\" func TestFlyweight(t *testing.T) { viewer1 := NewColorViewer(\"blue\") viewer2 := NewColorViewer(\"blue\") if viewer1.ColorFlyweight != viewer2.ColorFlyweight { t.Fail() } } 当程序需要存储大量对象且没有足够的内存容量时，可以考虑使用享元模式。\n代理模式Proxy 问题 如果你需要在访问一个对象时，有一个像“代理”一样的角色，她可以在访问对象之前为你进行缓存检查、权限判断等访问控制，在访问对象之后为你进行结果缓存、日志记录等结果处理，那么就可以考虑使用代理模式。\n回忆一下一些web框架的router模块，当客户端访问一个接口时，在最终执行对应的接口之前，router模块会执行一些事前操作，进行权限判断等操作，在执行之后还会记录日志，这就是典型的代理模式。\n解决 代理模式需要一个代理类，其包含执行真实对象所需的成员变量，并由代理类管理整个生命周期。\n请看以下代码：\npackage proxy import \"fmt\" type Subject interface { Proxy() string } // 代理 type Proxy struct { real RealSubject } func (p Proxy) Proxy() string { var res string // 在调用真实对象之前，检查缓存，判断权限，等等 p.real.Pre() // 调用真实对象 p.real.Real() // 调用之后的操作，如缓存结果，对结果进行处理，等等 p.real.After() return res } // 真实对象 type RealSubject struct{} func (RealSubject) Real() { fmt.Print(\"real\") } func (RealSubject) Pre() { fmt.Print(\"pre:\") } func (RealSubject) After() { fmt.Print(\":after\") } 我们定义了代理类Proxy，执行Proxy之后，在调用真实对象Real之前，我们会先调用事前对象Pre，并在执行真实对象Real之后，调用事后对象After。\n测试代码：\npackage proxy func ExampleProxy() { var sub Subject sub = \u0026Proxy{} sub.Proxy() // Output: // pre:real:after } 行为型模式 行为型模式处理对象和类之间的通信，并使其保持高效的沟通和委派。\n责任链模式Chain of Responsibility 问题 假设我们要让程序按照指定的步骤执行，并且这个步骤的顺序不是固定的，而是可以根据不同需求改变的，每个步骤都会对请求进行一些处理，并将结果传递给下一个步骤的处理者，就像一条流水线一样，我们该如何实现？\n当遇到这种必须按顺序执行多个处理者，并且处理者的顺序可以改变的需求，我们可以考虑使用责任链模式。\n解决 责任链模式使用了类似链表的结构。请看以下代码：\npackage chain import \"fmt\" type department interface { execute(*Do) setNext(department) } type aPart struct { next department } func (r *aPart) execute(p *Do) { if p.aPartDone { fmt.Println(\"aPart done\") r.next.execute(p) return } fmt.Println(\"aPart\") p.aPartDone = true r.next.execute(p) } func (r *aPart) setNext(next department) { r.next = next } type bPart struct { next department } func (d *bPart) execute(p *Do) { if p.bPartDone { fmt.Println(\"bPart done\") d.next.execute(p) return } fmt.Println(\"bPart\") p.bPartDone = true d.next.execute(p) } func (d *bPart) setNext(next department) { d.next = next } type endPart struct { next department } func (c *endPart) execute(p *Do) { if p.endPartDone { fmt.Println(\"endPart Done\") } fmt.Println(\"endPart\") } func (c *endPart) setNext(next department) { c.next = next } type Do struct { aPartDone bool bPartDone bool endPartDone bool } 我们实现了方法execute和setNext，并定义了aPart、bPart、endPart这3个处理者，每个处理者都可以通过execute方法执行其对应的业务代码，并可以通过setNext方法决定下一个处理者是谁。除了endPart是最终的处理者之外，在它之前的处理者aPart、bPart的顺序都可以任意调整。\n请看以下测试代码：\nfunc ExampleChain() { startPart := \u0026endPart{} aPart := \u0026aPart{} aPart.setNext(startPart) bPart := \u0026bPart{} bPart.setNext(aPart) do := \u0026Do{} bPart.execute(do) // Output: // bPart // aPart // endPart } 我们也可以调整处理者的执行顺序：\nfunc ExampleChain2() { startPart := \u0026endPart{} bPart := \u0026bPart{} bPart.setNext(startPart) aPart := \u0026aPart{} aPart.setNext(bPart) do := \u0026Do{} aPart.execute(do) // Output: // aPart // bPart // endPart } 命令模式Command 问题 假设你实现了开启和关闭电视机的功能，随着业务迭代，还需要实现开启和关闭冰箱的功能，开启和关闭电灯的功能，开启和关闭微波炉的功能……这些功能都基于你的基类，开启和关闭。如果你之后对基类进行修改，很可能会影响到其他功能，这使项目变得不稳定了。\n一个优秀的设计往往会关注于软件的分层与解耦，命令模式试图做到这样的结果：让命令和对应功能解耦，并能根据不同的请求将其方法参数化。\n解决 还是用开启和关闭家用电器的例子来举例吧。请看以下代码：\npackage command import \"fmt\" // 请求者 type button struct { command command } func (b *button) press() { b.command.execute() } // 具体命令接口 type command interface { execute() } type onCommand struct { device device } func (c *onCommand) execute() { c.device.on() } type offCommand struct { device device } func (c *offCommand) execute() { c.device.off() } // 接收者 type device interface { on() off() } type tv struct{} func (t *tv) on() { fmt.Println(\"Turning tv on\") } func (t *tv) off() { fmt.Println(\"Turning tv off\") } type airConditioner struct{} func (t *airConditioner) on() { fmt.Println(\"Turning air conditioner on\") } func (t *airConditioner) off() { fmt.Println(\"Turning air conditioner off\") } 我们分别实现了请求者button，命令接口command，接收者device。请求者button就像是那个可以执行开启或关闭的遥控器，命令接口command则是一个中间层，它使我们的请求者和接收者解藕。\n测试代码：\npackage command func ExampleCommand() { Tv() AirConditioner() // Output: // Turning tv on // Turning tv off // Turning air conditioner on // Turning air conditioner off } func Tv() { tv := \u0026tv{} onTvCommand := \u0026onCommand{ device: tv, } offTvCommand := \u0026offCommand{ device: tv, } onTvButton := \u0026button{ command: onTvCommand, } onTvButton.press() offTvButton := \u0026button{ command: offTvCommand, } offTvButton.press() } func AirConditioner() { airConditioner := \u0026airConditioner{} onAirConditionerCommand := \u0026onCommand{ device: airConditioner, } offAirConditionerCommand := \u0026offCommand{ device: airConditioner, } onAirConditionerButton := \u0026button{ command: onAirConditionerCommand, } onAirConditionerButton.press() offAirConditionerButton := \u0026button{ command: offAirConditionerCommand, } offAirConditionerButton.press() } 迭代器模式Iterator 问题 迭代器模式用于遍历集合中的元素，无论集合的数据结构是怎样的。\n解决 请看以下代码：\npackage iterator // 集合接口 type collection interface { createIterator() iterator } // 具体的集合 type part struct { title string number int } type partCollection struct { part parts []*part } func (u *partCollection) createIterator() iterator { return \u0026partIterator{ parts: u.parts, } } // 迭代器 type iterator interface { hasNext() bool getNext() *part } // 具体的迭代器 type partIterator struct { index int parts []*part } func (u *partIterator) hasNext() bool { if u.index \u003c len(u.parts) { return true } return false } func (u *partIterator) getNext() *part { if u.hasNext() { part := u.parts[u.index] u.index++ return part } return nil } 测试代码：\nfunc ExampleIterator() { part1 := \u0026part{ title: \"part1\", number: 10, } part2 := \u0026part{ title: \"part2\", number: 20, } part3 := \u0026part{ title: \"part3\", number: 30, } partCollection := \u0026partCollection{ parts: []*part{part1, part2, part3}, } iterator := partCollection.createIterator() for iterator.hasNext() { part := iterator.getNext() fmt.Println(part) } // Output: // \u0026{part1 10} // \u0026{part2 20} // \u0026{part3 30} } 中介者模式Mediator 问题 中介者模式试图解决网状关系的复杂关联，降低对象间的耦合度。\n举个例子，假设一个十字路口上的车都是对象，它们会执行不同的操作，前往不同的目的地，那么在十字路口指挥的交警就是“中介者”。\n各个对象通过执行中介者接口，再由中介者维护对象之间的联系。这能使对象变得更独立，比较适合用在一些对象是网状关系的案例上。\n解决 假设有p1，p2，p3这3个发送者，p1 发送的消息p2能收到，p2 发送的消息p1能收到，p3 发送的消息则p1和p2能收到，如何实现呢？像这种情况就很适合用中介者模式实现。\n请看以下代码：\npackage mediator import ( \"fmt\" ) type p1 struct{} func (p *p1) getMessage(data string) { fmt.Println(\"p1 get message: \" + data) } type p2 struct{} func (p *p2) getMessage(data string) { fmt.Println(\"p2 get message: \" + data) } type p3 struct{} func (p *p3) getMessage(data string) { fmt.Println(\"p3 get message: \" + data) } type Message struct { p1 *p1 p2 *p2 p3 *p3 } func (m *Message) sendMessage(i interface{}, data string) { switch i.(type) { case *p1: m.p2.getMessage(data) case *p2: m.p1.getMessage(data) case *p3: m.p1.getMessage(data) m.p2.getMessage(data) } } 我们定义了p1，p2，p3这3个对象，然后实现了中介者sendMessage。\n测试代码：\npackage mediator func ExampleMediator() { message := \u0026Message{} p1 := \u0026p1{} p2 := \u0026p2{} p3 := \u0026p3{} message.sendMessage(p1, \"hi! my name is p1\") message.sendMessage(p2, \"hi! my name is p2\") message.sendMessage(p3, \"hi! my name is p3\") // Output: // p2 get message: hi! my name is p1 // p1 get message: hi! my name is p2 // p1 get message: hi! my name is p3 // p2 get message: hi! my name is p3 } 备忘录模式Memento 问题 常用的文字编辑器都支持保存和恢复一段文字的操作，如果我们想要在程序中实现保存和恢复的功能该怎么做呢？\n我们需要提供保存和恢复的功能，当保存功能被调用时，就会生成当前对象的快照，在恢复功能被调用时，就会用之前保存的快照覆盖当前的快照。这可以使用备忘录模式来做。\n解决 请看以下代码：\npackage memento import \"fmt\" type Memento interface{} type Text struct { content string } type textMemento struct { content string } func (t *Text) Write(content string) { t.content = content } func (t *Text) Save() Memento { return \u0026textMemento{ content: t.content, } } func (t *Text) Load(m Memento) { tm := m.(*textMemento) t.content = tm.content } func (t *Text) Show() { fmt.Println(\"content:\", t.content) } 我们定义了textMemento结构体用于保存当前快照，并在Load方法中将快照覆盖到当前内容。\n测试代码：\npackage memento func ExampleText() { text := \u0026Text{ content: \"how are you\", } text.Show() progress := text.Save() text.Write(\"fine think you and you\") text.Show() text.Load(progress) text.Show() // Output: // content: how are you // content: fine think you and you // content: how are you } 观察者模式Observer 问题 如果你需要在一个对象的状态被改变时，其他对象能作为其“观察者”而被通知，就可以使用观察者模式。\n我们将自身的状态改变就会通知给其他对象的对象称为“发布者”，关注发布者状态变化的对象则称为“订阅者”。\n解决 请看以下代码：\npackage observer import \"fmt\" // 发布者 type Subject struct { observers []Observer content string } func NewSubject() *Subject { return \u0026Subject{ observers: make([]Observer, 0), } } // 添加订阅者 func (s *Subject) AddObserver(o Observer) { s.observers = append(s.observers, o) } // 改变发布者的状态 func (s *Subject) UpdateContext(content string) { s.content = content s.notify() } // 通知订阅者接口 type Observer interface { Do(*Subject) } func (s *Subject) notify() { for _, o := range s.observers { o.Do(s) } } // 订阅者 type Reader struct { name string } func NewReader(name string) *Reader { return \u0026Reader{ name: name, } } func (r *Reader) Do(s *Subject) { fmt.Println(r.name + \" get \" + s.content) } 很简单，我们只要实现一个通知notify方法，在发布者的状态改变时执行即可。\n测试代码：\npackage observer func ExampleObserver() { subject := NewSubject() boy := NewReader(\"小明\") girl := NewReader(\"小美\") subject.AddObserver(boy) subject.AddObserver(girl) subject.UpdateContext(\"hi~\") // Output: // 小明 get hi~ // 小美 get hi~ } 状态模式 State 问题 如果一个对象的实现方法会根据自身的状态而改变，就可以使用状态模式。\n举个例子：假设有一个开门的方法，门的状态在一开始是“关闭”，你可以执行open方法和close方法，当你执行了open方法，门的状态就变成了“开启”，再执行open方法就不会执行开门的功能，而是返回“门已开启”，如果执行close方法，门的状态就变成了“关闭”，再执行close方法就不会执行关门的功能，而是返回“门已关闭”。这是一个简单的例子，我们将为每个状态提供不同的实现方法，将这些方法组织起来很麻烦，如果状态也越来越多呢？无疑，这将会使代码变得臃肿。\n解决 如果我们需要为一个门对象提供3种状态下的open和close方法：\n“开启”状态下，open方法返回“门已开启”，close方法返回“关闭成功”。 “关闭”状态下，open方法返回“开启成功”，close方法返回“门已关闭”。 “损坏”状态下，open方法返回“门已损坏，无法开启”，close方法返回“门已损坏，无法关闭”。 请看以下代码：\npackage state import \"fmt\" // 不同状态需要实现的接口 type state interface { open(*door) close(*door) } // 门对象 type door struct { opened state closed state damaged state currentState state // 当前状态 } func (d *door) open() { d.currentState.open(d) } func (d *door) close() { d.currentState.close(d) } func (d *door) setState(s state) { d.currentState = s } // 开启状态 type opened struct{} func (o *opened) open(d *door) { fmt.Println(\"门已开启\") } func (o *opened) close(d *door) { fmt.Println(\"关闭成功\") } // 关闭状态 type closed struct{} func (c *closed) open(d *door) { fmt.Println(\"开启成功\") } func (c *closed) close(d *door) { fmt.Println(\"门已关闭\") } // 损坏状态 type damaged struct{} func (a *damaged) open(d *door) { fmt.Println(\"门已损坏，无法开启\") } func (a *damaged) close(d *door) { fmt.Println(\"门已损坏，无法关闭\") } 我们的门对象door实现了open和close方法，在方法中，只需要调用当前状态currentState的open和close方法即可。\n测试代码：\npackage state func ExampleState() { door := \u0026door{} // 开启状态 opened := \u0026opened{} door.setState(opened) door.open() door.close() // 关闭状态 closed := \u0026closed{} door.setState(closed) door.open() door.close() // 损坏状态 damaged := \u0026damaged{} door.setState(damaged) door.open() door.close() // Output: // 门已开启 // 关闭成功 // 开启成功 // 门已关闭 // 门已损坏，无法开启 // 门已损坏，无法关闭 } 策略模式Strategy 问题 假设需要实现一组出行的功能，出现的方案可以选择步行、骑行、开车，最简单的做法就是分别实现这3种方法供客户端调用。但这样做就使对象与其代码实现变得耦合了，客户端需要决定出行方式，然后决定调用步行出行、骑行出行、开车出行等方法，这不符合开闭原则。\n而策略模式的区别在于，它会将这些出行方案抽取到一组被称为策略的类中，客户端还是调用同一个出行对象，不需要关注实现细节，只需要在参数中指定所需的策略即可。\n解决 请看以下代码：\npackage strategy import \"fmt\" type Travel struct { name string strategy Strategy } func NewTravel(name string, strategy Strategy) *Travel { return \u0026Travel{ name: name, strategy: strategy, } } func (p *Travel) traffic() { p.strategy.traffic(p) } type Strategy interface { traffic(*Travel) } type Walk struct{} func (w *Walk) traffic(t *Travel) { fmt.Println(t.name + \" walk\") } type Ride struct{} func (w *Ride) traffic(t *Travel) { fmt.Println(t.name + \" ride\") } type Drive struct{} func (w *Drive) traffic(t *Travel) { fmt.Println(t.name + \" drive\") } 我们定义了strategy一组策略接口，为其实现了Walk、Ride、Drive算法。客户端只需要执行traffic方法即可，无需关注实现细节。\n测试代码：\npackage strategy func ExampleTravel() { walk := \u0026Walk{} Travel1 := NewTravel(\"小明\", walk) Travel1.traffic() ride := \u0026Ride{} Travel2 := NewTravel(\"小美\", ride) Travel2.traffic() drive := \u0026Drive{} Travel3 := NewTravel(\"小刚\", drive) Travel3.traffic() // Output: // 小明 walk // 小美 ride // 小刚 drive } 模板方法模式Template Method 问题 模板方法模式就是将算法分解为一系列步骤，然后在一个模版方法中依次调用这些步骤。这样客户端就不需要了解各个步骤的实现细节，只需要调用模版即可。\n解决 一个非常简单的例子，请看以下代码：\npackage templatemethod import \"fmt\" type PrintTemplate interface { Print(name string) } type template struct { isTemplate PrintTemplate name string } func (t *template) Print() { t.isTemplate.Print(t.name) } type A struct{} func (a *A) Print(name string) { fmt.Println(\"a: \" + name) // 业务代码…… } type B struct{} func (b *B) Print(name string) { fmt.Println(\"b: \" + name) // 业务代码…… } 测试代码：\npackage templatemethod func ExamplePrintTemplate() { templateA := \u0026A{} template := \u0026template{ isTemplate: templateA, name: \"hi~\", } template.Print() templateB := \u0026B{} template.isTemplate = templateB template.Print() // Output: // a: hi~ // b: hi~ } 访问者模式Visitor 问题 访问者模式试图解决这样一个问题：在不改变类的对象结构的前提下增加新的操作。\n解决 请看以下代码：\npackage visitor import \"fmt\" type Shape interface { accept(visitor) } type square struct{} func (s *square) accept(v visitor) { v.visitForSquare(s) } type circle struct{} func (c *circle) accept(v visitor) { v.visitForCircle(c) } type visitor interface { visitForSquare(*square) visitForCircle(*circle) } type sideCalculator struct{} func (a *sideCalculator) visitForSquare(s *square) { fmt.Println(\"square side\") } func (a *sideCalculator) visitForCircle(s *circle) { fmt.Println(\"circle side\") } type radiusCalculator struct{} func (a *radiusCalculator) visitForSquare(s *square) { fmt.Println(\"square radius\") } func (a *radiusCalculator) visitForCircle(c *circle) { fmt.Println(\"circle radius\") } 测试代码：\npackage visitor func ExampleShape() { square := \u0026square{} circle := \u0026circle{} side := \u0026sideCalculator{} square.accept(side) circle.accept(side) radius := \u0026radiusCalculator{} square.accept(radius) circle.accept(radius) // Output: // square side // circle side // square radius // circle radius } 设计模式的“道” 上面那么多种设计模式你能记住几种呢？设计模式分为“术”的部分和“道”的部分，上面那些设计模式就是“术”的部分，他们是一些围绕着设计模式核心思路的经典解决方案。换句话说，重要的是理解为什么要用那些设计模式，具体问题，具体分析，而不是把某种设计模式生搬硬套进代码。\n设计模式有6大原则，以上的设计模式目的就是为了使软件系统能达到这些原则：\n开闭原则 软件应该对扩展开放，对修改关闭。\n对系统进行扩展，而无需修改现有的代码。这可以降低软件的维护成本，同时也增加可扩展性。\n里氏替换原则 任何基类可以出现的地方，子类一定可以出现。\n里氏替换原则是对开闭原则的补充，实现开闭原则的关键步骤就是抽象化，基类与子类的关系就是要尽可能的抽象化。\n依赖倒置原则 面向接口编程，抽象不应该依赖于具体类，具体类应当依赖于抽象。\n这是为了减少类间的耦合，使系统更适宜于扩展，也更便于维护。\n单一职责原则 一个类应该只有一个发生变化的原因。\n一个类承载的越多，耦合度就越高。如果类的职责单一，就可以降低出错的风险，也可以提高代码的可读性。\n最少知道原则 一个实体应当尽量少地与其他实体之间发生相互作用。\n还是为了降低耦合，一个类与其他类的关联越少，越易于扩展。\n接口分离原则 使用多个专门的接口，而不使用高耦合的单一接口。\n避免同一个接口占用过多的职责，更明确的划分，可以降低耦合。高耦合会导致程序不易扩展，提高出错的风险。\n",
  "wordCount" : "11494",
  "inLanguage": "zh",
  "datePublished": "2023-10-10T00:00:00Z",
  "dateModified": "2023-10-10T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "liiqii"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://liiqii.github.io/posts/tech/go/go_design_mode/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "liiqii",
    "logo": {
      "@type": "ImageObject",
      "url": "https://liiqii.github.io/img/icon.jpg"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    (function () {
        let  arr,reg = new RegExp("(^| )"+"change-themes"+"=([^;]*)(;|$)");
        if(arr = document.cookie.match(reg)) {
        } else {
            if (new Date().getHours() >= 19 || new Date().getHours() < 6) {
                document.body.classList.add('dark');
                localStorage.setItem("pref-theme", 'dark');
            } else {
                document.body.classList.remove('dark');
                localStorage.setItem("pref-theme", 'light');
            }
        }
    })()

    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://liiqii.github.io/" accesskey="h" title="Home (Alt + H)">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://liiqii.github.io/search" title="🔍 搜索 (Alt &#43; /)" accesskey=/>
                <span>🔍 搜索</span>
                </a>
            </li>
            <li>
                <a href="https://liiqii.github.io/posts" title="📚 文章">
                <span>📚 文章</span>
                </a>
            </li>
            <li>
                <a href="https://liiqii.github.io/tags" title="🧩 标签">
                <span>🧩 标签</span>
                </a>
            </li>
            <li>
                <a href="https://liiqii.github.io/archives/" title="⏱️ 时间轴">
                <span>⏱️ 时间轴</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main page">
<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }
</style>

<article class="post-single">
    <div id="single-content">
        <header class="post-header">
            <div class="breadcrumbs"><a href="https://liiqii.github.io/">🏠 主页</a>&nbsp;»&nbsp;<a href="https://liiqii.github.io/posts/">📚文章</a>&nbsp;»&nbsp;<a href="https://liiqii.github.io/posts/tech/">👨🏻‍💻 技术</a></div>
            <h1 class="post-title">
                Go 23种设计模式
            </h1>
            <div class="post-description">
                Go 23种设计模式
            </div>
            <div class="post-meta">

<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }

    .parent-post-meta {
        display: flex;
        flex-wrap: wrap;
        opacity: 0.8;
    }
</style>

<span class="parent-post-meta">
    <span id="post_meta_style_1">
        <span class="fa fa-calendar-check-o"></span>
        <span>2023-10-10
            &nbsp;&nbsp;
        </span>
    </span>
    
    
    
    
    
    
    
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>11494字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>23分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>liiqii
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
                <a href="https://liiqii.github.io/tags/go/" style="color: var(--secondary)!important;">Go</a>
                &nbsp;<a href="https://liiqii.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="color: var(--secondary)!important;">设计模式</a>
            </span>
        </span>
    </span>
</span>
<span style="opacity: 0.8;">
                    <span id="post_meta_style_7">
                        &nbsp;&nbsp;
                        <span class="fa fa-eye" ></span>
                        <span>
                            <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span></span>
                            &nbsp;&nbsp;
                        </span>
                    </span>
                    <span id="post_meta_style_8">
                        <span class="fa fa-commenting-o"></span>
                        <span>
                            <script src="https://cdn.staticfile.org/twikoo/1.5.8/twikoo.all.min.js"></script>
                            <script>
                                let url = document.documentURI
                                
                                let dnsUrl = "https://liiqii.github.io/"
                                let urlSplit = url.split(dnsUrl)
                                let finalUrl = urlSplit[1]
                                if (finalUrl[0] !== '/') {
                                    finalUrl = '/'+finalUrl
                                }
                                twikoo.getCommentsCount({
                                    envId:  null , 
                                region:  null , 
                                urls: [ 
                                    
                                    finalUrl,
                                ],
                                    includeReply: false 
                                }).then(function (res) {
                                    let count = res[0].count
                                    const obj = document.getElementById("comment_count");
                                    obj.innerText = count
                                    
                                    
                                    
                                }).catch(function (err) {
                                    
                                    console.error(err);
                                });
                            </script>
                            <span id="comment_count"></span>
                        </span>
                    </span>
                </span>

</div>
        </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%88%9b%e5%bb%ba%e5%9e%8b%e6%a8%a1%e5%bc%8f" aria-label="创建型模式"><strong>创建型模式</strong></a><ul>
                        
                <li>
                    <a href="#%e5%b7%a5%e5%8e%82%e6%96%b9%e6%b3%95%e6%a8%a1%e5%bc%8f-factory-method" aria-label="工厂方法模式 Factory Method">工厂方法模式 Factory Method</a><ul>
                        
                <li>
                    <a href="#%e9%97%ae%e9%a2%98" aria-label="问题">问题</a></li>
                <li>
                    <a href="#%e8%a7%a3%e5%86%b3" aria-label="解决">解决</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%8a%bd%e8%b1%a1%e5%b7%a5%e5%8e%82%e6%a8%a1%e5%bc%8f-abstract-factory" aria-label="抽象工厂模式 Abstract Factory">抽象工厂模式 Abstract Factory</a><ul>
                        
                <li>
                    <a href="#%e9%97%ae%e9%a2%98-1" aria-label="问题">问题</a></li>
                <li>
                    <a href="#%e8%a7%a3%e5%86%b3-1" aria-label="解决">解决</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%bb%ba%e9%80%a0%e8%80%85%e6%a8%a1%e5%bc%8f-builder" aria-label="建造者模式 Builder">建造者模式 Builder</a><ul>
                        
                <li>
                    <a href="#%e9%97%ae%e9%a2%98-2" aria-label="问题">问题</a></li>
                <li>
                    <a href="#%e8%a7%a3%e5%86%b3-2" aria-label="解决">解决</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%8e%9f%e5%9e%8b%e6%a8%a1%e5%bc%8f-prototype" aria-label="原型模式 Prototype">原型模式 Prototype</a><ul>
                        
                <li>
                    <a href="#%e9%97%ae%e9%a2%98-3" aria-label="问题">问题</a></li>
                <li>
                    <a href="#%e8%a7%a3%e5%86%b3-3" aria-label="解决">解决</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f-singleton" aria-label="单例模式 Singleton">单例模式 Singleton</a><ul>
                        
                <li>
                    <a href="#%e9%97%ae%e9%a2%98-4" aria-label="问题">问题</a></li>
                <li>
                    <a href="#%e8%a7%a3%e5%86%b3-4" aria-label="解决">解决</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e7%bb%93%e6%9e%84%e5%9e%8b%e6%a8%a1%e5%bc%8f" aria-label="结构型模式">结构型模式</a><ul>
                        
                <li>
                    <a href="#%e9%80%82%e9%85%8d%e5%99%a8%e6%a8%a1%e5%bc%8f-adapter" aria-label="适配器模式 Adapter">适配器模式 Adapter</a><ul>
                        
                <li>
                    <a href="#%e9%97%ae%e9%a2%98-5" aria-label="问题">问题</a></li>
                <li>
                    <a href="#%e8%a7%a3%e5%86%b3-5" aria-label="解决">解决</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%a1%a5%e6%8e%a5%e6%a8%a1%e5%bc%8fbridge" aria-label="桥接模式Bridge">桥接模式Bridge</a><ul>
                        
                <li>
                    <a href="#%e9%97%ae%e9%a2%98-6" aria-label="问题">问题</a></li>
                <li>
                    <a href="#%e8%a7%a3%e5%86%b3-6" aria-label="解决">解决</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%af%b9%e8%b1%a1%e6%a0%91%e6%a8%a1%e5%bc%8fobject-tree" aria-label="对象树模式Object Tree">对象树模式Object Tree</a><ul>
                        
                <li>
                    <a href="#%e9%97%ae%e9%a2%98-7" aria-label="问题">问题</a></li>
                <li>
                    <a href="#%e8%a7%a3%e5%86%b3-7" aria-label="解决">解决</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%a3%85%e9%a5%b0%e6%a8%a1%e5%bc%8fdecorator" aria-label="装饰模式Decorator">装饰模式Decorator</a><ul>
                        
                <li>
                    <a href="#%e9%97%ae%e9%a2%98-8" aria-label="问题">问题</a></li>
                <li>
                    <a href="#%e8%a7%a3%e5%86%b3-8" aria-label="解决">解决</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%a4%96%e8%a7%82%e6%a8%a1%e5%bc%8ffacade" aria-label="外观模式Facade">外观模式Facade</a><ul>
                        
                <li>
                    <a href="#%e9%97%ae%e9%a2%98-9" aria-label="问题">问题</a></li>
                <li>
                    <a href="#%e8%a7%a3%e5%86%b3-9" aria-label="解决">解决</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%ba%ab%e5%85%83%e6%a8%a1%e5%bc%8f-flyweight" aria-label="享元模式 Flyweight">享元模式 Flyweight</a><ul>
                        
                <li>
                    <a href="#%e9%97%ae%e9%a2%98-10" aria-label="问题">问题</a></li>
                <li>
                    <a href="#%e8%a7%a3%e5%86%b3-10" aria-label="解决">解决</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%bb%a3%e7%90%86%e6%a8%a1%e5%bc%8fproxy" aria-label="代理模式Proxy">代理模式Proxy</a><ul>
                        
                <li>
                    <a href="#%e9%97%ae%e9%a2%98-11" aria-label="问题">问题</a></li>
                <li>
                    <a href="#%e8%a7%a3%e5%86%b3-11" aria-label="解决">解决</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e8%a1%8c%e4%b8%ba%e5%9e%8b%e6%a8%a1%e5%bc%8f" aria-label="行为型模式">行为型模式</a><ul>
                        
                <li>
                    <a href="#%e8%b4%a3%e4%bb%bb%e9%93%be%e6%a8%a1%e5%bc%8fchain-of-responsibility" aria-label="责任链模式Chain of Responsibility">责任链模式Chain of Responsibility</a><ul>
                        
                <li>
                    <a href="#%e9%97%ae%e9%a2%98-12" aria-label="问题">问题</a></li>
                <li>
                    <a href="#%e8%a7%a3%e5%86%b3-12" aria-label="解决">解决</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%91%bd%e4%bb%a4%e6%a8%a1%e5%bc%8fcommand" aria-label="命令模式Command">命令模式Command</a><ul>
                        
                <li>
                    <a href="#%e9%97%ae%e9%a2%98-13" aria-label="问题">问题</a></li>
                <li>
                    <a href="#%e8%a7%a3%e5%86%b3-13" aria-label="解决">解决</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%bf%ad%e4%bb%a3%e5%99%a8%e6%a8%a1%e5%bc%8fiterator" aria-label="迭代器模式Iterator">迭代器模式Iterator</a><ul>
                        
                <li>
                    <a href="#%e9%97%ae%e9%a2%98-14" aria-label="问题">问题</a></li>
                <li>
                    <a href="#%e8%a7%a3%e5%86%b3-14" aria-label="解决">解决</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%b8%ad%e4%bb%8b%e8%80%85%e6%a8%a1%e5%bc%8fmediator" aria-label="中介者模式Mediator">中介者模式Mediator</a><ul>
                        
                <li>
                    <a href="#%e9%97%ae%e9%a2%98-15" aria-label="问题">问题</a></li>
                <li>
                    <a href="#%e8%a7%a3%e5%86%b3-15" aria-label="解决">解决</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%a4%87%e5%bf%98%e5%bd%95%e6%a8%a1%e5%bc%8fmemento" aria-label="备忘录模式Memento">备忘录模式Memento</a><ul>
                        
                <li>
                    <a href="#%e9%97%ae%e9%a2%98-16" aria-label="问题">问题</a></li>
                <li>
                    <a href="#%e8%a7%a3%e5%86%b3-16" aria-label="解决">解决</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%a7%82%e5%af%9f%e8%80%85%e6%a8%a1%e5%bc%8fobserver" aria-label="观察者模式Observer">观察者模式Observer</a><ul>
                        
                <li>
                    <a href="#%e9%97%ae%e9%a2%98-17" aria-label="问题">问题</a></li>
                <li>
                    <a href="#%e8%a7%a3%e5%86%b3-17" aria-label="解决">解决</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%8a%b6%e6%80%81%e6%a8%a1%e5%bc%8f-state" aria-label="状态模式 State">状态模式 State</a><ul>
                        
                <li>
                    <a href="#%e9%97%ae%e9%a2%98-18" aria-label="问题">问题</a></li>
                <li>
                    <a href="#%e8%a7%a3%e5%86%b3-18" aria-label="解决">解决</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ad%96%e7%95%a5%e6%a8%a1%e5%bc%8fstrategy" aria-label="策略模式Strategy">策略模式Strategy</a><ul>
                        
                <li>
                    <a href="#%e9%97%ae%e9%a2%98-19" aria-label="问题">问题</a></li>
                <li>
                    <a href="#%e8%a7%a3%e5%86%b3-19" aria-label="解决">解决</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%a8%a1%e6%9d%bf%e6%96%b9%e6%b3%95%e6%a8%a1%e5%bc%8ftemplate-method" aria-label="模板方法模式Template Method">模板方法模式Template Method</a><ul>
                        
                <li>
                    <a href="#%e9%97%ae%e9%a2%98-20" aria-label="问题">问题</a></li>
                <li>
                    <a href="#%e8%a7%a3%e5%86%b3-20" aria-label="解决">解决</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%ae%bf%e9%97%ae%e8%80%85%e6%a8%a1%e5%bc%8fvisitor" aria-label="访问者模式Visitor">访问者模式Visitor</a><ul>
                        
                <li>
                    <a href="#%e9%97%ae%e9%a2%98-21" aria-label="问题">问题</a></li>
                <li>
                    <a href="#%e8%a7%a3%e5%86%b3-21" aria-label="解决">解决</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e7%9a%84%e9%81%93" aria-label="设计模式的“道”">设计模式的“道”</a><ul>
                        
                <li>
                    <a href="#%e5%bc%80%e9%97%ad%e5%8e%9f%e5%88%99" aria-label="开闭原则">开闭原则</a></li>
                <li>
                    <a href="#%e9%87%8c%e6%b0%8f%e6%9b%bf%e6%8d%a2%e5%8e%9f%e5%88%99" aria-label="里氏替换原则">里氏替换原则</a></li>
                <li>
                    <a href="#%e4%be%9d%e8%b5%96%e5%80%92%e7%bd%ae%e5%8e%9f%e5%88%99" aria-label="依赖倒置原则">依赖倒置原则</a></li>
                <li>
                    <a href="#%e5%8d%95%e4%b8%80%e8%81%8c%e8%b4%a3%e5%8e%9f%e5%88%99" aria-label="单一职责原则">单一职责原则</a></li>
                <li>
                    <a href="#%e6%9c%80%e5%b0%91%e7%9f%a5%e9%81%93%e5%8e%9f%e5%88%99" aria-label="最少知道原则">最少知道原则</a></li>
                <li>
                    <a href="#%e6%8e%a5%e5%8f%a3%e5%88%86%e7%a6%bb%e5%8e%9f%e5%88%99" aria-label="接口分离原则">接口分离原则</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        if (elements) {
            activeElement = Array.from(elements).find((element) => {
                if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                    (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                    return element;
                }
            }) || activeElement

            elements.forEach(element => {
                const id = encodeURI(element.getAttribute('id')).toLowerCase();
                if (element === activeElement){
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
                } else {
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
                }
            })
        }
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;
        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
        <div class="post-content"><h1 id="创建型模式"><strong>创建型模式</strong><a hidden class="anchor" aria-hidden="true" href="#创建型模式">#</a></h1>
<p>创建型模式是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象，增加已有代码的灵活性和可复用性。</p>
<h2 id="工厂方法模式-factory-method">工厂方法模式 Factory Method<a hidden class="anchor" aria-hidden="true" href="#工厂方法模式-factory-method">#</a></h2>
<h3 id="问题">问题<a hidden class="anchor" aria-hidden="true" href="#问题">#</a></h3>
<p>假设我们的业务需要一个支付渠道，我们开发了一个Pay方法，其可以用于支付。请看以下示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Pay</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Pay</span>() <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PayReq</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">OrderId</span> <span style="color:#66d9ef">string</span> <span style="color:#75715e">// 订单号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">PayReq</span>) <span style="color:#a6e22e">Pay</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// todo
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">OrderId</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;支付成功&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如上，我们定义了接口Pay，并实现了其方法Pay()。</p>
<p>如果业务需求变更，需要我们提供多种支付方式，一种叫APay，一种叫BPay，这二种支付方式所需的参数不同，APay只需要订单号OrderId，BPay则需要订单号OrderId和Uid。此时如何修改？</p>
<p>很容易想到的是在原有的代码基础上修改，比如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Pay</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">APay</span>() <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">BPay</span>() <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PayReq</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">OrderId</span> <span style="color:#66d9ef">string</span> <span style="color:#75715e">// 订单号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">Uid</span> <span style="color:#66d9ef">int64</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">PayReq</span>) <span style="color:#a6e22e">APay</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// todo
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">OrderId</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;APay支付成功&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">PayReq</span>) <span style="color:#a6e22e">BPay</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// todo
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">OrderId</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Uid</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;BPay支付成功&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们为Pay接口实现了APay() 和BPay() 方法。虽然暂时实现了业务需求，但却使得结构体PayReq<strong>变得冗余</strong>了，APay() 并不需要Uid参数。如果之后再增加CPay、DPay、EPay，可想而知，<strong>代码会变得越来越难以维护</strong>。</p>
<p><strong>随着后续业务迭代，将不得不编写出复杂的代码。</strong></p>
<h3 id="解决">解决<a hidden class="anchor" aria-hidden="true" href="#解决">#</a></h3>
<p>让我们想象一个工厂类，这个工厂类需要生产电线和开关等器具，我们可以为工厂类提供一个生产方法，当电线机器调用生产方法时，就产出电线，当开关机器调用生产方法时，就产出开关。</p>
<p>套用到我们的支付业务来，就是我们不再为接口提供APay方法、BPay方法，而只提供一个Pay方法，并将A支付方式和B支付方式的区别下放到子类。</p>
<p>请看示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">factorymethod</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Pay</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Pay</span>(<span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PayReq</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">OrderId</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">APayReq</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">PayReq</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">APayReq</span>) <span style="color:#a6e22e">Pay</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// todo
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">OrderId</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;APay支付成功&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">BPayReq</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">PayReq</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Uid</span> <span style="color:#66d9ef">int64</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">BPayReq</span>) <span style="color:#a6e22e">Pay</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// todo
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">OrderId</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Uid</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;BPay支付成功&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们用APay和BPay两个结构体重写了Pay() 方法，如果需要添加一种新的支付方式， 只需要重写新的Pay() 方法即可。</p>
<p>工厂方法的优点就在于避免了创建者和具体产品之间的紧密耦合，从而使得代码更容易维护。</p>
<p>测试代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-perl" data-lang="perl"><span style="display:flex;"><span><span style="color:#66d9ef">package</span> factorymethod
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>import (
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;testing&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>func TestPay(t <span style="color:#f92672">*</span>testing<span style="color:#f92672">.</span>T) {
</span></span><span style="display:flex;"><span>  aPay :<span style="color:#f92672">=</span> APayReq{}
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> aPay<span style="color:#f92672">.</span>Pay() <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;APay支付成功&#34;</span> {
</span></span><span style="display:flex;"><span>    t<span style="color:#f92672">.</span>Fatal(<span style="color:#e6db74">&#34;aPay error&#34;</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  bPay :<span style="color:#f92672">=</span> BPayReq{}
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> bPay<span style="color:#f92672">.</span>Pay() <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;BPay支付成功&#34;</span> {
</span></span><span style="display:flex;"><span>    t<span style="color:#f92672">.</span>Fatal(<span style="color:#e6db74">&#34;bPay error&#34;</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="抽象工厂模式-abstract-factory">抽象工厂模式 Abstract Factory<a hidden class="anchor" aria-hidden="true" href="#抽象工厂模式-abstract-factory">#</a></h2>
<h3 id="问题-1">问题<a hidden class="anchor" aria-hidden="true" href="#问题-1">#</a></h3>
<p>抽象工厂模式基于工厂方法模式。两者的区别在于：工厂方法模式是创建出一种产品，而抽象工厂模式是创建出一类产品。这二种都属于工厂模式，在设计上是相似的。</p>
<p>假设，有一个存储工厂，提供redis和mysql两种存储数据的方式。如果使用工厂方法模式，我们就需要一个存储工厂，并提供SaveRedis方法和SaveMysql方法。</p>
<p>如果此时业务还需要分成存储散文和古诗两种载体，这两种载体都可以进行redis和mysql存储。就可以使用抽象工厂模式，我们需要一个存储工厂作为父工厂，散文工厂和古诗工厂作为子工厂，并提供SaveRedis方法和SaveMysql方法。</p>
<h3 id="解决-1">解决<a hidden class="anchor" aria-hidden="true" href="#解决-1">#</a></h3>
<p>以上文的存储工厂业务为例，用抽象工厂模式的思路来设计代码，就像下面这样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">abstractfactory</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// SaveArticle 抽象模式工厂接口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SaveArticle</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">CreateProse</span>() <span style="color:#a6e22e">Prose</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">CreateAncientPoetry</span>() <span style="color:#a6e22e">AncientPoetry</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SaveRedis</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">SaveRedis</span>) <span style="color:#a6e22e">CreateProse</span>() <span style="color:#a6e22e">Prose</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">RedisProse</span>{}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">SaveRedis</span>) <span style="color:#a6e22e">CreateAncientPoetry</span>() <span style="color:#a6e22e">AncientPoetry</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">RedisProse</span>{}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SaveMysql</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">SaveMysql</span>) <span style="color:#a6e22e">CreateProse</span>() <span style="color:#a6e22e">Prose</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">MysqlProse</span>{}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">SaveMysql</span>) <span style="color:#a6e22e">CreateAncientPoetry</span>() <span style="color:#a6e22e">AncientPoetry</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">MysqlProse</span>{}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Prose 散文
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Prose</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">SaveProse</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// AncientPoetry 古诗
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">AncientPoetry</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">SaveAncientPoetry</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">RedisProse</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">RedisProse</span>) <span style="color:#a6e22e">SaveProse</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Redis Save Prose&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">RedisProse</span>) <span style="color:#a6e22e">SaveAncientPoetry</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Redis Save Ancient Poetry&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MysqlProse</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">MysqlProse</span>) <span style="color:#a6e22e">SaveProse</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Mysql Save Prose&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">MysqlProse</span>) <span style="color:#a6e22e">SaveAncientPoetry</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Mysql Save Ancient Poetry&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们定义了存储工厂，也就是SaveArticle接口，并实现了CreateProse方法和CreateAncientPoetry方法，这2个方法分别用于创建散文工厂和古诗工厂。</p>
<p>然后我们又分别为散文工厂和古诗工厂实现了SaveProse方法和SaveAncientPoetry方法，并用Redis结构体和Mysql结构体分别重写了2种存储方法。</p>
<p>测试代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scss" data-lang="scss"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#f92672">abstractfactory</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">func</span> <span style="color:#f92672">Save</span><span style="color:#f92672">(</span><span style="color:#f92672">saveArticle</span> <span style="color:#f92672">SaveArticle</span><span style="color:#f92672">)</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">saveArticle</span><span style="color:#a6e22e">.CreateProse</span><span style="color:#f92672">()</span><span style="color:#a6e22e">.SaveProse</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">saveArticle</span><span style="color:#a6e22e">.CreateAncientPoetry</span><span style="color:#f92672">()</span><span style="color:#a6e22e">.SaveAncientPoetry</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">func</span> <span style="color:#f92672">ExampleSaveRedis</span><span style="color:#f92672">()</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">var</span> <span style="color:#f92672">factory</span> <span style="color:#f92672">SaveArticle</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">factory</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">SaveRedis</span>{}
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">Save</span><span style="color:#f92672">(</span><span style="color:#f92672">factory</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">//</span> <span style="color:#f92672">Output</span><span style="color:#a6e22e">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">//</span> <span style="color:#f92672">Redis</span> <span style="color:#f92672">Save</span> <span style="color:#f92672">Prose</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">//</span> <span style="color:#f92672">Redis</span> <span style="color:#f92672">Save</span> <span style="color:#f92672">Ancient</span> <span style="color:#f92672">Poetry</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">func</span> <span style="color:#f92672">ExampleSaveMysql</span><span style="color:#f92672">()</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">var</span> <span style="color:#f92672">factory</span> <span style="color:#f92672">SaveArticle</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">factory</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">SaveMysql</span>{}
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">Save</span><span style="color:#f92672">(</span><span style="color:#f92672">factory</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">//</span> <span style="color:#f92672">Output</span><span style="color:#a6e22e">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">//</span> <span style="color:#f92672">Mysql</span> <span style="color:#f92672">Save</span> <span style="color:#f92672">Prose</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">//</span> <span style="color:#f92672">Mysql</span> <span style="color:#f92672">Save</span> <span style="color:#f92672">Ancient</span> <span style="color:#f92672">Poetry</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="建造者模式-builder">建造者模式 Builder<a hidden class="anchor" aria-hidden="true" href="#建造者模式-builder">#</a></h2>
<h3 id="问题-2">问题<a hidden class="anchor" aria-hidden="true" href="#问题-2">#</a></h3>
<p>假设业务需要按步骤创建一系列复杂的对象，实现这些步骤的代码加在一起非常繁复，我们可以将这些代码放进一个包含了众多参数的构造函数中，但这个构造函数看起来将会非常杂乱无章，且难以维护。</p>
<p>假设业务需要建造一个房子对象，需要先打地基、建墙、建屋顶、建花园、放置家具……。我们需要非常多的步骤，并且这些步骤之间是有联系的，即使将各个步骤从一个大的构造函数抽出到其他小函数中，整个程序的层次结构看起来依然很复杂。</p>
<p>如何解决呢？像这种复杂的有许多步骤的构造函数，就可以用建造者模式来设计。</p>
<p>建造者模式的用处就在于能够分步骤创建复杂对象。</p>
<h3 id="解决-2">解决<a hidden class="anchor" aria-hidden="true" href="#解决-2">#</a></h3>
<p>在建造者模式中，我们需要清晰的定义每个步骤的代码，然后在一个构造函数中操作这些步骤，我们需要一个<strong>主管类</strong>，用这个主管类来管理各步骤。这样我们就只需要将所需参数传给一个构造函数，构造函数再将参数传递给对应的主管类，最后由主管类完成后续所有建造任务。</p>
<p>请看以下代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scss" data-lang="scss"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#f92672">builder</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">//</span> <span style="color:#960050;background-color:#1e0010">建造者接口</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">type</span> <span style="color:#f92672">Builder</span> <span style="color:#f92672">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">Part1</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">Part2</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">Part3</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 管理类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">type</span> <span style="color:#f92672">Director</span> <span style="color:#f92672">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">builder</span> <span style="color:#f92672">Builder</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">func</span> <span style="color:#f92672">NewDirector</span><span style="color:#f92672">(</span><span style="color:#f92672">builder</span> <span style="color:#f92672">Builder</span><span style="color:#f92672">)</span> <span style="color:#f92672">*</span><span style="color:#f92672">Director</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">return</span> <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">Director</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">builder</span><span style="color:#f92672">:</span> builder<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 建造
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">func</span> <span style="color:#f92672">(</span><span style="color:#f92672">d</span> <span style="color:#f92672">*</span><span style="color:#f92672">Director</span><span style="color:#f92672">)</span> <span style="color:#f92672">Construct</span><span style="color:#f92672">()</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">d</span><span style="color:#a6e22e">.builder.Part1</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">d</span><span style="color:#a6e22e">.builder.Part2</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">d</span><span style="color:#a6e22e">.builder.Part3</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">type</span> <span style="color:#f92672">Builder</span> <span style="color:#f92672">struct</span> {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">func</span> <span style="color:#f92672">(</span><span style="color:#f92672">b</span> <span style="color:#f92672">*</span><span style="color:#f92672">Builder</span><span style="color:#f92672">)</span> <span style="color:#f92672">Part1</span><span style="color:#f92672">()</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">fmt</span><span style="color:#a6e22e">.Println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;part1&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">func</span> <span style="color:#f92672">(</span><span style="color:#f92672">b</span> <span style="color:#f92672">*</span><span style="color:#f92672">Builder</span><span style="color:#f92672">)</span> <span style="color:#f92672">Part2</span><span style="color:#f92672">()</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">fmt</span><span style="color:#a6e22e">.Println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;part2&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">func</span> <span style="color:#f92672">(</span><span style="color:#f92672">b</span> <span style="color:#f92672">*</span><span style="color:#f92672">Builder</span><span style="color:#f92672">)</span> <span style="color:#f92672">Part3</span><span style="color:#f92672">()</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">fmt</span><span style="color:#a6e22e">.Println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;part3&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如上，我们实现part1、part2、part3这3个步骤，只需要执行构造函数，对应的管理类就可以运行建造方法Construct，完成3个步骤的执行。</p>
<p>测试代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">builder</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">ExampleBuilder</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">builder</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Builder</span>{}
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">director</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewDirector</span>(<span style="color:#a6e22e">builder</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">director</span>.<span style="color:#a6e22e">Construct</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Output:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// part1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// part2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// part3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="原型模式-prototype">原型模式 Prototype<a hidden class="anchor" aria-hidden="true" href="#原型模式-prototype">#</a></h2>
<h3 id="问题-3">问题<a hidden class="anchor" aria-hidden="true" href="#问题-3">#</a></h3>
<p>如果你希望生成一个对象，其与另一个对象完全相同，该如何实现呢？</p>
<p>如果遍历对象的所有成员，将其依次复制到新对象中，会稍显麻烦，而且有些对象可能会有私有成员变量遗漏。</p>
<p>原型模式将这个克隆的过程委派给了被克隆的实际对象，被克隆的对象就叫做“原型”。</p>
<h3 id="解决-3">解决<a hidden class="anchor" aria-hidden="true" href="#解决-3">#</a></h3>
<p>如果需要克隆一个新的对象，这个对象完全独立于它的原型，那么就可以使用原型模式。</p>
<p>原型模式的实现非常简单，请看以下代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">prototype</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;testing&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">manager</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">PrototypeManager</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Type1</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Type1</span>) <span style="color:#a6e22e">Clone</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">Type1</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">tc</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">t</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">tc</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestClone</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">t1</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Type1</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#e6db74">&#34;type1&#34;</span>,
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">t2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">t1</span>.<span style="color:#a6e22e">Clone</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">t1</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">t2</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Fatal</span>(<span style="color:#e6db74">&#34;error! get clone not working&#34;</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们依靠一个Clone方法实现了原型Type1的克隆。</p>
<p>原型模式的用处就在于我们可以克隆对象，而无需与原型对象的依赖相耦合。</p>
<h2 id="单例模式-singleton">单例模式 Singleton<a hidden class="anchor" aria-hidden="true" href="#单例模式-singleton">#</a></h2>
<h3 id="问题-4">问题<a hidden class="anchor" aria-hidden="true" href="#问题-4">#</a></h3>
<p>存储着重要对象的全局变量，往往意味着“不安全”，因为你无法保证这个全局变量的值不会在项目的某个引用处被覆盖掉。</p>
<p>对数据的修改经常导致出乎意料的的结果和难以发现的bug。我在一处更新数据，却没有意识到软件中的另一处期望着完全不同的数据，于是一个功能就失效了，而且找出故障的原因也会非常困难。</p>
<p>一个较好的解决方案是：将这样的“可变数据”封装起来，写一个查询方法专门用来获取这些值。</p>
<p>单例模式则更进一步：除了要为“可变数据”提供一个全局访问方法，它还要保证获取到的只有同一个实例。也就是说，如果你打算用一个构造函数创建一个对象，单例模式将保证你得到的不是一个新的对象，而是之前创建过的对象，并且每次它所返回的都只有这同一个对象，也就是单例。这可以保护该对象实例不被篡改。</p>
<h3 id="解决-4">解决<a hidden class="anchor" aria-hidden="true" href="#解决-4">#</a></h3>
<p>单例模式需要一个全局构造函数，这个构造函数会返回一个私有的对象，无论何时调用，它总是返回相同的对象。</p>
<p>请看以下代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">singleton</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;sync&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 单例实例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">singleton</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Value</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Singleton</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">getValue</span>() <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#a6e22e">singleton</span>) <span style="color:#a6e22e">getValue</span>() <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">Value</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> (
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">instance</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">singleton</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">once</span>     <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Once</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 构造方法，用于获取单例模式对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">GetInstance</span>(<span style="color:#a6e22e">v</span> <span style="color:#66d9ef">int</span>) <span style="color:#a6e22e">Singleton</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">once</span>.<span style="color:#a6e22e">Do</span>(<span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">instance</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">singleton</span>{<span style="color:#a6e22e">Value</span>: <span style="color:#a6e22e">v</span>}
</span></span><span style="display:flex;"><span>  })
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">instance</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>单例实例singleton被保存为一个私有的变量，以保证不被其他包的函数引用。</p>
<p>用构造方法GetInstance可以获得单例实例，函数中使用了sync包的once方法，以保证实例只会在首次调用时被初始化一次，之后再调用构造方法都只会返回同一个实例。</p>
<p>测试代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestSingleton</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">ins1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">GetInstance2</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">ins2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">GetInstance2</span>(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ins1</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">ins2</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Fatal</span>(<span style="color:#e6db74">&#34;instance is not equal&#34;</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果你需要更加严格地控制全局变量，这确实很有必要，那么就使用单例模式吧。</p>
<h1 id="结构型模式">结构型模式<a hidden class="anchor" aria-hidden="true" href="#结构型模式">#</a></h1>
<p>结构型模式将一些对象和类组装成更大的结构体，并同时保持结构的灵活和高效。</p>
<h2 id="适配器模式-adapter">适配器模式 Adapter<a hidden class="anchor" aria-hidden="true" href="#适配器模式-adapter">#</a></h2>
<h3 id="问题-5">问题<a hidden class="anchor" aria-hidden="true" href="#问题-5">#</a></h3>
<p>适配器模式说白了就是兼容。</p>
<p>假设一开始我们提供了A对象，后期随着业务迭代，又需要从A对象的基础之上衍生出不同的需求。如果有很多函数已经在线上调用了A对象，此时再对A对象进行修改就比较麻烦，因为需要考虑<strong>兼容问题</strong>。还有更糟糕的情况， 你可能没有程序库的源代码， 从而无法对其进行修改。</p>
<p>此时就可以用一个适配器，它就像一个接口转换器，调用方只需要调用这个适配器接口，而不需要关注其背后的实现，由适配器接口封装复杂的过程。</p>
<h3 id="解决-5">解决<a hidden class="anchor" aria-hidden="true" href="#解决-5">#</a></h3>
<p>假设有2个接口，一个将厘米转为米，一个将米转为厘米。我们提供一个适配器接口，使调用方不需要再操心调用哪个接口，直接由适配器做好兼容。</p>
<p>请看以下代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">adapter</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 提供一个获取米的接口和一个获取厘米的接口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Cm</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">getLength</span>(<span style="color:#66d9ef">float64</span>) <span style="color:#66d9ef">float64</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">M</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">getLength</span>(<span style="color:#66d9ef">float64</span>) <span style="color:#66d9ef">float64</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewM</span>() <span style="color:#a6e22e">M</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">getLengthM</span>{}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">getLengthM</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">getLengthM</span>) <span style="color:#a6e22e">getLength</span>(<span style="color:#a6e22e">cm</span> <span style="color:#66d9ef">float64</span>) <span style="color:#66d9ef">float64</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">cm</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewCm</span>() <span style="color:#a6e22e">Cm</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">getLengthCm</span>{}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">getLengthCm</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">getLengthCm</span>) <span style="color:#a6e22e">getLength</span>(<span style="color:#a6e22e">m</span> <span style="color:#66d9ef">float64</span>) <span style="color:#66d9ef">float64</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 适配器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">LengthAdapter</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">getLength</span>(<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">float64</span>) <span style="color:#66d9ef">float64</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewLengthAdapter</span>() <span style="color:#a6e22e">LengthAdapter</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">getLengthAdapter</span>{}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">getLengthAdapter</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">getLengthAdapter</span>) <span style="color:#a6e22e">getLength</span>(<span style="color:#a6e22e">isType</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">into</span> <span style="color:#66d9ef">float64</span>) <span style="color:#66d9ef">float64</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">isType</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;m&#34;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">NewM</span>().<span style="color:#a6e22e">getLength</span>(<span style="color:#a6e22e">into</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">NewCm</span>().<span style="color:#a6e22e">getLength</span>(<span style="color:#a6e22e">into</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面实现了Cm和M两个接口，并由适配器LengthAdapter做兼容。</p>
<p>测试代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">adapter</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;testing&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestAdapter</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">into</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">10.5</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">getLengthAdapter</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewLengthAdapter</span>().<span style="color:#a6e22e">getLength</span>(<span style="color:#e6db74">&#34;m&#34;</span>, <span style="color:#a6e22e">into</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">getLengthM</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewM</span>().<span style="color:#a6e22e">getLength</span>(<span style="color:#a6e22e">into</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">getLengthAdapter</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">getLengthM</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Fatalf</span>(<span style="color:#e6db74">&#34;getLengthAdapter: %f, getLengthM: %f&#34;</span>, <span style="color:#a6e22e">getLengthAdapter</span>, <span style="color:#a6e22e">getLengthM</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="桥接模式bridge">桥接模式Bridge<a hidden class="anchor" aria-hidden="true" href="#桥接模式bridge">#</a></h2>
<h3 id="问题-6">问题<a hidden class="anchor" aria-hidden="true" href="#问题-6">#</a></h3>
<p>假设一开始业务需要两种发送信息的渠道，sms和email，我们可以分别实现sms和email两个接口。</p>
<p>之后随着业务迭代，又产生了新的需求，需要提供两种系统发送方式，systemA和systemB，并且这两种系统发送方式都应该支持sms和email渠道。</p>
<p>此时至少需要提供4种方法：systemA to sms，systemA to email，systemB to sms，systemB to email。</p>
<p>如果再分别增加一种渠道和一种系统发送方式，就需要提供9种方法。这将导致代码的复杂程度指数增长。</p>
<h3 id="解决-6">解决<a hidden class="anchor" aria-hidden="true" href="#解决-6">#</a></h3>
<p>其实之前我们是在用继承的想法来看问题，桥接模式则希望将继承关系转变为关联关系，使两个类独立存在。</p>
<p>详细说一下：</p>
<ul>
<li>桥接模式需要将抽象和实现区分开；</li>
<li>桥接模式需要将“渠道”和“系统发送方式”这两种类别区分开；</li>
<li>最后在“系统发送方式”的类里调用“渠道”的抽象接口，使他们从继承关系转变为关联关系。</li>
</ul>
<p>用一句话总结桥接模式的理念，就是：“<strong>将抽象与实现解耦，将不同类别的继承关系改为关联关系。</strong> ”</p>
<p>请看以下代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">bridge</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 两种发送消息的方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SendMessage</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">send</span>(<span style="color:#a6e22e">text</span>, <span style="color:#a6e22e">to</span> <span style="color:#66d9ef">string</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">sms</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewSms</span>() <span style="color:#a6e22e">SendMessage</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sms</span>{}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">sms</span>) <span style="color:#a6e22e">send</span>(<span style="color:#a6e22e">text</span>, <span style="color:#a6e22e">to</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;send %s to %s sms&#34;</span>, <span style="color:#a6e22e">text</span>, <span style="color:#a6e22e">to</span>))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">email</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewEmail</span>() <span style="color:#a6e22e">SendMessage</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">email</span>{}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">email</span>) <span style="color:#a6e22e">send</span>(<span style="color:#a6e22e">text</span>, <span style="color:#a6e22e">to</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;send %s to %s email&#34;</span>, <span style="color:#a6e22e">text</span>, <span style="color:#a6e22e">to</span>))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 两种发送系统
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">systemA</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">method</span> <span style="color:#a6e22e">SendMessage</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewSystemA</span>(<span style="color:#a6e22e">method</span> <span style="color:#a6e22e">SendMessage</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">systemA</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">systemA</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">method</span>: <span style="color:#a6e22e">method</span>,
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">systemA</span>) <span style="color:#a6e22e">SendMessage</span>(<span style="color:#a6e22e">text</span>, <span style="color:#a6e22e">to</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">method</span>.<span style="color:#a6e22e">send</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;[System A] %s&#34;</span>, <span style="color:#a6e22e">text</span>), <span style="color:#a6e22e">to</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">systemB</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">method</span> <span style="color:#a6e22e">SendMessage</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewSystemB</span>(<span style="color:#a6e22e">method</span> <span style="color:#a6e22e">SendMessage</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">systemB</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">systemB</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">method</span>: <span style="color:#a6e22e">method</span>,
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">systemB</span>) <span style="color:#a6e22e">SendMessage</span>(<span style="color:#a6e22e">text</span>, <span style="color:#a6e22e">to</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">method</span>.<span style="color:#a6e22e">send</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;[System B] %s&#34;</span>, <span style="color:#a6e22e">text</span>), <span style="color:#a6e22e">to</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以看到我们先定义了sms和email二种实现，以及接口SendMessage。接着我们实现了systemA和systemB，并调用了抽象接口SendMessage。</p>
<p>测试代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scss" data-lang="scss"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#f92672">bridge</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">func</span> <span style="color:#f92672">ExampleSystemA</span><span style="color:#f92672">()</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">NewSystemA</span><span style="color:#f92672">(</span><span style="color:#f92672">NewSms</span><span style="color:#f92672">())</span><span style="color:#a6e22e">.SendMessage</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hi&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;baby&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">NewSystemA</span><span style="color:#f92672">(</span><span style="color:#f92672">NewEmail</span><span style="color:#f92672">())</span><span style="color:#a6e22e">.SendMessage</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hi&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;baby&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">//</span> <span style="color:#f92672">Output</span><span style="color:#a6e22e">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">//</span> <span style="color:#f92672">send</span> <span style="color:#f92672">[</span><span style="color:#f92672">System</span> <span style="color:#f92672">A</span><span style="color:#f92672">]</span> <span style="color:#f92672">hi</span> <span style="color:#f92672">to</span> <span style="color:#f92672">baby</span> <span style="color:#f92672">sms</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">//</span> <span style="color:#f92672">send</span> <span style="color:#f92672">[</span><span style="color:#f92672">System</span> <span style="color:#f92672">A</span><span style="color:#f92672">]</span> <span style="color:#f92672">hi</span> <span style="color:#f92672">to</span> <span style="color:#f92672">baby</span> <span style="color:#f92672">email</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">func</span> <span style="color:#f92672">ExampleSystemB</span><span style="color:#f92672">()</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">NewSystemB</span><span style="color:#f92672">(</span><span style="color:#f92672">NewSms</span><span style="color:#f92672">())</span><span style="color:#a6e22e">.SendMessage</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hi&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;baby&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">NewSystemB</span><span style="color:#f92672">(</span><span style="color:#f92672">NewEmail</span><span style="color:#f92672">())</span><span style="color:#a6e22e">.SendMessage</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hi&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;baby&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">//</span> <span style="color:#f92672">Output</span><span style="color:#a6e22e">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">//</span> <span style="color:#f92672">send</span> <span style="color:#f92672">[</span><span style="color:#f92672">System</span> <span style="color:#f92672">B</span><span style="color:#f92672">]</span> <span style="color:#f92672">hi</span> <span style="color:#f92672">to</span> <span style="color:#f92672">baby</span> <span style="color:#f92672">sms</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">//</span> <span style="color:#f92672">send</span> <span style="color:#f92672">[</span><span style="color:#f92672">System</span> <span style="color:#f92672">B</span><span style="color:#f92672">]</span> <span style="color:#f92672">hi</span> <span style="color:#f92672">to</span> <span style="color:#f92672">baby</span> <span style="color:#f92672">email</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果你想要拆分或重组一个具有多重功能的复杂类，可以使用桥接模式。</p>
<h2 id="对象树模式object-tree">对象树模式Object Tree<a hidden class="anchor" aria-hidden="true" href="#对象树模式object-tree">#</a></h2>
<h3 id="问题-7">问题<a hidden class="anchor" aria-hidden="true" href="#问题-7">#</a></h3>
<p>在项目中，如果我们需要用到树状结构，就可以使用对象树模式。换言之，如果项目的核心模型不能以树状结构表示，则没必要使用对象树模式。</p>
<p>对象树模式的用处就在于可以利用多态和递归机制更方便地使用复杂树结构。</p>
<h3 id="解决-7">解决<a hidden class="anchor" aria-hidden="true" href="#解决-7">#</a></h3>
<p>请看以下代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">objecttree</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Component</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Parent</span>() <span style="color:#a6e22e">Component</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">SetParent</span>(<span style="color:#a6e22e">Component</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Name</span>() <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">SetName</span>(<span style="color:#66d9ef">string</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">AddChild</span>(<span style="color:#a6e22e">Component</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Search</span>(<span style="color:#66d9ef">string</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> (
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">LeafNode</span> = <span style="color:#66d9ef">iota</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">CompositeNode</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewComponent</span>(<span style="color:#a6e22e">kind</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>) <span style="color:#a6e22e">Component</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">c</span> <span style="color:#a6e22e">Component</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">kind</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">LeafNode</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">c</span> = <span style="color:#a6e22e">NewLeaf</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">CompositeNode</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">c</span> = <span style="color:#a6e22e">NewComposite</span>()
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">SetName</span>(<span style="color:#a6e22e">name</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">c</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">component</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">parent</span> <span style="color:#a6e22e">Component</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">name</span>   <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">component</span>) <span style="color:#a6e22e">Parent</span>() <span style="color:#a6e22e">Component</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">parent</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">component</span>) <span style="color:#a6e22e">SetParent</span>(<span style="color:#a6e22e">parent</span> <span style="color:#a6e22e">Component</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">parent</span> = <span style="color:#a6e22e">parent</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">component</span>) <span style="color:#a6e22e">Name</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">name</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">component</span>) <span style="color:#a6e22e">SetName</span>(<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">name</span> = <span style="color:#a6e22e">name</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">component</span>) <span style="color:#a6e22e">AddChild</span>(<span style="color:#a6e22e">Component</span>) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Leaf</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">component</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewLeaf</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">Leaf</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Leaf</span>{}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Leaf</span>) <span style="color:#a6e22e">Search</span>(<span style="color:#a6e22e">pre</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;leaf %s-%s\n&#34;</span>, <span style="color:#a6e22e">pre</span>, <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Name</span>())
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Composite</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">component</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">childs</span> []<span style="color:#a6e22e">Component</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewComposite</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">Composite</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Composite</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">childs</span>: make([]<span style="color:#a6e22e">Component</span>, <span style="color:#ae81ff">0</span>),
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Composite</span>) <span style="color:#a6e22e">AddChild</span>(<span style="color:#a6e22e">child</span> <span style="color:#a6e22e">Component</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">child</span>.<span style="color:#a6e22e">SetParent</span>(<span style="color:#a6e22e">c</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">childs</span> = append(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">childs</span>, <span style="color:#a6e22e">child</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Composite</span>) <span style="color:#a6e22e">Search</span>(<span style="color:#a6e22e">pre</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%s+%s\n&#34;</span>, <span style="color:#a6e22e">pre</span>, <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Name</span>())
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">pre</span> <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34; &#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">comp</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">childs</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">comp</span>.<span style="color:#a6e22e">Search</span>(<span style="color:#a6e22e">pre</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在Search方法中使用递归打印出了整棵树结构。</p>
<p>测试代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">objecttree</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">ExampleComposite</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">root</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewComponent</span>(<span style="color:#a6e22e">CompositeNode</span>, <span style="color:#e6db74">&#34;root&#34;</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">c1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewComponent</span>(<span style="color:#a6e22e">CompositeNode</span>, <span style="color:#e6db74">&#34;c1&#34;</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">c2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewComponent</span>(<span style="color:#a6e22e">CompositeNode</span>, <span style="color:#e6db74">&#34;c2&#34;</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">c3</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewComponent</span>(<span style="color:#a6e22e">CompositeNode</span>, <span style="color:#e6db74">&#34;c3&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">l1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewComponent</span>(<span style="color:#a6e22e">LeafNode</span>, <span style="color:#e6db74">&#34;l1&#34;</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">l2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewComponent</span>(<span style="color:#a6e22e">LeafNode</span>, <span style="color:#e6db74">&#34;l2&#34;</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">l3</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewComponent</span>(<span style="color:#a6e22e">LeafNode</span>, <span style="color:#e6db74">&#34;l3&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">AddChild</span>(<span style="color:#a6e22e">c1</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">AddChild</span>(<span style="color:#a6e22e">c2</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">c1</span>.<span style="color:#a6e22e">AddChild</span>(<span style="color:#a6e22e">c3</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">c1</span>.<span style="color:#a6e22e">AddChild</span>(<span style="color:#a6e22e">l1</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">c2</span>.<span style="color:#a6e22e">AddChild</span>(<span style="color:#a6e22e">l2</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">c2</span>.<span style="color:#a6e22e">AddChild</span>(<span style="color:#a6e22e">l3</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Search</span>(<span style="color:#e6db74">&#34;&#34;</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Output:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// +root
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//  +c1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//   +c3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//leaf   -l1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//  +c2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//leaf   -l2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//leaf   -l3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="装饰模式decorator">装饰模式Decorator<a hidden class="anchor" aria-hidden="true" href="#装饰模式decorator">#</a></h2>
<h3 id="问题-8">问题<a hidden class="anchor" aria-hidden="true" href="#问题-8">#</a></h3>
<p>有时候我们需要在一个类的基础上扩展另一个类，例如，一个披萨类，你可以在披萨类的基础上增加番茄披萨类和芝士披萨类。此时就可以使用装饰模式，简单来说，<strong>装饰模式就是将对象封装到另一个对象中，用以为原对象绑定新的行为</strong>。</p>
<p>如果你希望在无需修改代码的情况下使用对象，并且希望为对象新增额外的行为，就可以考虑使用装饰模式。</p>
<h3 id="解决-8">解决<a hidden class="anchor" aria-hidden="true" href="#解决-8">#</a></h3>
<p>用上文的披萨类做例子。请看以下代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">decorator</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">pizza</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">getPrice</span>() <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">base</span> <span style="color:#66d9ef">struct</span> {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">base</span>) <span style="color:#a6e22e">getPrice</span>() <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">15</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">tomatoTopping</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">pizza</span> <span style="color:#a6e22e">pizza</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">tomatoTopping</span>) <span style="color:#a6e22e">getPrice</span>() <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">pizzaPrice</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">pizza</span>.<span style="color:#a6e22e">getPrice</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">pizzaPrice</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">cheeseTopping</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">pizza</span> <span style="color:#a6e22e">pizza</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">cheeseTopping</span>) <span style="color:#a6e22e">getPrice</span>() <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">pizzaPrice</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">pizza</span>.<span style="color:#a6e22e">getPrice</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">pizzaPrice</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">20</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>首先我们定义了pizza接口，创建了base类，实现了方法getPrice。然后再用装饰模式的理念，实现了tomatoTopping和cheeseTopping类，他们都封装了pizza接口的getPrice方法。</p>
<p>测试代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">decorator</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">ExampleDecorator</span>() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">pizza</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">base</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//Add cheese topping
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">pizzaWithCheese</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">cheeseTopping</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pizza</span>: <span style="color:#a6e22e">pizza</span>,
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//Add tomato topping
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">pizzaWithCheeseAndTomato</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">tomatoTopping</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pizza</span>: <span style="color:#a6e22e">pizzaWithCheese</span>,
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;price is %d\n&#34;</span>, <span style="color:#a6e22e">pizzaWithCheeseAndTomato</span>.<span style="color:#a6e22e">getPrice</span>())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Output:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// price is 45
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="外观模式facade">外观模式Facade<a hidden class="anchor" aria-hidden="true" href="#外观模式facade">#</a></h2>
<h3 id="问题-9">问题<a hidden class="anchor" aria-hidden="true" href="#问题-9">#</a></h3>
<p>如果你需要初始化大量复杂的库或框架，就需要管理其依赖关系并且按正确的顺序执行。此时就可以用一个外观类来统一处理这些依赖关系，以对其进行整合。</p>
<h3 id="解决-9">解决<a hidden class="anchor" aria-hidden="true" href="#解决-9">#</a></h3>
<p>外观模式和建造者模式很相似。两者的区别在于，外观模式是一种结构型模式，她的目的是将对象组合起来，而不是像建造者模式那样创建出不同的产品。</p>
<p>请看以下代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">facade</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 初始化APIA和APIB
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">APIA</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">TestA</span>() <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewAPIA</span>() <span style="color:#a6e22e">APIA</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">apiRunA</span>{}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">apiRunA</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">apiRunA</span>) <span style="color:#a6e22e">TestA</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;A api running&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">APIB</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">TestB</span>() <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewAPIB</span>() <span style="color:#a6e22e">APIB</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">apiRunB</span>{}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">apiRunB</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">apiRunB</span>) <span style="color:#a6e22e">TestB</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;B api running&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 外观类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">API</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Test</span>() <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewAPI</span>() <span style="color:#a6e22e">API</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">apiRun</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">a</span>: <span style="color:#a6e22e">NewAPIA</span>(),
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">b</span>: <span style="color:#a6e22e">NewAPIB</span>(),
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">apiRun</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">a</span> <span style="color:#a6e22e">APIA</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">b</span> <span style="color:#a6e22e">APIB</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">apiRun</span>) <span style="color:#a6e22e">Test</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">aRet</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">TestA</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">bRet</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">TestB</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%s\n%s&#34;</span>, <span style="color:#a6e22e">aRet</span>, <span style="color:#a6e22e">bRet</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>假设要初始化APIA和APIB，我们就可以通过一个外观类API进行处理，在外观类接口Test方法中分别执行类TestA方法和TestB方法。</p>
<p>测试代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">facade</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;testing&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">expect</span> = <span style="color:#e6db74">&#34;A api running\nB api running&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// TestFacadeAPI ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestFacadeAPI</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">api</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewAPI</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">ret</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">api</span>.<span style="color:#a6e22e">Test</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ret</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">expect</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Fatalf</span>(<span style="color:#e6db74">&#34;expect %s, return %s&#34;</span>, <span style="color:#a6e22e">expect</span>, <span style="color:#a6e22e">ret</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="享元模式-flyweight">享元模式 Flyweight<a hidden class="anchor" aria-hidden="true" href="#享元模式-flyweight">#</a></h2>
<h3 id="问题-10">问题<a hidden class="anchor" aria-hidden="true" href="#问题-10">#</a></h3>
<p>在一些情况下，程序没有足够的内存容量支持存储大量对象，或者大量的对象存储着重复的状态，此时就会造成内存资源的浪费。</p>
<p>享元模式提出了这样的解决方案：如果多个对象中相同的状态可以共用，就能在在有限的内存容量中载入更多对象。</p>
<h3 id="解决-10">解决<a hidden class="anchor" aria-hidden="true" href="#解决-10">#</a></h3>
<p>如上所说，享元模式希望抽取出能在多个对象间共享的重复状态。</p>
<p>我们可以使用map结构来实现这一设想，假设需要存储一些代表颜色的对象，使用享元模式可以这样做，请看以下代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">flyweight</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 享元工厂
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ColorFlyweightFactory</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">maps</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">ColorFlyweight</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">colorFactory</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ColorFlyweightFactory</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">GetColorFlyweightFactory</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">ColorFlyweightFactory</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">colorFactory</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">colorFactory</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">ColorFlyweightFactory</span>{
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">maps</span>: make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">ColorFlyweight</span>),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">colorFactory</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">f</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ColorFlyweightFactory</span>) <span style="color:#a6e22e">Get</span>(<span style="color:#a6e22e">filename</span> <span style="color:#66d9ef">string</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">ColorFlyweight</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">color</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">maps</span>[<span style="color:#a6e22e">filename</span>]
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">color</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">color</span> = <span style="color:#a6e22e">NewColorFlyweight</span>(<span style="color:#a6e22e">filename</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">maps</span>[<span style="color:#a6e22e">filename</span>] = <span style="color:#a6e22e">color</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">color</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ColorFlyweight</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">data</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 存储color对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewColorFlyweight</span>(<span style="color:#a6e22e">filename</span> <span style="color:#66d9ef">string</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">ColorFlyweight</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Load color file
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">data</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;color data %s&#34;</span>, <span style="color:#a6e22e">filename</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">ColorFlyweight</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">data</span>: <span style="color:#a6e22e">data</span>,
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ColorViewer</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span><span style="color:#a6e22e">ColorFlyweight</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewColorViewer</span>(<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">ColorViewer</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">color</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">GetColorFlyweightFactory</span>().<span style="color:#a6e22e">Get</span>(<span style="color:#a6e22e">name</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">ColorViewer</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ColorFlyweight</span>: <span style="color:#a6e22e">color</span>,
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们定义了一个享元工厂，使用map存储相同对象（key）的状态（value）。这个享元工厂可以使我们更方便和安全的访问各种享元，保证其状态不被修改。</p>
<p>我们定义了NewColorViewer方法，它会调用享元工厂的Get方法存储对象，而在享元工厂的实现中可以看到，相同状态的对象只会占用一次。</p>
<p>测试代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">flyweight</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;testing&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestFlyweight</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">viewer1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewColorViewer</span>(<span style="color:#e6db74">&#34;blue&#34;</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">viewer2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewColorViewer</span>(<span style="color:#e6db74">&#34;blue&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">viewer1</span>.<span style="color:#a6e22e">ColorFlyweight</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">viewer2</span>.<span style="color:#a6e22e">ColorFlyweight</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Fail</span>()
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当程序需要存储大量对象且没有足够的内存容量时，可以考虑使用享元模式。</p>
<h2 id="代理模式proxy">代理模式Proxy<a hidden class="anchor" aria-hidden="true" href="#代理模式proxy">#</a></h2>
<h3 id="问题-11">问题<a hidden class="anchor" aria-hidden="true" href="#问题-11">#</a></h3>
<p>如果你需要在访问一个对象时，有一个像“代理”一样的角色，她可以在访问对象之前为你进行缓存检查、权限判断等访问控制，在访问对象之后为你进行结果缓存、日志记录等结果处理，那么就可以考虑使用代理模式。</p>
<p>回忆一下一些web框架的router模块，当客户端访问一个接口时，在最终执行对应的接口之前，router模块会执行一些事前操作，进行权限判断等操作，在执行之后还会记录日志，这就是典型的代理模式。</p>
<h3 id="解决-11">解决<a hidden class="anchor" aria-hidden="true" href="#解决-11">#</a></h3>
<p>代理模式需要一个代理类，其包含执行真实对象所需的成员变量，并由代理类管理整个生命周期。</p>
<p>请看以下代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">proxy</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Subject</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Proxy</span>() <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 代理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Proxy</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">real</span> <span style="color:#a6e22e">RealSubject</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#a6e22e">Proxy</span>) <span style="color:#a6e22e">Proxy</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">res</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 在调用真实对象之前，检查缓存，判断权限，等等
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">real</span>.<span style="color:#a6e22e">Pre</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 调用真实对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">real</span>.<span style="color:#a6e22e">Real</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 调用之后的操作，如缓存结果，对结果进行处理，等等
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">real</span>.<span style="color:#a6e22e">After</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 真实对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">RealSubject</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">RealSubject</span>) <span style="color:#a6e22e">Real</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Print</span>(<span style="color:#e6db74">&#34;real&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">RealSubject</span>) <span style="color:#a6e22e">Pre</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Print</span>(<span style="color:#e6db74">&#34;pre:&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">RealSubject</span>) <span style="color:#a6e22e">After</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Print</span>(<span style="color:#e6db74">&#34;:after&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们定义了代理类Proxy，执行Proxy之后，在调用真实对象Real之前，我们会先调用事前对象Pre，并在执行真实对象Real之后，调用事后对象After。</p>
<p>测试代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-perl" data-lang="perl"><span style="display:flex;"><span><span style="color:#66d9ef">package</span> proxy
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>func ExampleProxy() {
</span></span><span style="display:flex;"><span>  var <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">Subject</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">sub</span> = &amp;Proxy{}
</span></span><span style="display:flex;"><span>  sub<span style="color:#f92672">.</span>Proxy()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">//</span> Output:
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">//</span> pre:real:after
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="行为型模式">行为型模式<a hidden class="anchor" aria-hidden="true" href="#行为型模式">#</a></h1>
<p>行为型模式处理对象和类之间的通信，并使其保持高效的沟通和委派。</p>
<h2 id="责任链模式chain-of-responsibility">责任链模式Chain of Responsibility<a hidden class="anchor" aria-hidden="true" href="#责任链模式chain-of-responsibility">#</a></h2>
<h3 id="问题-12">问题<a hidden class="anchor" aria-hidden="true" href="#问题-12">#</a></h3>
<p>假设我们要让程序按照指定的步骤执行，并且这个步骤的顺序不是固定的，而是可以根据不同需求改变的，每个步骤都会对请求进行一些处理，并将结果传递给下一个步骤的处理者，就像一条流水线一样，我们该如何实现？</p>
<p>当遇到这种必须按顺序执行多个处理者，并且处理者的顺序可以改变的需求，我们可以考虑使用责任链模式。</p>
<h3 id="解决-12">解决<a hidden class="anchor" aria-hidden="true" href="#解决-12">#</a></h3>
<p>责任链模式使用了类似链表的结构。请看以下代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">chain</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">department</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">execute</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">Do</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">setNext</span>(<span style="color:#a6e22e">department</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">aPart</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">next</span> <span style="color:#a6e22e">department</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">aPart</span>) <span style="color:#a6e22e">execute</span>(<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Do</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">aPartDone</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;aPart done&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">next</span>.<span style="color:#a6e22e">execute</span>(<span style="color:#a6e22e">p</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;aPart&#34;</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">aPartDone</span> = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">next</span>.<span style="color:#a6e22e">execute</span>(<span style="color:#a6e22e">p</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">aPart</span>) <span style="color:#a6e22e">setNext</span>(<span style="color:#a6e22e">next</span> <span style="color:#a6e22e">department</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">next</span> = <span style="color:#a6e22e">next</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">bPart</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">next</span> <span style="color:#a6e22e">department</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">d</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">bPart</span>) <span style="color:#a6e22e">execute</span>(<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Do</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">bPartDone</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;bPart done&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">next</span>.<span style="color:#a6e22e">execute</span>(<span style="color:#a6e22e">p</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;bPart&#34;</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">bPartDone</span> = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">next</span>.<span style="color:#a6e22e">execute</span>(<span style="color:#a6e22e">p</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">d</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">bPart</span>) <span style="color:#a6e22e">setNext</span>(<span style="color:#a6e22e">next</span> <span style="color:#a6e22e">department</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">next</span> = <span style="color:#a6e22e">next</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">endPart</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">next</span> <span style="color:#a6e22e">department</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">endPart</span>) <span style="color:#a6e22e">execute</span>(<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Do</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">endPartDone</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;endPart Done&#34;</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;endPart&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">endPart</span>) <span style="color:#a6e22e">setNext</span>(<span style="color:#a6e22e">next</span> <span style="color:#a6e22e">department</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">next</span> = <span style="color:#a6e22e">next</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Do</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">aPartDone</span>   <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">bPartDone</span>   <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">endPartDone</span> <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们实现了方法execute和setNext，并定义了aPart、bPart、endPart这3个处理者，每个处理者都可以通过execute方法执行其对应的业务代码，并可以通过setNext方法决定下一个处理者是谁。除了endPart是最终的处理者之外，在它之前的处理者aPart、bPart的顺序都可以任意调整。</p>
<p>请看以下测试代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">ExampleChain</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">startPart</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">endPart</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">aPart</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">aPart</span>{}
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">aPart</span>.<span style="color:#a6e22e">setNext</span>(<span style="color:#a6e22e">startPart</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">bPart</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">bPart</span>{}
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">bPart</span>.<span style="color:#a6e22e">setNext</span>(<span style="color:#a6e22e">aPart</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">do</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Do</span>{}
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">bPart</span>.<span style="color:#a6e22e">execute</span>(<span style="color:#a6e22e">do</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Output:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// bPart
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// aPart
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// endPart
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>我们也可以调整处理者的执行顺序：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">ExampleChain2</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">startPart</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">endPart</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">bPart</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">bPart</span>{}
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">bPart</span>.<span style="color:#a6e22e">setNext</span>(<span style="color:#a6e22e">startPart</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">aPart</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">aPart</span>{}
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">aPart</span>.<span style="color:#a6e22e">setNext</span>(<span style="color:#a6e22e">bPart</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">do</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Do</span>{}
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">aPart</span>.<span style="color:#a6e22e">execute</span>(<span style="color:#a6e22e">do</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Output:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// aPart
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// bPart
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// endPart
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="命令模式command">命令模式Command<a hidden class="anchor" aria-hidden="true" href="#命令模式command">#</a></h2>
<h3 id="问题-13">问题<a hidden class="anchor" aria-hidden="true" href="#问题-13">#</a></h3>
<p>假设你实现了开启和关闭电视机的功能，随着业务迭代，还需要实现开启和关闭冰箱的功能，开启和关闭电灯的功能，开启和关闭微波炉的功能……这些功能都基于你的基类，开启和关闭。如果你之后对基类进行修改，很可能会影响到其他功能，这使项目变得不稳定了。</p>
<p>一个优秀的设计往往会关注于软件的分层与解耦，命令模式试图做到这样的结果：让命令和对应功能解耦，并能根据不同的请求将其方法参数化。</p>
<h3 id="解决-13">解决<a hidden class="anchor" aria-hidden="true" href="#解决-13">#</a></h3>
<p>还是用开启和关闭家用电器的例子来举例吧。请看以下代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">command</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 请求者
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">button</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">command</span> <span style="color:#a6e22e">command</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">button</span>) <span style="color:#a6e22e">press</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">command</span>.<span style="color:#a6e22e">execute</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 具体命令接口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">command</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">execute</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">onCommand</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">device</span> <span style="color:#a6e22e">device</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">onCommand</span>) <span style="color:#a6e22e">execute</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">device</span>.<span style="color:#a6e22e">on</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">offCommand</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">device</span> <span style="color:#a6e22e">device</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">offCommand</span>) <span style="color:#a6e22e">execute</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">device</span>.<span style="color:#a6e22e">off</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 接收者
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">device</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">on</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">off</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">tv</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">tv</span>) <span style="color:#a6e22e">on</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Turning tv on&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">tv</span>) <span style="color:#a6e22e">off</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Turning tv off&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">airConditioner</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">airConditioner</span>) <span style="color:#a6e22e">on</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Turning air conditioner on&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">airConditioner</span>) <span style="color:#a6e22e">off</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Turning air conditioner off&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们分别实现了请求者button，命令接口command，接收者device。请求者button就像是那个可以执行开启或关闭的遥控器，命令接口command则是一个中间层，它使我们的请求者和接收者解藕。</p>
<p>测试代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">command</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">ExampleCommand</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Tv</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">AirConditioner</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Output:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Turning tv on
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Turning tv off
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Turning air conditioner on
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Turning air conditioner off
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Tv</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">tv</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">tv</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">onTvCommand</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">onCommand</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">device</span>: <span style="color:#a6e22e">tv</span>,
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">offTvCommand</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">offCommand</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">device</span>: <span style="color:#a6e22e">tv</span>,
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">onTvButton</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">button</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">command</span>: <span style="color:#a6e22e">onTvCommand</span>,
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">onTvButton</span>.<span style="color:#a6e22e">press</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">offTvButton</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">button</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">command</span>: <span style="color:#a6e22e">offTvCommand</span>,
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">offTvButton</span>.<span style="color:#a6e22e">press</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">AirConditioner</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">airConditioner</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">airConditioner</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">onAirConditionerCommand</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">onCommand</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">device</span>: <span style="color:#a6e22e">airConditioner</span>,
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">offAirConditionerCommand</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">offCommand</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">device</span>: <span style="color:#a6e22e">airConditioner</span>,
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">onAirConditionerButton</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">button</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">command</span>: <span style="color:#a6e22e">onAirConditionerCommand</span>,
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">onAirConditionerButton</span>.<span style="color:#a6e22e">press</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">offAirConditionerButton</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">button</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">command</span>: <span style="color:#a6e22e">offAirConditionerCommand</span>,
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">offAirConditionerButton</span>.<span style="color:#a6e22e">press</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="迭代器模式iterator">迭代器模式Iterator<a hidden class="anchor" aria-hidden="true" href="#迭代器模式iterator">#</a></h2>
<h3 id="问题-14">问题<a hidden class="anchor" aria-hidden="true" href="#问题-14">#</a></h3>
<p>迭代器模式用于遍历集合中的元素，无论集合的数据结构是怎样的。</p>
<h3 id="解决-14">解决<a hidden class="anchor" aria-hidden="true" href="#解决-14">#</a></h3>
<p>请看以下代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">iterator</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 集合接口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">collection</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">createIterator</span>() <span style="color:#a6e22e">iterator</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 具体的集合
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">part</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">title</span>  <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">number</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">partCollection</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">part</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">parts</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">part</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">u</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">partCollection</span>) <span style="color:#a6e22e">createIterator</span>() <span style="color:#a6e22e">iterator</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">partIterator</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">parts</span>: <span style="color:#a6e22e">u</span>.<span style="color:#a6e22e">parts</span>,
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 迭代器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">iterator</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">hasNext</span>() <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">getNext</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">part</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 具体的迭代器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">partIterator</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">index</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">parts</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">part</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">u</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">partIterator</span>) <span style="color:#a6e22e">hasNext</span>() <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">u</span>.<span style="color:#a6e22e">index</span> &lt; len(<span style="color:#a6e22e">u</span>.<span style="color:#a6e22e">parts</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">u</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">partIterator</span>) <span style="color:#a6e22e">getNext</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">part</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">u</span>.<span style="color:#a6e22e">hasNext</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">part</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">u</span>.<span style="color:#a6e22e">parts</span>[<span style="color:#a6e22e">u</span>.<span style="color:#a6e22e">index</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">u</span>.<span style="color:#a6e22e">index</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">part</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>测试代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-css" data-lang="css"><span style="display:flex;"><span><span style="color:#f92672">func</span> <span style="color:#f92672">ExampleIterator</span><span style="color:#f92672">()</span> {
</span></span><span style="display:flex;"><span>  part1 :<span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>part<span style="color:#960050;background-color:#1e0010">{</span>
</span></span><span style="display:flex;"><span>    title<span style="color:#f92672">:</span>  <span style="color:#e6db74">&#34;part1&#34;</span>,
</span></span><span style="display:flex;"><span>    number<span style="color:#f92672">:</span> <span style="color:#ae81ff">10</span>,
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">part2</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#f92672">part</span>{
</span></span><span style="display:flex;"><span>    title:  <span style="color:#e6db74">&#34;part2&#34;</span>,
</span></span><span style="display:flex;"><span>    number<span style="color:#f92672">:</span> <span style="color:#ae81ff">20</span>,
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">part3</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#f92672">part</span>{
</span></span><span style="display:flex;"><span>    title:  <span style="color:#e6db74">&#34;part3&#34;</span>,
</span></span><span style="display:flex;"><span>    number<span style="color:#f92672">:</span> <span style="color:#ae81ff">30</span>,
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">partCollection</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#f92672">partCollection</span>{
</span></span><span style="display:flex;"><span>    parts: []<span style="color:#f92672">*</span>part<span style="color:#960050;background-color:#1e0010">{</span>part1, part2, part3}<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">iterator</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">partCollection</span>.<span style="color:#a6e22e">createIterator</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">for</span> <span style="color:#f92672">iterator</span>.<span style="color:#a6e22e">hasNext</span><span style="color:#f92672">()</span> {
</span></span><span style="display:flex;"><span>    part :<span style="color:#f92672">=</span> iterator<span style="color:#f92672">.</span><span style="color:#a6e22e">getNext</span>()
</span></span><span style="display:flex;"><span>    fmt<span style="color:#f92672">.</span><span style="color:#a6e22e">Println</span>(part)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">//</span> <span style="color:#f92672">Output</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">//</span> <span style="color:#f92672">&amp;</span>{<span style="color:#960050;background-color:#1e0010">part1</span> <span style="color:#960050;background-color:#1e0010">10</span>}
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">//</span> <span style="color:#f92672">&amp;</span>{<span style="color:#960050;background-color:#1e0010">part2</span> <span style="color:#960050;background-color:#1e0010">20</span>}
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">//</span> <span style="color:#f92672">&amp;</span>{<span style="color:#960050;background-color:#1e0010">part3</span> <span style="color:#960050;background-color:#1e0010">30</span>}
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">}</span>
</span></span></code></pre></div><h2 id="中介者模式mediator">中介者模式Mediator<a hidden class="anchor" aria-hidden="true" href="#中介者模式mediator">#</a></h2>
<h3 id="问题-15">问题<a hidden class="anchor" aria-hidden="true" href="#问题-15">#</a></h3>
<p>中介者模式试图解决网状关系的复杂关联，降低对象间的耦合度。</p>
<p>举个例子，假设一个十字路口上的车都是对象，它们会执行不同的操作，前往不同的目的地，那么在十字路口指挥的交警就是“中介者”。</p>
<p>各个对象通过执行中介者接口，再由中介者维护对象之间的联系。这能使对象变得更独立，比较适合用在一些对象是网状关系的案例上。</p>
<h3 id="解决-15">解决<a hidden class="anchor" aria-hidden="true" href="#解决-15">#</a></h3>
<p>假设有p1，p2，p3这3个发送者，p1 发送的消息p2能收到，p2 发送的消息p1能收到，p3 发送的消息则p1和p2能收到，如何实现呢？像这种情况就很适合用中介者模式实现。</p>
<p>请看以下代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">mediator</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">p1</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">p1</span>) <span style="color:#a6e22e">getMessage</span>(<span style="color:#a6e22e">data</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;p1 get message: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">data</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">p2</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">p2</span>) <span style="color:#a6e22e">getMessage</span>(<span style="color:#a6e22e">data</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;p2 get message: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">data</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">p3</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">p3</span>) <span style="color:#a6e22e">getMessage</span>(<span style="color:#a6e22e">data</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;p3 get message: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">data</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Message</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">p1</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">p1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">p2</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">p2</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">p3</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">p3</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Message</span>) <span style="color:#a6e22e">sendMessage</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">interface</span>{}, <span style="color:#a6e22e">data</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">i</span>.(<span style="color:#66d9ef">type</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">case</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">p1</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p2</span>.<span style="color:#a6e22e">getMessage</span>(<span style="color:#a6e22e">data</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">case</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">p2</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p1</span>.<span style="color:#a6e22e">getMessage</span>(<span style="color:#a6e22e">data</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">case</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">p3</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p1</span>.<span style="color:#a6e22e">getMessage</span>(<span style="color:#a6e22e">data</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p2</span>.<span style="color:#a6e22e">getMessage</span>(<span style="color:#a6e22e">data</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们定义了p1，p2，p3这3个对象，然后实现了中介者sendMessage。</p>
<p>测试代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">mediator</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">ExampleMediator</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">message</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Message</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">p1</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">p1</span>{}
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">p2</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">p2</span>{}
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">p3</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">p3</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">message</span>.<span style="color:#a6e22e">sendMessage</span>(<span style="color:#a6e22e">p1</span>, <span style="color:#e6db74">&#34;hi! my name is p1&#34;</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">message</span>.<span style="color:#a6e22e">sendMessage</span>(<span style="color:#a6e22e">p2</span>, <span style="color:#e6db74">&#34;hi! my name is p2&#34;</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">message</span>.<span style="color:#a6e22e">sendMessage</span>(<span style="color:#a6e22e">p3</span>, <span style="color:#e6db74">&#34;hi! my name is p3&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Output:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// p2 get message: hi! my name is p1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// p1 get message: hi! my name is p2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// p1 get message: hi! my name is p3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// p2 get message: hi! my name is p3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="备忘录模式memento">备忘录模式Memento<a hidden class="anchor" aria-hidden="true" href="#备忘录模式memento">#</a></h2>
<h3 id="问题-16">问题<a hidden class="anchor" aria-hidden="true" href="#问题-16">#</a></h3>
<p>常用的文字编辑器都支持保存和恢复一段文字的操作，如果我们想要在程序中实现保存和恢复的功能该怎么做呢？</p>
<p>我们需要提供保存和恢复的功能，当保存功能被调用时，就会生成当前对象的快照，在恢复功能被调用时，就会用之前保存的快照覆盖当前的快照。这可以使用备忘录模式来做。</p>
<h3 id="解决-16">解决<a hidden class="anchor" aria-hidden="true" href="#解决-16">#</a></h3>
<p>请看以下代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">memento</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Memento</span> <span style="color:#66d9ef">interface</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Text</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">content</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">textMemento</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">content</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Text</span>) <span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">content</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">content</span> = <span style="color:#a6e22e">content</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Text</span>) <span style="color:#a6e22e">Save</span>() <span style="color:#a6e22e">Memento</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">textMemento</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">content</span>: <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">content</span>,
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Text</span>) <span style="color:#a6e22e">Load</span>(<span style="color:#a6e22e">m</span> <span style="color:#a6e22e">Memento</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">tm</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">textMemento</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">content</span> = <span style="color:#a6e22e">tm</span>.<span style="color:#a6e22e">content</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Text</span>) <span style="color:#a6e22e">Show</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;content:&#34;</span>, <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">content</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们定义了textMemento结构体用于保存当前快照，并在Load方法中将快照覆盖到当前内容。</p>
<p>测试代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-arduino" data-lang="arduino"><span style="display:flex;"><span>package memento
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>func <span style="color:#a6e22e">ExampleText</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">text</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span>Text{
</span></span><span style="display:flex;"><span>    content: <span style="color:#e6db74">&#34;how are you&#34;</span>,
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">text</span>.Show()
</span></span><span style="display:flex;"><span>  progress :<span style="color:#f92672">=</span> <span style="color:#a6e22e">text</span>.Save()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">text</span>.Write(<span style="color:#e6db74">&#34;fine think you and you&#34;</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">text</span>.Show()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">text</span>.Load(progress)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">text</span>.Show()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Output:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// content: how are you
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// content: fine think you and you
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// content: how are you
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="观察者模式observer">观察者模式Observer<a hidden class="anchor" aria-hidden="true" href="#观察者模式observer">#</a></h2>
<h3 id="问题-17">问题<a hidden class="anchor" aria-hidden="true" href="#问题-17">#</a></h3>
<p>如果你需要在一个对象的状态被改变时，其他对象能作为其“观察者”而被通知，就可以使用观察者模式。</p>
<p>我们将自身的状态改变就会通知给其他对象的对象称为“发布者”，关注发布者状态变化的对象则称为“订阅者”。</p>
<h3 id="解决-17">解决<a hidden class="anchor" aria-hidden="true" href="#解决-17">#</a></h3>
<p>请看以下代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">observer</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 发布者
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Subject</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">observers</span> []<span style="color:#a6e22e">Observer</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">content</span>   <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewSubject</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">Subject</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Subject</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">observers</span>: make([]<span style="color:#a6e22e">Observer</span>, <span style="color:#ae81ff">0</span>),
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 添加订阅者
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Subject</span>) <span style="color:#a6e22e">AddObserver</span>(<span style="color:#a6e22e">o</span> <span style="color:#a6e22e">Observer</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">observers</span> = append(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">observers</span>, <span style="color:#a6e22e">o</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 改变发布者的状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Subject</span>) <span style="color:#a6e22e">UpdateContext</span>(<span style="color:#a6e22e">content</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">content</span> = <span style="color:#a6e22e">content</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">notify</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 通知订阅者接口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Observer</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Do</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">Subject</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Subject</span>) <span style="color:#a6e22e">notify</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">o</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">observers</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">Do</span>(<span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 订阅者
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Reader</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewReader</span>(<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">Reader</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Reader</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>: <span style="color:#a6e22e">name</span>,
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Reader</span>) <span style="color:#a6e22e">Do</span>(<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Subject</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; get &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">content</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>很简单，我们只要实现一个通知notify方法，在发布者的状态改变时执行即可。</p>
<p>测试代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">observer</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">ExampleObserver</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">subject</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewSubject</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">boy</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewReader</span>(<span style="color:#e6db74">&#34;小明&#34;</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">girl</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewReader</span>(<span style="color:#e6db74">&#34;小美&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">subject</span>.<span style="color:#a6e22e">AddObserver</span>(<span style="color:#a6e22e">boy</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">subject</span>.<span style="color:#a6e22e">AddObserver</span>(<span style="color:#a6e22e">girl</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">subject</span>.<span style="color:#a6e22e">UpdateContext</span>(<span style="color:#e6db74">&#34;hi~&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Output:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// 小明 get hi~
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// 小美 get hi~
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="状态模式-state">状态模式 State<a hidden class="anchor" aria-hidden="true" href="#状态模式-state">#</a></h2>
<h3 id="问题-18">问题<a hidden class="anchor" aria-hidden="true" href="#问题-18">#</a></h3>
<p>如果一个对象的实现方法会根据自身的状态而改变，就可以使用状态模式。</p>
<p>举个例子：假设有一个开门的方法，门的状态在一开始是“关闭”，你可以执行open方法和close方法，当你执行了open方法，门的状态就变成了“开启”，再执行open方法就不会执行开门的功能，而是返回“门已开启”，如果执行close方法，门的状态就变成了“关闭”，再执行close方法就不会执行关门的功能，而是返回“门已关闭”。这是一个简单的例子，我们将为每个状态提供不同的实现方法，将这些方法组织起来很麻烦，如果状态也越来越多呢？无疑，这将会使代码变得臃肿。</p>
<h3 id="解决-18">解决<a hidden class="anchor" aria-hidden="true" href="#解决-18">#</a></h3>
<p>如果我们需要为一个门对象提供3种状态下的open和close方法：</p>
<ul>
<li>“开启”状态下，open方法返回“门已开启”，close方法返回“关闭成功”。</li>
<li>“关闭”状态下，open方法返回“开启成功”，close方法返回“门已关闭”。</li>
<li>“损坏”状态下，open方法返回“门已损坏，无法开启”，close方法返回“门已损坏，无法关闭”。</li>
</ul>
<p>请看以下代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">state</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 不同状态需要实现的接口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">state</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">open</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">door</span>)
</span></span><span style="display:flex;"><span>  close(<span style="color:#f92672">*</span><span style="color:#a6e22e">door</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 门对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">door</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">opened</span>  <span style="color:#a6e22e">state</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">closed</span>  <span style="color:#a6e22e">state</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">damaged</span> <span style="color:#a6e22e">state</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">currentState</span> <span style="color:#a6e22e">state</span> <span style="color:#75715e">// 当前状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">d</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">door</span>) <span style="color:#a6e22e">open</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">currentState</span>.<span style="color:#a6e22e">open</span>(<span style="color:#a6e22e">d</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">d</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">door</span>) close() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">currentState</span>.close(<span style="color:#a6e22e">d</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">d</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">door</span>) <span style="color:#a6e22e">setState</span>(<span style="color:#a6e22e">s</span> <span style="color:#a6e22e">state</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">currentState</span> = <span style="color:#a6e22e">s</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 开启状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">opened</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">o</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">opened</span>) <span style="color:#a6e22e">open</span>(<span style="color:#a6e22e">d</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">door</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;门已开启&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">o</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">opened</span>) close(<span style="color:#a6e22e">d</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">door</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;关闭成功&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 关闭状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">closed</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">closed</span>) <span style="color:#a6e22e">open</span>(<span style="color:#a6e22e">d</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">door</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;开启成功&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">closed</span>) close(<span style="color:#a6e22e">d</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">door</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;门已关闭&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 损坏状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">damaged</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">damaged</span>) <span style="color:#a6e22e">open</span>(<span style="color:#a6e22e">d</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">door</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;门已损坏，无法开启&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">damaged</span>) close(<span style="color:#a6e22e">d</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">door</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;门已损坏，无法关闭&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们的门对象door实现了open和close方法，在方法中，只需要调用当前状态currentState的open和close方法即可。</p>
<p>测试代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scss" data-lang="scss"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#f92672">state</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">func</span> <span style="color:#f92672">ExampleState</span><span style="color:#f92672">()</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">door</span> <span style="color:#a6e22e">:</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">door</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 开启状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#f92672">opened</span> <span style="color:#a6e22e">:</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">opened</span>{}
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">door</span><span style="color:#a6e22e">.setState</span><span style="color:#f92672">(</span><span style="color:#f92672">opened</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">door</span><span style="color:#a6e22e">.open</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">door</span><span style="color:#a6e22e">.close</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">//</span> <span style="color:#960050;background-color:#1e0010">关闭状态</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">closed</span> <span style="color:#a6e22e">:</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">closed</span>{}
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">door</span><span style="color:#a6e22e">.setState</span><span style="color:#f92672">(</span><span style="color:#f92672">closed</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">door</span><span style="color:#a6e22e">.open</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">door</span><span style="color:#a6e22e">.close</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">//</span> <span style="color:#960050;background-color:#1e0010">损坏状态</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">damaged</span> <span style="color:#a6e22e">:</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">damaged</span>{}
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">door</span><span style="color:#a6e22e">.setState</span><span style="color:#f92672">(</span><span style="color:#f92672">damaged</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">door</span><span style="color:#a6e22e">.open</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">door</span><span style="color:#a6e22e">.close</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">//</span> <span style="color:#f92672">Output</span><span style="color:#a6e22e">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">//</span> <span style="color:#960050;background-color:#1e0010">门已开启</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">//</span> <span style="color:#960050;background-color:#1e0010">关闭成功</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">//</span> <span style="color:#960050;background-color:#1e0010">开启成功</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">//</span> <span style="color:#960050;background-color:#1e0010">门已关闭</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">//</span> <span style="color:#960050;background-color:#1e0010">门已损坏，无法开启</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">//</span> <span style="color:#960050;background-color:#1e0010">门已损坏，无法关闭</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="策略模式strategy">策略模式Strategy<a hidden class="anchor" aria-hidden="true" href="#策略模式strategy">#</a></h2>
<h3 id="问题-19">问题<a hidden class="anchor" aria-hidden="true" href="#问题-19">#</a></h3>
<p>假设需要实现一组出行的功能，出现的方案可以选择步行、骑行、开车，最简单的做法就是分别实现这3种方法供客户端调用。但这样做就使对象与其代码实现变得耦合了，客户端需要决定出行方式，然后决定调用步行出行、骑行出行、开车出行等方法，这不符合<strong>开闭原则</strong>。</p>
<p>而策略模式的区别在于，它会将这些出行方案抽取到一组被称为策略的类中，客户端还是调用同一个出行对象，不需要关注实现细节，只需要在参数中指定所需的策略即可。</p>
<h3 id="解决-19">解决<a hidden class="anchor" aria-hidden="true" href="#解决-19">#</a></h3>
<p>请看以下代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">strategy</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Travel</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">name</span>     <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">strategy</span> <span style="color:#a6e22e">Strategy</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewTravel</span>(<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">strategy</span> <span style="color:#a6e22e">Strategy</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">Travel</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Travel</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span>:     <span style="color:#a6e22e">name</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">strategy</span>: <span style="color:#a6e22e">strategy</span>,
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Travel</span>) <span style="color:#a6e22e">traffic</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">strategy</span>.<span style="color:#a6e22e">traffic</span>(<span style="color:#a6e22e">p</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Strategy</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">traffic</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">Travel</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Walk</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">w</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Walk</span>) <span style="color:#a6e22e">traffic</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Travel</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; walk&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Ride</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">w</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Ride</span>) <span style="color:#a6e22e">traffic</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Travel</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; ride&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Drive</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">w</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Drive</span>) <span style="color:#a6e22e">traffic</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Travel</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; drive&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们定义了strategy一组策略接口，为其实现了Walk、Ride、Drive算法。客户端只需要执行traffic方法即可，无需关注实现细节。</p>
<p>测试代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">strategy</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">ExampleTravel</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">walk</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Walk</span>{}
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Travel1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewTravel</span>(<span style="color:#e6db74">&#34;小明&#34;</span>, <span style="color:#a6e22e">walk</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Travel1</span>.<span style="color:#a6e22e">traffic</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">ride</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Ride</span>{}
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Travel2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewTravel</span>(<span style="color:#e6db74">&#34;小美&#34;</span>, <span style="color:#a6e22e">ride</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Travel2</span>.<span style="color:#a6e22e">traffic</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">drive</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Drive</span>{}
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Travel3</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewTravel</span>(<span style="color:#e6db74">&#34;小刚&#34;</span>, <span style="color:#a6e22e">drive</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Travel3</span>.<span style="color:#a6e22e">traffic</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Output:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// 小明 walk
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// 小美 ride
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// 小刚 drive
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="模板方法模式template-method">模板方法模式Template Method<a hidden class="anchor" aria-hidden="true" href="#模板方法模式template-method">#</a></h2>
<h3 id="问题-20">问题<a hidden class="anchor" aria-hidden="true" href="#问题-20">#</a></h3>
<p>模板方法模式就是将算法分解为一系列步骤，然后在一个模版方法中依次调用这些步骤。这样客户端就不需要了解各个步骤的实现细节，只需要调用模版即可。</p>
<h3 id="解决-20">解决<a hidden class="anchor" aria-hidden="true" href="#解决-20">#</a></h3>
<p>一个非常简单的例子，请看以下代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">templatemethod</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PrintTemplate</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Print</span>(<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">template</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">isTemplate</span> <span style="color:#a6e22e">PrintTemplate</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">name</span>       <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">template</span>) <span style="color:#a6e22e">Print</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">isTemplate</span>.<span style="color:#a6e22e">Print</span>(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">name</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">A</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">A</span>) <span style="color:#a6e22e">Print</span>(<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;a: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">name</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 业务代码……
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">B</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">B</span>) <span style="color:#a6e22e">Print</span>(<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;b: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">name</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 业务代码……
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>测试代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-arduino" data-lang="arduino"><span style="display:flex;"><span>package templatemethod
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>func <span style="color:#a6e22e">ExamplePrintTemplate</span>() {
</span></span><span style="display:flex;"><span>  templateA :<span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>A{}
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">template</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">template</span>{
</span></span><span style="display:flex;"><span>    isTemplate: templateA,
</span></span><span style="display:flex;"><span>    name:       <span style="color:#e6db74">&#34;hi~&#34;</span>,
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">template</span>.Print()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  templateB :<span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>B{}
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">template</span>.isTemplate <span style="color:#f92672">=</span> templateB
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">template</span>.Print()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Output:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// a: hi~
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// b: hi~
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="访问者模式visitor">访问者模式Visitor<a hidden class="anchor" aria-hidden="true" href="#访问者模式visitor">#</a></h2>
<h3 id="问题-21">问题<a hidden class="anchor" aria-hidden="true" href="#问题-21">#</a></h3>
<p>访问者模式试图解决这样一个问题：在不改变类的对象结构的前提下增加新的操作。</p>
<h3 id="解决-21">解决<a hidden class="anchor" aria-hidden="true" href="#解决-21">#</a></h3>
<p>请看以下代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scss" data-lang="scss"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#f92672">visitor</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">type</span> <span style="color:#f92672">Shape</span> <span style="color:#f92672">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">accept</span><span style="color:#f92672">(</span><span style="color:#f92672">visitor</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">type</span> <span style="color:#f92672">square</span> <span style="color:#f92672">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">func</span> <span style="color:#f92672">(</span><span style="color:#f92672">s</span> <span style="color:#f92672">*</span><span style="color:#f92672">square</span><span style="color:#f92672">)</span> <span style="color:#f92672">accept</span><span style="color:#f92672">(</span><span style="color:#f92672">v</span> <span style="color:#f92672">visitor</span><span style="color:#f92672">)</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">v</span><span style="color:#a6e22e">.visitForSquare</span><span style="color:#f92672">(</span><span style="color:#f92672">s</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">type</span> <span style="color:#f92672">circle</span> <span style="color:#f92672">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">func</span> <span style="color:#f92672">(</span><span style="color:#f92672">c</span> <span style="color:#f92672">*</span><span style="color:#f92672">circle</span><span style="color:#f92672">)</span> <span style="color:#f92672">accept</span><span style="color:#f92672">(</span><span style="color:#f92672">v</span> <span style="color:#f92672">visitor</span><span style="color:#f92672">)</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">v</span><span style="color:#a6e22e">.visitForCircle</span><span style="color:#f92672">(</span><span style="color:#f92672">c</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">type</span> <span style="color:#f92672">visitor</span> <span style="color:#f92672">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">visitForSquare</span><span style="color:#f92672">(*</span><span style="color:#f92672">square</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">visitForCircle</span><span style="color:#f92672">(*</span><span style="color:#f92672">circle</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">type</span> <span style="color:#f92672">sideCalculator</span> <span style="color:#f92672">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">func</span> <span style="color:#f92672">(</span><span style="color:#f92672">a</span> <span style="color:#f92672">*</span><span style="color:#f92672">sideCalculator</span><span style="color:#f92672">)</span> <span style="color:#f92672">visitForSquare</span><span style="color:#f92672">(</span><span style="color:#f92672">s</span> <span style="color:#f92672">*</span><span style="color:#f92672">square</span><span style="color:#f92672">)</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">fmt</span><span style="color:#a6e22e">.Println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;square side&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">func</span> <span style="color:#f92672">(</span><span style="color:#f92672">a</span> <span style="color:#f92672">*</span><span style="color:#f92672">sideCalculator</span><span style="color:#f92672">)</span> <span style="color:#f92672">visitForCircle</span><span style="color:#f92672">(</span><span style="color:#f92672">s</span> <span style="color:#f92672">*</span><span style="color:#f92672">circle</span><span style="color:#f92672">)</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">fmt</span><span style="color:#a6e22e">.Println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;circle side&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">type</span> <span style="color:#f92672">radiusCalculator</span> <span style="color:#f92672">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">func</span> <span style="color:#f92672">(</span><span style="color:#f92672">a</span> <span style="color:#f92672">*</span><span style="color:#f92672">radiusCalculator</span><span style="color:#f92672">)</span> <span style="color:#f92672">visitForSquare</span><span style="color:#f92672">(</span><span style="color:#f92672">s</span> <span style="color:#f92672">*</span><span style="color:#f92672">square</span><span style="color:#f92672">)</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">fmt</span><span style="color:#a6e22e">.Println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;square radius&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">func</span> <span style="color:#f92672">(</span><span style="color:#f92672">a</span> <span style="color:#f92672">*</span><span style="color:#f92672">radiusCalculator</span><span style="color:#f92672">)</span> <span style="color:#f92672">visitForCircle</span><span style="color:#f92672">(</span><span style="color:#f92672">c</span> <span style="color:#f92672">*</span><span style="color:#f92672">circle</span><span style="color:#f92672">)</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">fmt</span><span style="color:#a6e22e">.Println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;circle radius&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>测试代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scss" data-lang="scss"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#f92672">visitor</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">func</span> <span style="color:#f92672">ExampleShape</span><span style="color:#f92672">()</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">square</span> <span style="color:#a6e22e">:</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">square</span>{}
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">circle</span> <span style="color:#a6e22e">:</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">circle</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">side</span> <span style="color:#a6e22e">:</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">sideCalculator</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">square</span><span style="color:#a6e22e">.accept</span><span style="color:#f92672">(</span><span style="color:#f92672">side</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">circle</span><span style="color:#a6e22e">.accept</span><span style="color:#f92672">(</span><span style="color:#f92672">side</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">radius</span> <span style="color:#a6e22e">:</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">radiusCalculator</span>{}
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">square</span><span style="color:#a6e22e">.accept</span><span style="color:#f92672">(</span><span style="color:#f92672">radius</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">circle</span><span style="color:#a6e22e">.accept</span><span style="color:#f92672">(</span><span style="color:#f92672">radius</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">//</span> <span style="color:#f92672">Output</span><span style="color:#a6e22e">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">//</span> <span style="color:#f92672">square</span> <span style="color:#f92672">side</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">//</span> <span style="color:#f92672">circle</span> <span style="color:#f92672">side</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">//</span> <span style="color:#f92672">square</span> <span style="color:#f92672">radius</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">//</span> <span style="color:#f92672">circle</span> <span style="color:#f92672">radius</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="设计模式的道">设计模式的“道”<a hidden class="anchor" aria-hidden="true" href="#设计模式的道">#</a></h1>
<p>上面那么多种设计模式你能记住几种呢？设计模式分为“术”的部分和“道”的部分，上面那些设计模式就是“术”的部分，他们是一些围绕着设计模式核心思路的经典解决方案。换句话说，重要的是理解为什么要用那些设计模式，具体问题，具体分析，而不是把某种设计模式生搬硬套进代码。</p>
<p>设计模式有6大原则，以上的设计模式目的就是为了使软件系统能达到这些原则：</p>
<h2 id="开闭原则">开闭原则<a hidden class="anchor" aria-hidden="true" href="#开闭原则">#</a></h2>
<p>软件应该对扩展开放，对修改关闭。</p>
<p>对系统进行扩展，而无需修改现有的代码。这可以降低软件的维护成本，同时也增加可扩展性。</p>
<h2 id="里氏替换原则">里氏替换原则<a hidden class="anchor" aria-hidden="true" href="#里氏替换原则">#</a></h2>
<p>任何基类可以出现的地方，子类一定可以出现。</p>
<p>里氏替换原则是对开闭原则的补充，实现开闭原则的关键步骤就是抽象化，基类与子类的关系就是要尽可能的抽象化。</p>
<h2 id="依赖倒置原则">依赖倒置原则<a hidden class="anchor" aria-hidden="true" href="#依赖倒置原则">#</a></h2>
<p>面向接口编程，抽象不应该依赖于具体类，具体类应当依赖于抽象。</p>
<p>这是为了减少类间的耦合，使系统更适宜于扩展，也更便于维护。</p>
<h2 id="单一职责原则">单一职责原则<a hidden class="anchor" aria-hidden="true" href="#单一职责原则">#</a></h2>
<p>一个类应该只有一个发生变化的原因。</p>
<p>一个类承载的越多，耦合度就越高。如果类的职责单一，就可以降低出错的风险，也可以提高代码的可读性。</p>
<h2 id="最少知道原则">最少知道原则<a hidden class="anchor" aria-hidden="true" href="#最少知道原则">#</a></h2>
<p>一个实体应当尽量少地与其他实体之间发生相互作用。</p>
<p>还是为了降低耦合，一个类与其他类的关联越少，越易于扩展。</p>
<h2 id="接口分离原则">接口分离原则<a hidden class="anchor" aria-hidden="true" href="#接口分离原则">#</a></h2>
<p>使用多个专门的接口，而不使用高耦合的单一接口。</p>
<p>避免同一个接口占用过多的职责，更明确的划分，可以降低耦合。高耦合会导致程序不易扩展，提高出错的风险。</p>


        </div>

        <footer class="post-footer">
            
<nav class="paginav">
  <a class="prev" href="https://liiqii.github.io/posts/tech/git/git/">
    <span class="title">« 上一页</span>
    <br>
    <span>Git 命令详解</span>
  </a>
  <a class="next" href="https://liiqii.github.io/posts/tech/go/go_channel/">
    <span class="title">下一页 »</span>
    <br>
    <span>Go Channel详解</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Go 23种设计模式 on twitter"
       href="https://twitter.com/intent/tweet/?text=Go%2023%e7%a7%8d%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f&amp;url=https%3a%2f%2fliiqii.github.io%2fposts%2ftech%2fgo%2fgo_design_mode%2f&amp;hashtags=Go%2c%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f">
    <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Go 23种设计模式 on linkedin"
       href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fliiqii.github.io%2fposts%2ftech%2fgo%2fgo_design_mode%2f&amp;title=Go%2023%e7%a7%8d%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f&amp;summary=Go%2023%e7%a7%8d%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f&amp;source=https%3a%2f%2fliiqii.github.io%2fposts%2ftech%2fgo%2fgo_design_mode%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Go 23种设计模式 on reddit"
       href="https://reddit.com/submit?url=https%3a%2f%2fliiqii.github.io%2fposts%2ftech%2fgo%2fgo_design_mode%2f&title=Go%2023%e7%a7%8d%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Go 23种设计模式 on facebook"
       href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fliiqii.github.io%2fposts%2ftech%2fgo%2fgo_design_mode%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Go 23种设计模式 on whatsapp"
       href="https://api.whatsapp.com/send?text=Go%2023%e7%a7%8d%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%20-%20https%3a%2f%2fliiqii.github.io%2fposts%2ftech%2fgo%2fgo_design_mode%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Go 23种设计模式 on telegram"
       href="https://telegram.me/share/url?text=Go%2023%e7%a7%8d%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f&amp;url=https%3a%2f%2fliiqii.github.io%2fposts%2ftech%2fgo%2fgo_design_mode%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

        </footer>
    </div>

<style>
    .comments_details summary::marker {
        font-size: 20px;
        content: '👉展开评论';
        color: var(--content);
    }
    .comments_details[open] summary::marker{
        font-size: 20px;
        content: '👇关闭评论';
        color: var(--content);
    }
</style>


<div>
    <details class="comments_details">
        <summary style="cursor: pointer; margin: 50px 0 20px 0;width: 130px;">
            <span style="font-size: 20px;color: var(--content);">...</span>
        </summary>
        <div id="tcomment"></div>
    </details>
    <script src="https://cdn.staticfile.org/twikoo/1.5.8/twikoo.all.min.js">
    </script>
    <script>
        twikoo.init({
            envId:  null ,
        el: "#tcomment",
            lang: 'zh-CN',
            region:  null ,
        path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
        })
    </script>
</div>
</article>
</main>

<footer class="footer">
    <span>
        &copy;
        -2023
        <a href="https://liiqii.github.io/" style="color:#939393;">liiqii</a>
    </span>
    
    <span>Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &amp;
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
    
</footer>












</body>

</html>
